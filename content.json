{"meta":{"title":"Dy_RisingSunlight","subtitle":"I am Dy.","description":"拼一个春夏秋冬，搏一个无怨无悔！路漫漫其修远兮，吾将上下而求索。","author":"dy.","url":"https://dyrisingsunlight.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-09-17T14:39:02.077Z","updated":"2019-09-17T14:39:02.077Z","comments":true,"path":"about/index.html","permalink":"https://dyrisingsunlight.github.io/about/index.html","excerpt":"","text":"我是$\\mathcal{Dy}$，山东NOIP提高组$\\mathrm{CSP-S \\ OIer}$，于$2017$年省选前入役。本博客记录了本人学习信竞时部分题解及学习笔记。祝你$\\mathrm{rp++}$！"},{"title":"分类","date":"2019-08-01T14:08:47.700Z","updated":"2019-08-01T14:08:47.700Z","comments":true,"path":"categories/index.html","permalink":"https://dyrisingsunlight.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-01T12:41:22.538Z","updated":"2019-08-01T12:41:22.538Z","comments":true,"path":"tags/index.html","permalink":"https://dyrisingsunlight.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"20190916模拟赛T1 求和","slug":"20190916模拟赛求和","date":"2019-09-15T16:00:00.000Z","updated":"2019-09-19T15:58:42.298Z","comments":true,"path":"2019/09/16/20190916模拟赛求和/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/09/16/20190916模拟赛求和/","excerpt":"$\\mathrm{Problem’s\\ Website}$求和（洛谷） [HAOI2012]容易题(easy)（大视野评测） $\\mathrm{Problem’s \\ Description}$有一个数列，有$m$个元素，每个元素为$1 \\thicksim n$，其中有$k$个限制，使第$i$个元素不能取$num$，问所有排列方案的每个元素的乘积和。","text":"$\\mathrm{Problem’s\\ Website}$求和（洛谷） [HAOI2012]容易题(easy)（大视野评测） $\\mathrm{Problem’s \\ Description}$有一个数列，有$m$个元素，每个元素为$1 \\thicksim n$，其中有$k$个限制，使第$i$个元素不能取$num$，问所有排列方案的每个元素的乘积和。 $\\mathrm{Solution}$一看这道题，感觉毫无思路，于是我们来推一下式子，我们假设$n=2,m=2,k=0$，设$A$为第一个元素可能的值的集合，$B$为第二个元素可能的值，那我们不难得出 $ans=A_1 \\times B_1 + A_1 \\times B_2 + A_2 \\times B_1 + A_2 \\times B_2$ $\\Rightarrow \\ A_1 \\times (B_1 + B_2) \\times A_2 \\times (B_1 + B_2)$ $\\Rightarrow \\ (A_1 + A_2) \\times (B_1 + B_2)$ 当我们推出这个式子时，我们可以已经拿到$70$分的好成绩了，但想要$\\mathrm{AC}$还要再进行优化，虽然$n$的范围很大，但是$k$的范围并不大，于是我们可以单独处理$k$，因为如果没有任何限制，那么$A_1 + A_2 \\ == \\ B_1 + B_2$，所以除了有限制的元素，其他的元素是一样的，所以我们可以直接快速幂求解，然后我们记录一下有限制的元素的编号和限制的数值，单独处理即可$\\mathrm{AC}$。 总结一下式子： $ans=((1 + n) n / 2) ^ {m - cnt} \\times \\prod\\limits^{cnt}_{i=1}{((1+n)n/2) - a[i]}$ $cnt$为去重后限制元素的个数，$a$数组为限制的值的和。 最后温馨提示：取模要注意负数 &amp; 要开$\\mathrm{long\\ long}$ $\\mathrm{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//Coded by Dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)typedef long long ll;inline ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(ll x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;const int Maxk = 1e5 + 10;const int mod = 1000000007LL;#define re registerstruct LIM &#123; ll id, num; bool operator &lt; (const LIM &amp;x) const &#123; if(id == x.id) return num &lt; x.num; return id &lt; x.id; &#125;&#125;lim[Maxk];ll n, m, k, cnt, ans = 1LL;ll a[Maxk];inline ll qw(ll x, ll y) &#123; ll ans = 1LL, base = (x % mod); while(y) &#123; if(y &amp; 1) ans = (ans * base) % mod; base = (base * base) % mod; y &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123;// freopen(\"sum.in\", \"r\", stdin);// freopen(\"sum.out\", \"w\", stdout); n = sc(), m = sc(), k = sc(); for(re int i = 1; i &lt;= k; ++i) &#123; ll x = sc(), y = sc(); lim[i].id = x, lim[i].num = y; &#125; std :: sort(lim + 1, lim + k + 1); for(re int i = 1; i &lt;= k; ++i) &#123; if(lim[i].id == lim[i - 1].id) &#123; if(lim[i].num == lim[i - 1].num) continue; a[cnt] += lim[i].num; &#125; else &#123; a[++cnt] += lim[i].num; &#125; &#125; ll tmp = (((1LL + n) * n) &gt;&gt; 1) % mod; ans = qw(tmp, (m - cnt)); for(re int i = 1; i &lt;= cnt; ++i) &#123; ans = (ans * (tmp - a[i] + mod) % mod) % mod; &#125; out(ans), pc('\\n'); return 0;&#125; $\\mathrm{rp++}$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://dyrisingsunlight.github.io/tags/数学/"}]},{"title":"模板_文艺平衡树(fhq-Treap)","slug":"文艺平衡树fhq-Treap","date":"2019-09-13T16:00:00.000Z","updated":"2019-09-16T04:31:16.071Z","comments":true,"path":"2019/09/14/文艺平衡树fhq-Treap/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/09/14/文艺平衡树fhq-Treap/","excerpt":"$Problem’s\\ Website$文艺平衡树（洛谷） 文艺平衡树（$\\mathbb{LOJ}$） $Problem’s\\ Description$ 给定一个序列，每次操作使区间[$l - r$]翻转。","text":"$Problem’s\\ Website$文艺平衡树（洛谷） 文艺平衡树（$\\mathbb{LOJ}$） $Problem’s\\ Description$ 给定一个序列，每次操作使区间[$l - r$]翻转。 $Solution$因为本人暂时不会$\\mathfrak{Splay}$，所以这题我用$\\mathfrak{fhq-Treap}$来写。 思路还是比较明确的，将要翻转的区间分裂出来，然后维护一个翻转标记（类似于线段树的$\\mathrm{Lazy\\ Tag}$）。 关于如何分裂，大家可以打一下草，我们先以$l - 1$将区间分成$r1,r2$两段，再在$r2$的区间中以序列长度($r-l+1$)分成$r2,r3$两段，那么$r2$就是目标区间。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//Coded by Dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;#define re registerusing std :: swap;const int Maxn = 1e5 + 10;int n, m;int rt, r1, r2, r3, tot;int ch[Maxn][2], val[Maxn], dat[Maxn], siz[Maxn];bool tag[Maxn];inline void pushup(int id) &#123; siz[id] = siz[ch[id][0]] + siz[ch[id][1]] + 1;&#125;inline int cre(int k) &#123; siz[++tot] = 1, val[tot] = k, dat[tot] = rand(); return tot;&#125;inline void pushdown(int id) &#123; if(!tag[id]) return; swap(ch[id][0], ch[id][1]); if(ch[id][0])// pushdown(ch[id][0]); tag[ch[id][0]] ^= 1; if(ch[id][1])// pushdown(ch[id][1]); tag[ch[id][1]] ^= 1; tag[id] = 0;&#125;inline void split(int id, int k, int &amp;x,int &amp;y) &#123; if(!id) x = y = 0; else &#123; if(tag[id]) pushdown(id); if(siz[ch[id][0]] + 1 &lt;= k) &#123; x = id; split(ch[id][1], k - siz[ch[id][0]] - 1, ch[id][1], y); &#125; else &#123; y = id; split(ch[id][0], k, x, ch[id][0]); &#125; pushup(id); &#125;&#125;inline int merge(int x, int y) &#123; if(!x || !y) return x + y; if(dat[x] &lt; dat[y]) &#123; if(tag[x]) pushdown(x); ch[x][1] = merge(ch[x][1], y); pushup(x); return x; &#125; if(tag[y]) pushdown(y); ch[y][0] = merge(x, ch[y][0]); pushup(y); return y;&#125;inline void flist(int id) &#123; if(!id) return; if(tag[id]) pushdown(id); flist(ch[id][0]); out(val[id]), pc(' '); flist(ch[id][1]);&#125;int main() &#123; srand(20041029); n = sc(), m = sc(); for(re int i = 1; i &lt;= n; ++i) rt = merge(rt, cre(i)); while(m--) &#123; int l = sc(), r = sc(); split(rt, l - 1, r1, r2); split(r2, r - l + 1, r2, r3); tag[r2] ^= 1; rt = merge(r1, merge(r2, r3)); &#125; flist(rt); return 0;&#125; $\\mathrm{rp++}$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"fhq-Treap","slug":"fhq-Treap","permalink":"https://dyrisingsunlight.github.io/tags/fhq-Treap/"}]},{"title":"20190830模拟赛 幻方","slug":"20190830模拟赛幻方","date":"2019-08-31T16:00:00.000Z","updated":"2019-09-19T15:54:05.262Z","comments":true,"path":"2019/09/01/20190830模拟赛幻方/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/09/01/20190830模拟赛幻方/","excerpt":"$Problem’s \\ Website$幻方 $Problem’s \\ Description$给一个$n \\times n$的矩阵，将其中的数任意摆放，使其每行、每列、两条对角线所有数之和相等。","text":"$Problem’s \\ Website$幻方 $Problem’s \\ Description$给一个$n \\times n$的矩阵，将其中的数任意摆放，使其每行、每列、两条对角线所有数之和相等。 $Solution$首先我们要确定那个相等的和是多少，还是比较好算的，即$lim = tot \\div n,\\ tot=\\sum\\limits_{i=1}^{n\\times n}{a[i]}$。 因为$n$不是$3$就是$4$，所以我们可以暴力枚举一遍，找出可以拼凑成$lim$的数，用一个变量记录次数，然后按照次数进行降序排序。 最后我们进行$dfs$，下面说一下怎样剪枝 首先明确，我们是一行一行的搜，即对于$x$，先把$y$搜完。 如果一行搜完，这一行的和不为$lim$，再见。 如果当前位置处于对角线，那么要求次数$&gt; 3$，否则，再见。 在倒数第二行时，判断最后一行是否可以使当前的列之和为$lim$，否则，再见。 最后，温馨提示：写搜索时一定要思路清晰，否则后果不堪设想。。。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#define re registertypedef long long ll;const int Maxn = 10;struct MAP &#123; ll val; int times; bool operator &lt; (const MAP &amp;x) const &#123; return times &gt; x.times; &#125;&#125;a[Maxn * Maxn];int n;ll lim;ll sumx[Maxn], sumy[Maxn], s[Maxn][Maxn];bool vis[Maxn * Maxn];inline void D_F() &#123; if(n == 4) &#123; for(re int i = 1; i &lt;= n * n; ++i) for(re int j = i + 1; j &lt;= n * n; ++j) for(re int k = j + 1; k &lt;= n * n; ++k) for(re int l = k + 1; l &lt;= n * n; ++l) &#123; if(a[i].val + a[j].val + a[k].val + a[l].val == lim) ++a[i].times, ++a[j].times, ++a[k].times, ++a[l].times; &#125; &#125; else &#123; for(re int i = 1; i &lt;= n * n; ++i) for(re int j = i + 1; j &lt;= n * n; ++j) for(re int k = j + 1; k &lt;= n * n; ++k) &#123; if(a[i].val + a[j].val + a[k].val == lim) ++a[i].times, ++a[j].times, ++a[k].times; &#125; &#125;&#125;inline bool check(int y) &#123; for(re int i = 1; i &lt;= n * n; ++i) &#123; if(sumy[y] + a[i].val == lim &amp;&amp; !vis[i]) return 0; &#125; return 1;&#125;inline void dfs(int x, int y) &#123;// std :: cerr &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; '\\n'; if(y &gt; n) &#123; if(sumx[x] != lim) return; dfs(x + 1, 1); return; &#125; if(x &gt; n) &#123; ll sum1 = 0, sum2 = 0; for(re int i = 1; i &lt;= n; ++i) sum1 += s[i][n - i + 1], sum2 += s[i][i]; if(sum1 == sum2 &amp;&amp; sum1 == lim) &#123; for(re int i = 1; i &lt;= n; ++i) &#123; for(re int j = 1; j &lt;= n; ++j) printf(\"%lld \", s[i][j]); putchar('\\n'); &#125; exit(0); &#125; return; &#125; for(re int i = 1; i &lt;= n * n; ++i) &#123; if(vis[i]) continue; if(x == n) &#123; if(sumy[y] + a[i].val == lim) &#123; s[x][y] = a[i].val; if((x == n - y + 1 || x == y) &amp;&amp; a[i].times &lt; 3) continue; sumx[x] += a[i].val; sumy[y] += a[i].val; vis[i] = 1; dfs(x, y + 1); sumx[x] -= a[i].val; sumy[y] -= a[i].val; vis[i] = 0; &#125; &#125; else &#123; s[x][y] = a[i].val; if((x == n - y + 1 || x == y) &amp;&amp; a[i].times &lt; 3) continue; sumx[x] += a[i].val; sumy[y] += a[i].val; if(x == n - 1 &amp;&amp; check(y)) &#123; sumx[x] -= a[i].val; sumy[y] -= a[i].val; continue; &#125; vis[i] = 1; dfs(x, y + 1); sumx[x] -= a[i].val; sumy[y] -= a[i].val; vis[i] = 0; &#125; &#125;&#125;int main() &#123;// freopen(\"magicsquare.in\", \"r\", stdin);// freopen(\"magicsquare.out\", \"w\", stdout); scanf(\"%d\", &amp;n); for(re int i = 1; i &lt;= n * n; ++i) &#123; scanf(\"%lld\", &amp;a[i].val); lim += a[i].val; &#125; lim /= n; D_F(); std :: sort(a + 1, a + n * n + 1);// std :: cerr &lt;&lt; lim; dfs(1, 1); return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://dyrisingsunlight.github.io/tags/dfs/"},{"name":"数学","slug":"数学","permalink":"https://dyrisingsunlight.github.io/tags/数学/"}]},{"title":"20190830模拟赛统计","slug":"20190830模拟赛统计","date":"2019-08-30T16:00:00.000Z","updated":"2019-08-31T14:54:16.364Z","comments":true,"path":"2019/08/31/20190830模拟赛统计/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/31/20190830模拟赛统计/","excerpt":"$Problem’s$ $Website$统计 （没有权限查看题目的同学不要打我） $Solution$这道题是一道 思想 + 码农 题，很不错。 题意清楚明了，但做法却十分复杂。。。","text":"$Problem’s$ $Website$统计 （没有权限查看题目的同学不要打我） $Solution$这道题是一道 思想 + 码农 题，很不错。 题意清楚明了，但做法却十分复杂。。。 根据数据范围$n \\le 50$，我们得出结论——要用高精度计算。 因为有前导$0$ 的存在，所以对于$k\\ =\\ 0$时要单独讨论。 下面详细说一下做法。 $k\\ =\\ 0$ 当$k\\ =\\ 0$时，我们发现，只要有一位是$0$就符合要求，对于$n$位数，根据乘法原理，一共有$\\prod\\limits_{i=1}^{n}{10}$种方案数，其中不包含$0$的有$\\prod\\limits_{i=1}^{n}{9}$种，所以答案作差即可。 $k\\ \\neq\\ 0$ 当$k\\ \\neq\\ 0$时，我们考虑进行$dp$，不难得出状态$f[i][j]$为第$i$位组成$j$的方案数，然而观察数据范围，我们发现$k \\le 10^9$，那么这样是定义不了数组的，于是我们想改善，我们可以把$k$分解因数，$f[i][j]$为第$i$位由第$j$个因数所能组成数的方案数，首先用一个数组存因数并且进行排序，然后第一遍枚举位数，第二遍枚举因数个数，第三遍枚举$1-9$(因为一位最多到$9$，用这些数去$\\times$当前循环到的因数来转移状态)，如果当前乘出来的数也是一个因数，那么$f[i + 1][temp]\\ += \\ f[i][j];$，最后答案即为$f[n][cnt]$($cnt$为因数个数)。 最后再次强调，这道题要写高精度！！！ 同时注意定义变量的细节！！！ $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int n, k, cnt;long long num[1010];#define re registerconst int mod = 1e4;struct HN &#123; int p[60], len; HN() &#123; len = 0; memset(p, 0, sizeof(p)); &#125; inline void print() &#123; printf(\"%d\", p[len]); for(re int i = len - 1; i &gt; 0; --i) &#123; if(!p[i]) &#123; printf(\"0000\"); continue; &#125; for(re int k = 10; k * p[i] &lt; mod; k *= 10) printf(\"0\"); printf(\"%d\", p[i]); &#125; &#125;&#125;f[60][1010];using std :: max;HN operator + (const HN &amp;x, const HN &amp;y) &#123; HN temp; int num = 0; temp.len = max(x.len, y.len); for(re int i = 1; i &lt;= temp.len; ++i) &#123; temp.p[i] = x.p[i] + y.p[i] + num; num = temp.p[i] / mod; temp.p[i] %= mod; &#125; while(num &gt; 0) &#123; temp.p[++temp.len] = num % mod; num /= mod; &#125; return temp;&#125;using std :: swap;HN operator - (const HN &amp;x, const HN &amp;y) &#123; HN temp; temp.len = max(x.len, y.len); for(re int i = 1; i &lt;= temp.len; ++i) &#123; if(temp.p[i] + x.p[i] - y.p[i] &lt; 0) temp.p[i] += mod, temp.p[i + 1]--; temp.p[i] += x.p[i] - y.p[i]; &#125; while(temp.len &gt; 0 &amp;&amp; temp.p[temp.len] == 0) --temp.len; return temp;&#125;HN operator * (const HN &amp;x, int y) &#123; HN temp; int num = 0; temp.len = x.len; for(re int i = 1; i &lt;= temp.len; ++i) &#123; temp.p[i] = x.p[i] * y + num; num = temp.p[i] / mod; temp.p[i] %= mod; &#125; while(num &gt; 0) &#123; temp.p[++temp.len] = num % mod; num /= mod; &#125; return temp;&#125;inline int find(long long x) &#123; int res = std :: lower_bound(num + 1, num + cnt + 1, x) - num; return num[res] == x ? res : -1;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;k); if(!k) &#123; HN num1, num2; num1.p[1] = num2.p[1] = 1; num1.len = num2.len = 1; for(re int i = 1; i &lt;= n; ++i) num1 = num1 * 10; for(re int i = 1; i &lt;= n; ++i) num2 = num2 * 9; HN num3 = num1 - num2; num3.print(); putchar('\\n'); return 0; &#125; for(re int i = 1; i * i &lt;= k; ++i) &#123; if(k % i == 0) &#123; num[++cnt] = i; if(i * i != k) num[++cnt] = k / i; &#125; &#125; std :: sort(num + 1, num + cnt + 1); f[0][1].p[1] = 1, f[0][1].len = 1; for(re int i = 2; i &lt;= cnt; ++i) f[0][i].p[1] = 0, f[0][i].len = 1; for(re int i = 0; i &lt; n; ++i) &#123; for(re int j = 1; j &lt;= cnt; ++j) &#123; for(re int l = 1; l &lt;= 9; ++l) &#123; if((long long)(l * num[j]) &lt;= k) &#123; int temp = find(l * num[j]);// printf(\"%d \", temp); if(temp != -1) f[i + 1][temp] = f[i + 1][temp] + f[i][j]; &#125; &#125; &#125; &#125; f[n][cnt].print(); putchar('\\n'); return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"},{"name":"数论","slug":"数论","permalink":"https://dyrisingsunlight.github.io/tags/数论/"},{"name":"高精度","slug":"高精度","permalink":"https://dyrisingsunlight.github.io/tags/高精度/"}]},{"title":"矩阵取数游戏","slug":"矩阵取数游戏","date":"2019-08-30T16:00:00.000Z","updated":"2019-08-31T14:55:42.657Z","comments":true,"path":"2019/08/31/矩阵取数游戏/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/31/矩阵取数游戏/","excerpt":"$Problem’s \\ Website$矩阵取数游戏 $Solution$这道题可以用记忆化搜索，比较好理解，于是我就不说了。。。 我们来说一下$dp$的做法。","text":"$Problem’s \\ Website$矩阵取数游戏 $Solution$这道题可以用记忆化搜索，比较好理解，于是我就不说了。。。 我们来说一下$dp$的做法。 很明确，我们可以将每一行分开处理，而且处理的点只带两端，明显的区间$dp$。 我们设$f[i][j]$为当前区间变为$i,\\ j$时的最大得分。 每次取数时，至于$i\\ -\\ 1$和$j\\ +\\ 1$有关，次数我们可以推出来为$m-j+i-1$ 状态转移方程还是比较好推的。 对于每一行 $for\\ i\\ 1-m$ $for\\ j\\ m - i$ $ f[i][j]\\ = \\max(f[i - 1][j] + a[i - 1][j] \\times 2^{n-j+i-1}, f[i][j+1]+a[i][j+1] \\times 2^{n-j+i-1});$ 最后只剩下一个数时 $f[i][i] = \\max(f[i][i]+a[i][i] \\times 2^m);$ 对于每一行的$f[i][i]$取$\\max$，最后答案为$\\sum\\limits_{i=1}^{n}{\\max_{j=1}^{m}(f[j][j] + a[j][j] \\times 2^m)}$ 最后，温馨提示：本题要用高精度 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re registerconst int Maxn = 90;const int mod = 1e4;struct BIG &#123; int p[110]; int len; BIG() &#123; memset(p, 0, sizeof(p)); len = 0; &#125; void print() &#123; printf(\"%d\", p[len]); for(re int i = len - 1; i &gt; 0; --i) &#123; if(!p[i]) &#123; printf(\"0000\"); continue; &#125; for(re int k = 10; k * p[i] &lt; mod; k *= 10) printf(\"0\"); printf(\"%d\", p[i]); &#125; &#125; BIG operator + (const BIG &amp;x) &#123; BIG temp; int num = 0; temp.len = std :: max(len, x.len); for(re int i = 1; i &lt;= temp.len; ++i) &#123; temp.p[i] = p[i] + x.p[i] + num; num = temp.p[i] / mod; temp.p[i] %= mod; &#125; while(num &gt; 0) &#123; temp.p[++temp.len] = num % mod; num /= mod; &#125; return temp; &#125; BIG operator * (int x) &#123; BIG temp; int num = 0; temp.len = len; for(re int i = 1; i &lt;= temp.len; ++i) &#123; temp.p[i] = p[i] * x + num; num = temp.p[i] / mod; temp.p[i] %= mod; &#125; while(num &gt; 0) &#123; temp.p[++temp.len] = num % mod; num /= mod; &#125; return temp; &#125;&#125;f[Maxn][Maxn], two[Maxn], ans;BIG max (const BIG &amp;x, const BIG &amp;y) &#123; if(x.len &gt; y.len) return x; else if(x.len &lt; y.len) return y; for(re int i = x.len; i &gt; 0; --i) &#123; if(x.p[i] &gt; y.p[i]) return x; else if(x.p[i] &lt; y.p[i]) return y; &#125; return x;&#125;int n, m;inline void control() &#123; two[0].p[1] = 1, two[0].len = 1; for(re int i = 1; i &lt;= m + 1; ++i) two[i] = two[i - 1] * 2;&#125;int a[Maxn];int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); control(); while(n--) &#123; memset(f, 0, sizeof(f)); for(re int i = 1; i &lt;= m; ++i) scanf(\"%d\", &amp;a[i]); for(re int i = 1; i &lt;= m; ++i) for(re int j = m; j &gt;= i; --j) &#123; f[i][j] = max(f[i][j], f[i - 1][j] + two[m - j + i - 1] * a[i - 1]); f[i][j] = max(f[i][j], f[i][j + 1] + two[m - j + i - 1] * a[j + 1]); &#125; BIG temp; for(re int i = 1; i &lt;= m; ++i) temp = max(temp, f[i][i] + two[m] * a[i]); ans = ans + temp; &#125; ans.print(); return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"},{"name":"高精度","slug":"高精度","permalink":"https://dyrisingsunlight.github.io/tags/高精度/"}]},{"title":"20190829模拟赛画画画","slug":"20190829模拟赛画画画","date":"2019-08-28T16:00:00.000Z","updated":"2019-08-30T15:49:54.231Z","comments":true,"path":"2019/08/29/20190829模拟赛画画画/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/29/20190829模拟赛画画画/","excerpt":"$Problem’s$ $Website$画画画 （因权限问题查看不了题目的同学不要打我） 根据题意直接进行模拟肯定会超时。。。 于是我们来优化，我们可以对$x$坐标进行普通的枚举，对$y$坐标进行差分。 因为等腰直角三角形的直角顶点有四种情况，所以要分类讨论","text":"$Problem’s$ $Website$画画画 （因权限问题查看不了题目的同学不要打我） 根据题意直接进行模拟肯定会超时。。。 于是我们来优化，我们可以对$x$坐标进行普通的枚举，对$y$坐标进行差分。 因为等腰直角三角形的直角顶点有四种情况，所以要分类讨论 因为作者太懒了，所以请读者自行画图，我只在下文给出结论。。。 写在前面：$num$，每次循环前为$0$，然后不断递增。 $opt = 1$ $for$ $i$ $x$ ~ $(x + l)$ $a[i][y]$ $+=$ $c$ $a[i][y + l - num + 1] -= c$ - $opt = 2$ $for$ $i$ $x$ ~ $(x + l)$ $a[i][y - l + num] += c$ $a[i][y + 1] -= c$ $opt = 3$ $for$ $i$ $x$ ~ $(x - l)$ $a[i][y] += c$ $a[i][y + l - num + 1] -= c$ - $opt = 4$ $for$ $i$ $x$ $(x - l)$ $a[i][y - l + num] += c$ $a[i][y + 1] -= c$ 最后直接枚举，计算最大值即可。 $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Coded by dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;typedef long long ll;inline void out(ll x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;#define re registerusing std :: max;int n;ll ans;ll a[1010][1010];int main() &#123; n = sc(); for(re int i = 1; i &lt;= n; ++i) &#123; int opt = sc(), x = sc(), y = sc(), l = sc(), c =sc(); if(opt == 1) &#123; int num = 0; for(re int j = x; j &lt;= x + l; ++j) &#123; a[j][y] += c; a[j][y + l - num + 1] -= c; ++num; &#125; &#125; else if(opt == 2) &#123; int num = 0; for(re int j = x; j &lt;= x + l; ++j) &#123; a[j][y - l + num] += c; a[j][y + 1] -= c; ++num; &#125; &#125; else if(opt == 3) &#123; int num = 0; for(re int j = x; j &gt;= x - l; --j) &#123; a[j][y] += c; a[j][y + l - num + 1] -=c; ++num; &#125; &#125; else &#123; int num = 0; for(re int j = x; j &gt;= x - l; --j) &#123; a[j][y - l + num] += c; a[j][y + 1] -= c; ++num; &#125; &#125; &#125; for(re int i = 1; i &lt;= 1000; ++i) &#123; ll num = 0; for(re int j = 1; j &lt;= 1000; ++j) &#123; num += a[i][j]; ans = max(ans, num); &#125; &#125; out(ans), pc('\\n'); return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"https://dyrisingsunlight.github.io/tags/前缀和/"},{"name":"差分","slug":"差分","permalink":"https://dyrisingsunlight.github.io/tags/差分/"}]},{"title":"20190829模拟赛 圣诞树","slug":"20190829模拟赛圣诞树","date":"2019-08-28T16:00:00.000Z","updated":"2019-08-30T15:52:55.942Z","comments":true,"path":"2019/08/29/20190829模拟赛圣诞树/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/29/20190829模拟赛圣诞树/","excerpt":"$Problem’s$ $Website$圣诞树 （没有权限查看题目的同学不要打我）","text":"$Problem’s$ $Website$圣诞树 （没有权限查看题目的同学不要打我） 这是一道经典题，我们首先用类似链剖分的方法求一个dfs序，将树上问题转化为线性问题，用两个数组记录每一棵子树起始的dfs序和终止的dfs序，然后处理每个赋颜色的操作，记录每个操作最后一个起始子树的dfs序（因为可能重复赋值），然后将所有子树按照终止子树的dfs序升序排序，维护一个类似指针的东西，表示当前的颜色，先枚举子树根，如果当前颜色起始的dfs序在这棵子树中，就在那个位置$+1$，如果这种颜色有重复赋值，我们就在它上一个赋值的位置$-1$，最后对于每个子树区间，树状数组加一下就是答案，有点像 差分前缀和 。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Coded by dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;#define re registerusing std :: sort;const int Maxn = 1e5 + 10;struct TREE &#123; int nxt, to;&#125;t[Maxn &lt;&lt; 1];struct SON &#123; int l, r, id; bool operator &lt; (const SON &amp;x) const &#123; return r &lt; x.r; &#125;&#125;q[Maxn];struct COLOR &#123; int p, c, lst; bool operator &lt; (const COLOR &amp;x) const &#123; return p &lt; x.p; &#125;&#125;a[Maxn];int n, m, cnt;int head[Maxn], ta[Maxn], ans[Maxn], now[Maxn], st[Maxn], ed[Maxn];inline void ADD(int from, int to) &#123; t[++cnt].nxt = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void dfs(int id) &#123; st[id] = ++cnt; for(re int i = head[id]; i; i = t[i].nxt) &#123; int to = t[i].to; if(!st[to]) dfs(to); &#125; ed[id] = cnt;&#125;#define lowbit(i) (i &amp; (-i))inline void update(int x, int z) &#123; for(; x &lt;= n; x += lowbit(x)) ta[x] += z;&#125;inline int query(int x) &#123; int res = 0; for(; x; x -= lowbit(x)) res += ta[x]; return res;&#125;int main() &#123; while(scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; //init cnt = 0; memset(head, 0, sizeof(head)); memset(st, 0, sizeof(st)); memset(ed, 0, sizeof(ed)); memset(ta, 0, sizeof(ta)); memset(now, 0, sizeof(now)); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y), ADD(y, x); &#125; cnt = 0; dfs(1); for(re int i = 1; i &lt;= m; ++i) &#123; int x = sc(), y = sc(); a[i].p = st[x], a[i].c = y; &#125; sort(a + 1, a + m + 1); for(re int i = 1; i &lt;= m; ++i) &#123; a[i].lst = now[a[i].c]; now[a[i].c] = a[i].p; &#125; for(re int i = 1; i &lt;= n; ++i) &#123; q[i] = SON&#123;st[i], ed[i], i&#125;; &#125; sort(q + 1, q + n + 1); int top = 0; for(re int i = 1; i &lt;= n; ++i) &#123; while(top &lt; m &amp;&amp; a[top + 1].p &lt;= q[i].r) &#123; ++top; update(a[top].p, 1); if(a[top].lst) update(a[top].lst, -1); &#125; ans[q[i].id] = query(q[i].r) - query(q[i].l - 1); &#125; for(re int i = 1; i &lt;= n; ++i) out(ans[i]), pc(' '); pc('\\n'); &#125; return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://dyrisingsunlight.github.io/tags/树状数组/"},{"name":"前缀和","slug":"前缀和","permalink":"https://dyrisingsunlight.github.io/tags/前缀和/"},{"name":"差分","slug":"差分","permalink":"https://dyrisingsunlight.github.io/tags/差分/"}]},{"title":"BOI2009 Radio Transmission 无线传输","slug":"BOI2009 Radio Transmission 无线传输","date":"2019-08-28T16:00:00.000Z","updated":"2019-08-30T15:46:22.458Z","comments":true,"path":"2019/08/29/BOI2009 Radio Transmission 无线传输/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/29/BOI2009 Radio Transmission 无线传输/","excerpt":"$Problem’s$ $Website$BOI2009 Radio Transmission 无线传输 $Solution$ 这道题会详细地解释$KMP$算法中的$next$数组(下文写作$nxt$)，可以配合我的另外一篇辣鸡题解进行学习。","text":"$Problem’s$ $Website$BOI2009 Radio Transmission 无线传输 $Solution$ 这道题会详细地解释$KMP$算法中的$next$数组(下文写作$nxt$)，可以配合我的另外一篇辣鸡题解进行学习。 长话短说，说一下$nxt$数组。 在模式串中(就是短的字符串)，$nxt[i]$ $\\le$ $i$ 并且 $str[i] == str[nxt[i]]$ 并且在 $j != 1$时应满足$str[1]$ ~ $str[nxt[i] - 1]$ $=$ $str[i - nxt[i] +1]$ ~ $str[i - 1]$，就是它们的前缀相等。 关于这题如何求最小周期 $Code$123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re registerint n;char s[1000010];int nxt[1000010];int main() &#123; scanf(\"%d\", &amp;n); scanf(\"%s\", s + 1); int j =0; for(re int i = 2; i &lt;= n; ++i) &#123; while(j &amp;&amp; s[j + 1] != s[i]) j = nxt[j]; if(s[j + 1] == s[i]) ++j; nxt[i] = j; &#125;// for(re int i = 1; i &lt;= n; ++i)// printf(\"%d \", nxt[i]); printf(\"%d\\n\", n - nxt[n]); return 0;&#125; $rp++$","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://dyrisingsunlight.github.io/tags/KMP/"}]},{"title":"20190828模拟赛T3","slug":"20190828模拟赛T3","date":"2019-08-27T16:00:00.000Z","updated":"2019-08-30T15:19:36.083Z","comments":true,"path":"2019/08/28/20190828模拟赛T3/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/28/20190828模拟赛T3/","excerpt":"$Problem’s$ $Website$20190828模拟赛T3 $Solution$首先，不懂权值线段树的同学可以暂时先去这学习一下。 根据数据范围，我们要离散化一下。","text":"$Problem’s$ $Website$20190828模拟赛T3 $Solution$首先，不懂权值线段树的同学可以暂时先去这学习一下。 根据数据范围，我们要离散化一下。 离散化之后，我们从$1$到$n$循环，每次输出 前面的元素个数 $-$ 已经合法的元素个数，即输出$i - 1 - query(1, 1, n, m - a[i])$，最后将当前的数据加到线段树上。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) +(cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;using std :: sort;using std :: pair;using std :: make_pair;#define P pair &lt;int, int&gt;const int Maxn = 2e5 + 10;int t, n, m;int a[Maxn], c[Maxn];P b[Maxn];int rank[Maxn &lt;&lt; 2];long long val[Maxn &lt;&lt; 2];inline bool cmp(P x, P y) &#123; if(x.second == y.second) return x.first &lt; y.first; return x.second &lt; y.second; &#125;inline void modify(int k, int l, int r, int x, int z) &#123; if(l == r &amp;&amp; l == x) &#123; rank[k] += 1; val[k] += z; return; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(k &lt;&lt; 1, l, mid, x, z); else modify(k &lt;&lt; 1 | 1, mid + 1, r, x, z); rank[k] = rank[k &lt;&lt; 1] + rank[k &lt;&lt; 1 | 1]; val[k] = val[k &lt;&lt; 1] + val[k &lt;&lt; 1 | 1];&#125;inline int query(int k, int l, int r, int x) &#123; if(val[k] &lt;= x) return rank[k]; if(l == r) return 0; int mid = l + r &gt;&gt; 1; if(val[k &lt;&lt; 1] &lt; x) return rank[k &lt;&lt; 1] + query(k &lt;&lt; 1 | 1, mid + 1, r, x - val[k &lt;&lt; 1]); else return query(k &lt;&lt; 1, l, mid, x);&#125;#define re registerint main() &#123; t = sc(); while(t--) &#123; memset(val, 0, sizeof(val)); memset(rank, 0, sizeof(rank)); n = sc(), m = sc(); for(re int i = 1; i &lt;= n; ++i) &#123; a[i] = sc(), b[i] = make_pair(i, a[i]); &#125; sort(b + 1, b + n + 1, cmp); for(re int i = 1; i &lt;= n; ++i) c[b[i].first] = i; for(re int i = 1; i &lt;= n; ++i) &#123; out(i - 1 - query(1, 1, n, m - a[i])), pc(' '); modify(1, 1, n, c[i], a[i]); &#125; pc('\\n'); &#125; return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"权值线段树","slug":"权值线段树","permalink":"https://dyrisingsunlight.github.io/tags/权值线段树/"}]},{"title":"X龙珠","slug":"X龙珠","date":"2019-08-27T16:00:00.000Z","updated":"2019-08-30T15:14:04.338Z","comments":true,"path":"2019/08/28/X龙珠/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/28/X龙珠/","excerpt":"$Problem’s$ $Website$X龙珠 $Solution$运用链表思想，用数组模拟链表，存储一个数据的$next$和$last$(后一个和前一个)，然后类似于贪心，我们从大到小枚举，如果当前的数没有$next$，说明无法输出，如果有，则将它和它的$next$输出，更新一下与这两个数相邻的数的$next$和$last$，然后将这两个数的$next$和$last$清零即可。","text":"$Problem’s$ $Website$X龙珠 $Solution$运用链表思想，用数组模拟链表，存储一个数据的$next$和$last$(后一个和前一个)，然后类似于贪心，我们从大到小枚举，如果当前的数没有$next$，说明无法输出，如果有，则将它和它的$next$输出，更新一下与这两个数相邻的数的$next$和$last$，然后将这两个数的$next$和$last$清零即可。 $Code$12345678910111213141516171819202122232425262728//Coded by dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re registerconst int Maxn = 1e5 + 10;int n;int a[Maxn], nxt[Maxn], lst[Maxn];int main() &#123; scanf(\"%d\", &amp;n); for(re int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;a[i]); nxt[a[i]] = i + 1; lst[a[i]] = i - 1; &#125; nxt[a[n]] = lst[a[1]] = 0; for(re int i = n; i &gt;= 1; --i) &#123; if(a[nxt[i]]) &#123; printf(\"%d %d \", i, a[nxt[i]]); nxt[a[lst[i]]] = nxt[a[nxt[i]]]; lst[a[nxt[a[nxt[i]]]]] = lst[i]; nxt[a[nxt[i]]] = lst[a[nxt[i]]] = 0; nxt[i] = lst[i] = 0; &#125; &#125; return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://dyrisingsunlight.github.io/tags/贪心/"},{"name":"链表思想","slug":"链表思想","permalink":"https://dyrisingsunlight.github.io/tags/链表思想/"}]},{"title":"20190828模拟赛T2","slug":"20190828模拟赛T2","date":"2019-08-27T16:00:00.000Z","updated":"2019-08-30T15:16:37.200Z","comments":true,"path":"2019/08/28/20190828模拟赛T2/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/28/20190828模拟赛T2/","excerpt":"$Problem’s$ $Website$2019.8.28模拟赛T2 $Solution$$dp$求解，我们设$f[i][j][k]$为前$i$个数，最后连续$j$个黑球，连续$k$个白球的方案数，这样求出来答案要$\\times 2$，因为颜色可以互换。","text":"$Problem’s$ $Website$2019.8.28模拟赛T2 $Solution$$dp$求解，我们设$f[i][j][k]$为前$i$个数，最后连续$j$个黑球，连续$k$个白球的方案数，这样求出来答案要$\\times 2$，因为颜色可以互换。 具体步骤: 1.当$n &lt; 7$时，答案为$2^n$，因为怎样涂颜色都可以。 2.当$n \\ge 7$时，我们求出一个$ans$数组，$ans[i]$为i个数时一种情况的方案数 (即$f[i][j][k]$ $j$ 为黑球个数，$k$为白球个数)，因为可以互换，所以答案为$ans[n] \\times 2$。 P.s. 如何处理$f$和$ans$数组？ 最外层一次循环枚举$i$从$1$到$6$，每次将$f$数组清零，初始化$f[i + 1][1][0] = 1$，显然~。然后有以下式子: $\\sum\\limits_{j = i + 1}^{2e5 + 10}{\\sum\\limits_{k = 1}^{6}{f[j][1][0] += f[j - 1][0][k], f[j][0][1] += f[j - 1][k][0];}}$ $\\sum\\limits_{j = i + 1}^{2e5 + 10}{\\sum\\limits_{k = 1}^{5}{f[j][k + 1][0] += f[j - 1][k][0], f[j][0][k + 1] += f[j - 1][0][k];}}$ $\\sum\\limits_{j = i + 1}^{2e5 + 10}{\\sum\\limits_{k = 1}^{6}{ans[j] += f[j][k][0];}}$ $\\sum\\limits_{j = i + 1}^{2e5 + 10}{\\sum\\limits_{k = 1}^{6 - i}{ans[j] += f[j][0][k];}}$ 最后别忘了$mod$！ $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Coded by dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define gc getchar()#define pc(x) putchar(x)inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;#define re registerconst int Maxn = 2e5 + 10;const int mod = 1e9 + 7;int t, n;int ans[Maxn];int f[Maxn][10][10];inline void control() &#123; for(re int i = 1; i &lt;= 6; ++i) &#123; memset(f, 0, sizeof(f)); f[i + 1][1][0] = 1; for(re int j = i + 1; j &lt;= Maxn; ++j) &#123; for(re int k = 1; k &lt;= 6; ++k) f[j][1][0] = (f[j][1][0] + f[j - 1][0][k]) % mod; for(re int k = 1; k &lt;= 5; ++k) f[j][k + 1][0] = (f[j][k + 1][0] + f[j - 1][k][0]) % mod; for(re int k = 1; k &lt;= 6; ++k) f[j][0][1] = (f[j][0][1] + f[j - 1][k][0]) % mod; for(re int k = 1; k &lt;= 5; ++k) f[j][0][k + 1] = (f[j][0][k + 1] + f[j - 1][0][k]) % mod; for(re int k = 1; k &lt; 7; ++k) ans[j] = (ans[j] + f[j][k][0]) % mod; for(re int k = 1; i + k &lt; 7; ++k) ans[j] = (ans[j] + f[j][0][k]) % mod; &#125; &#125;&#125;int main() &#123; control(); t = sc(); while(t--) &#123; n = sc(); if(n &lt; 7) out(1 &lt;&lt; n), pc('\\n'); else out((ans[n] &lt;&lt; 1) % mod), pc('\\n'); &#125; return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"TJOI2013 最长上升子序列","slug":"TJOI2013-最长上升子序列","date":"2019-08-20T16:00:00.000Z","updated":"2019-08-21T15:36:58.805Z","comments":true,"path":"2019/08/21/TJOI2013-最长上升子序列/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/21/TJOI2013-最长上升子序列/","excerpt":"$Problem’s$ $Website$TJOI2013 最长上升子序列 $Solution$这道题是一道既考思想有考代码能力的好题，能学到不少东西。 这道题我是用$fhq-Treap$ $+$ 线段树 做的，思想类似于模板 最长公共子序列，这道题我写了一篇题解，大家可以先去查看一下，当然也可以不看。。。","text":"$Problem’s$ $Website$TJOI2013 最长上升子序列 $Solution$这道题是一道既考思想有考代码能力的好题，能学到不少东西。 这道题我是用$fhq-Treap$ $+$ 线段树 做的，思想类似于模板 最长公共子序列，这道题我写了一篇题解，大家可以先去查看一下，当然也可以不看。。。 大体说一下做法 1.关于维护序列 首先要把样例搞懂，所以我先把样例解释一下，见下图： 我们发现，将一个数组$x$插入到位置$i$，如果位置$i$已经有数字了，那么要进行右移，那么平衡树自然是维护序列的不二选择了，因为我暂时不会$Splay$，所以我用的是$fhq-Treap$。 对于$fhq-Treap$来说，有一点要注意，就是分裂的对象，这道题我们要以子树的大小为对象进行分裂。 2.求$LIS$ 因为数据肯定不重复，所以我们可以用类似于离散化的方式来求$LIS$。 也就是用一个数组$a[x]$来记录数字$x$出现的位置，我们从小到大枚举 （因为要求$LIS$），每次求出从$1$到当前数字位置的前一个的$LIS$长度，$+1$后更新答案 （因为当前数一定比前面的数大），最后把当前位置的$LIS$记录下来。 上面的操作就是单点修改和区间最值，那么，线段树搞定! $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//Coded by dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerusing std :: max;const int Maxn = 100000 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct fhq_Treap &#123; int siz, val, dat; int ch[2];&#125;t[Maxn];int n, ans;int a[Maxn];int lst[Maxn &lt;&lt; 2];int rt, r1, r2, tot;inline void pushup(int id) &#123; t[id].siz = t[t[id].ch[0]].siz + t[t[id].ch[1]].siz + 1;&#125;inline int cre(int v) &#123; t[++tot].siz = 1, t[tot].val = v, t[tot].dat = rand(); return tot;&#125;inline void split(int id, int k, int &amp;x, int &amp;y) &#123; if(!id) x = y = 0; else &#123; if(k &lt;= t[t[id].ch[0]].siz) &#123; y = id; split(t[id].ch[0], k, x, t[id].ch[0]); &#125; else &#123; x = id; split(t[id].ch[1], k - t[t[id].ch[0]].siz - 1, t[id].ch[1], y); &#125; pushup(id); &#125;&#125;inline int merge(int x, int y) &#123; if(!x || !y) return x + y; if(t[x].dat &lt; t[y].dat) &#123; t[x].ch[1] = merge(t[x].ch[1], y); pushup(x); return x; &#125; t[y].ch[0] = merge(x, t[y].ch[0]); pushup(y); return y;&#125;inline void insert(int val, int id) &#123; split(rt, val, r1, r2); rt = merge(r1, merge(cre(id), r2));&#125;inline int rank(int id, int r) &#123; while(1) &#123; if(r &lt;= t[t[id].ch[0]].siz) id = t[id].ch[0]; else if(r == t[t[id].ch[0]].siz + 1) return id; else &#123; r -= (t[t[id].ch[0]].siz + 1); id = t[id].ch[1]; &#125; &#125;&#125;inline void modify(int k, int l, int r, int x, int z) &#123; if(l == r &amp;&amp; l == x) &#123; lst[k] = z; return; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(k &lt;&lt; 1, l, mid, x, z); else modify(k &lt;&lt; 1 | 1, mid + 1, r, x, z); lst[k] = max(lst[k &lt;&lt; 1], lst[k &lt;&lt; 1 | 1]);&#125;inline int query(int k, int l, int r, int x, int y) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) return lst[k]; int mid = l + r &gt;&gt; 1, res = 0; if(x &lt;= mid) res = max(res, query(k &lt;&lt; 1, l, mid, x, y)); if(y &gt; mid) res = max(res, query(k &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res;&#125;int main() &#123; srand(20041029); n = sc(); for(re int i = 1; i &lt;= n; ++i) insert(sc(), i); for(re int i = 1; i &lt;= n; ++i) a[t[rank(rt, i)].val] = i; for(re int i = 1; i &lt;= n; ++i) &#123; if(a[i] == 1) &#123; ans = max(ans, 1); modify(1, 1, n, a[i], 1); &#125; else &#123; int temp = query(1, 1, n, 1, a[i] - 1) + 1; ans = max(ans, temp); modify(1, 1, n, a[i], temp); &#125; out(ans), pc('\\n'); &#125; return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"},{"name":"fhq-Treap","slug":"fhq-Treap","permalink":"https://dyrisingsunlight.github.io/tags/fhq-Treap/"}]},{"title":"TJOI2007 书架","slug":"TJOI2007-书架","date":"2019-08-16T16:00:00.000Z","updated":"2019-08-17T14:48:51.205Z","comments":true,"path":"2019/08/17/TJOI2007-书架/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/17/TJOI2007-书架/","excerpt":"$Problem’s$ $Website$TJOI2007 书架 $Solution$这是一道平衡树的好题，因为我暂时不会$Splay$，所以我就用$fhq-Treap$来写。 首先关于$fhq-Treap$的一些解释在我的另外一篇blog中已经详细说明了，不懂的童鞋可以先去学习一下。 这道题要用到排名分裂，同样用到这种方法的还有另外一道同名题。","text":"$Problem’s$ $Website$TJOI2007 书架 $Solution$这是一道平衡树的好题，因为我暂时不会$Splay$，所以我就用$fhq-Treap$来写。 首先关于$fhq-Treap$的一些解释在我的另外一篇blog中已经详细说明了，不懂的童鞋可以先去学习一下。 这道题要用到排名分裂，同样用到这种方法的还有另外一道同名题。 上面好像都是废话，下面是干货。 下面详细地说一下操作。 1.处理书的名称: 因为是字符串，所以我们用一个$string$类型的数组记录，用一个变量当做编号映射到每本书的名称。 温馨提示：注意数据范围，否则将惨遭$RE$。。。（好像就我这个菜鸡$RE$了） 2.处理一开始就在书架上的书: 我们所说的“排名”即当前这本书的上面有几本书，所以对于最开始的书籍，我们只要$insert(i - 1, cnt);$即可（cnt即为映射的变量） 3.处理后来放入的书籍: 经过研究样例，我们发现：插入一个位置为$x$的书，原本的第$x$本到最后一本的位置都会$+1$，也就是，那么也就是说，插入后这本书的排名就为$x$，所以就$insert(x, cnt);$ 4.处理询问 要输出第$x$个位置书的名称，我们就相当于找到第$x$个位置书映射的编号。 方法也很简单，我们首先以$x$为排名将树分裂成以$r1, r2$为根的两棵树，再对$r2$以$1$为排名分裂成以$r3, r4$为根的两棵树，这样$r3$就成了一个节点，也就是要求的答案。 给个图让大家理解一下（对于$fhq-Treap$，不理解的时候画个图有事半功倍的效果）: 别忘了最后合并回去。 相信大家对$fhq-Treap$又加深了理解。 所以下面代码就不解释了 (逃 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//Coded by dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 1e5 + 200 + 10;using std :: string;using std :: cin;using std :: cout;using std :: endl;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct fhq_Treap &#123; int ch[2]; int siz, val, dat;&#125;t[Maxn];int n, m, cnt;int rt, r1, r2, r3, r4, tot;string s[Maxn];inline void pushup(int id) &#123; t[id].siz = t[t[id].ch[0]].siz + t[t[id].ch[1]].siz + 1;&#125;inline int cre(int r) &#123; t[++tot].siz = 1, t[tot].val = r, t[tot].dat = rand(); return tot;&#125;inline void split(int id, int r, int &amp;x, int &amp;y) &#123; if(!id) x = y = 0; else &#123; if(r &lt;= t[t[id].ch[0]].siz) &#123; y = id; split(t[id].ch[0], r, x, t[id].ch[0]); &#125; else &#123; x = id; split(t[id].ch[1], r - t[t[id].ch[0]].siz - 1, t[id].ch[1], y); &#125; pushup(id); &#125;&#125;inline int merge(int x, int y) &#123; if(!x || !y) return x + y; if(t[x].dat &lt; t[y].dat) &#123; t[x].ch[1] = merge(t[x].ch[1], y); pushup(x); return x; &#125; t[y].ch[0] = merge(x, t[y].ch[0]); pushup(y); return y;&#125;inline void insert(int r, int id) &#123; split(rt, r, r1, r2); rt = merge(r1, merge(cre(id), r2));&#125;inline void query(int r) &#123; split(rt, r, r1, r2); split(r2, 1, r3, r4); cout &lt;&lt; s[t[r3].val] &lt;&lt; endl; rt = merge(r1, merge(r3, r4));&#125;int main() &#123; srand(20041029); n = sc(); for(re int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[++cnt]; insert(i - 1, cnt); &#125; m = sc(); while(m--) &#123; cin &gt;&gt; s[++cnt]; int x = sc(); insert(x, cnt); &#125; m = sc(); while(m--) &#123; int x = sc(); query(x); &#125; return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"fhq-Treap","slug":"fhq-Treap","permalink":"https://dyrisingsunlight.github.io/tags/fhq-Treap/"}]},{"title":"ZJOI2006 书架","slug":"ZJOI2006书架","date":"2019-08-15T16:00:00.000Z","updated":"2019-08-16T15:46:18.279Z","comments":true,"path":"2019/08/16/ZJOI2006书架/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/16/ZJOI2006书架/","excerpt":"$Problem’s$ $Website$ZJOI2006 书架 $Solution$这道题是一道平衡树好题，我暂时不会$Splay$，所以就用$fhq-Treap$做。 这道题就要用到排名分裂了。 也就是以排名为对象进行分裂。 对这道题来说，排名就相当于当前这本书上有几本书。 特殊地一点：用一个数组将书的编号映射到树中的编号。 因此，我们还要记录每个节点的父亲节点。 我们来详细解释一下题目中操作的步骤：","text":"$Problem’s$ $Website$ZJOI2006 书架 $Solution$这道题是一道平衡树好题，我暂时不会$Splay$，所以就用$fhq-Treap$做。 这道题就要用到排名分裂了。 也就是以排名为对象进行分裂。 对这道题来说，排名就相当于当前这本书上有几本书。 特殊地一点：用一个数组将书的编号映射到树中的编号。 因此，我们还要记录每个节点的父亲节点。 我们来详细解释一下题目中操作的步骤： 1.$Top$ 对$now$和$now - 1$进行分裂，然后将当前的书放到最顶上。 2.$Bottom$ 类似于第一个操作，只不过要把当前的数放到最底下。 3.$Insert$ 如果是$0$，那么不需要管。 如果是$1$，就把当前的书和它的前驱交换一下。 如果是$-1$,就把当前的书和它的后驱交换一下。 4.$Ask$ 我们直接查找对应的排名，但注意答案要$-1$，因为树的编号是从$1$开始的。 5.$Query$ 对$x$进行分裂，分裂后左边的数的最右子树的值即为答案。 $P.s.$ 如何使用映射数组找到编号为$x$的书在树中的排名？ $Answer$：我们在确保当前书的编号不为树的根时向上走，如果当前节点是其父节点的右子树，答案就加上左子树的排名$+1$，大家可以画个图感性理解一下或者运用人类智慧进行理解。 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//Coded by dy.#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerusing std :: cerr;using std :: endl;const int Maxn = 80000 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct fhq_Treap &#123; int ch[2]; int fa, siz, val, dat;&#125;t[Maxn];int n, m;int rt, r1, r2, r3, r4, tot;int id[Maxn];inline void pushup(int id) &#123; t[id].siz = t[t[id].ch[0]].siz + t[t[id].ch[1]].siz + 1;&#125;inline int cre(int r) &#123; t[++tot].siz = 1, t[tot].val = r, t[tot].dat = rand(), id[r] = tot; return tot;&#125;inline void split(int id, int r, int &amp;x, int &amp;y, int faa = 0, int fab = 0) &#123; if(!id) x = y = 0; else &#123; if(r &lt;= t[t[id].ch[0]].siz) &#123; t[id].fa = fab, y = id; split(t[id].ch[0], r, x, t[id].ch[0], faa, id); &#125; else &#123; t[id].fa = faa, x = id; split(t[id].ch[1], r - t[t[id].ch[0]].siz - 1, t[id].ch[1], y, id, fab); &#125; pushup(id); &#125;&#125;inline int merge(int x, int y) &#123; if(!x || !y) return x + y; if(t[x].dat &lt; t[y].dat) &#123; t[x].ch[1] = merge(t[x].ch[1], y); t[t[x].ch[1]].fa = x; pushup(x); return x; &#125; t[y].ch[0] = merge(x, t[y].ch[0]); t[t[y].ch[0]].fa = y; pushup(y); return y;&#125;inline void insert(int r, int id) &#123; split(rt, r, r1, r2); rt = merge(r1, merge(cre(id), r2));&#125;inline bool get(int x) &#123; return t[t[x].fa].ch[1] == x;&#125;inline int find_id(int cnt) &#123; int node = cnt, res = t[t[cnt].ch[0]].siz + 1; while(node != rt &amp;&amp; cnt)&#123; if(get(cnt)) res += t[t[t[cnt].fa].ch[0]].siz+1; cnt = t[cnt].fa; &#125; return res;&#125;int main() &#123; srand(20041029); n = sc(), m = sc(); for(re int i = 1; i &lt;= n; ++i) insert(i - 1, sc());// cerr &lt;&lt; rt &lt;&lt; endl; while(m--) &#123; char c[7]; scanf(\"%s\", c); int x = sc(); if(c[0] == 'T') &#123; int now = find_id(id[x]);// cerr &lt;&lt; now &lt;&lt; endl; split(rt, now, r1, r3); split(r1, now - 1, r1, r2);// cerr &lt;&lt;rt &lt;&lt; \" \" &lt;&lt; r2 &lt;&lt; \" \" &lt;&lt; r1 &lt;&lt; \" \" &lt;&lt; r3 &lt;&lt; endl; rt = merge(r2, merge(r1, r3)); &#125; else if(c[0] == 'B') &#123; int now = find_id(id[x]);// cerr &lt;&lt; now &lt;&lt; endl; split(rt, now, r1, r3, 0); split(r1, now - 1, r1, r2, 0);// cerr &lt;&lt; rt &lt;&lt; \" \" &lt;&lt; r1 &lt;&lt; \" \" &lt;&lt; r2 &lt;&lt; \" \" &lt;&lt; r3 &lt;&lt; endl; rt = merge(r1, merge(r3, r2)); &#125; else if(c[0] == 'I') &#123; int y = sc(), now = find_id(id[x]); if(y == 1) &#123; split(rt, now + 1, r3, r4); split(r3, now, r2, r3); split(r2, now - 1, r1, r2); rt = merge(r1, merge(r3, merge(r2, r4))); &#125; else if(y == -1) &#123; split(rt, now, r3, r4); split(r3, now - 1, r2, r3); split(r2, now - 2, r1, r2); rt = merge(r1, merge(r3, merge(r2, r4))); &#125; &#125; else if(c[0] == 'A') &#123; int now = find_id(id[x]); out(now - 1), pc('\\n'); &#125; else &#123; split(rt, x, r1, r2); int node = r1; while(t[node].ch[1]) node = t[node].ch[1]; out(t[node].val), pc('\\n'); rt = merge(r1, r2); &#125; &#125; return 0;&#125; $rp++$","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"fhq-Treap","slug":"fhq-Treap","permalink":"https://dyrisingsunlight.github.io/tags/fhq-Treap/"}]},{"title":"NOI_2004 郁闷的出纳员","slug":"郁闷的出纳员","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-12T14:33:19.304Z","comments":true,"path":"2019/08/12/郁闷的出纳员/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/12/郁闷的出纳员/","excerpt":"Problem’s WebsiteNOI 2004_郁闷的出纳员（LOJ） NOI 2004_郁闷的出纳员（洛谷） Solution这道题是平衡树的一道模板题，可以用$Treap$做，但是我太菜了，于是我用$fhq-Treap$做。 这道题加深了我对$fhq-Treap$分裂操作的理解。","text":"Problem’s WebsiteNOI 2004_郁闷的出纳员（LOJ） NOI 2004_郁闷的出纳员（洛谷） Solution这道题是平衡树的一道模板题，可以用$Treap$做，但是我太菜了，于是我用$fhq-Treap$做。 这道题加深了我对$fhq-Treap$分裂操作的理解。 首先，我们再处理$A$和$S$命令时不需要全部加或减，我们用一个变量当做标记，在处理$I$命令时把新的$k$减去标记即可。 其次，关于如何处理员工因工资太低而离开公司的问题 1.在插入时，我们最低值-标记-1进行分裂，也就是说，分裂后左边的树，就是要离开公司的内容，我们只需要让$root = y$，就说明我们把左边的树去掉了。 2.在集体减工资时，我们也进行同样的操作，同时，我们可以维护离开公司的人数，让$ans$加上$siz[x]$即可。 最后，关于输出第$k$多工资的问题 我们要判断这个第$k$多工资的员工是否离开了公司，如果$k\\le siz[rt]$就说明该员工没有离开公司，可以输出，否则就输出$-1$，感觉这个还是很好理解的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re register//const int base = 1e3 + 10;const int Maxn = 1e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;int n, m, tag, ans;int siz[Maxn], val[Maxn], dat[Maxn], ch[Maxn][2];int x, y, tot, rt;inline void pushup(int id) &#123; siz[id] = 1 + siz[ch[id][0]] + siz[ch[id][1]];&#125;inline int cre(int v) &#123; siz[++tot] = 1, val[tot] = v, dat[tot] = rand(); return tot;&#125;inline void split(int id, int v, int &amp;x, int &amp;y) &#123; if(!id) x = y = 0; else &#123; if(val[id] &lt;= v) &#123; x = id; split(ch[id][1], v, ch[id][1], y); &#125; else &#123; y = id; split(ch[id][0], v, x, ch[id][0]); &#125; pushup(id); &#125;&#125;inline int merge(int A, int B) &#123; if(!A || !B) return A + B; if(dat[A] &lt; dat[B]) &#123; ch[A][1] = merge(ch[A][1], B); pushup(A); return A; &#125; ch[B][0] = merge(A, ch[B][0]); pushup(B); return B;&#125;inline void insert(int v) &#123; split(rt, v, x, y); rt = merge(merge(x, cre(v)), y);&#125;inline int rank(int id, int r) &#123; while(1) &#123; if(r &lt;= siz[ch[id][0]]) id = ch[id][0]; else if(r == siz[ch[id][0]] + 1) return id; else &#123; r -= (1 + siz[ch[id][0]]); id = ch[id][1]; &#125; &#125;&#125;int main() &#123; n = sc(), m = sc(); while(n--) &#123; char c[2];// std :: cin &gt;&gt; c[0]; c[0] = gc;// c[0] = gc; int x = sc(); if(c[0] == 'I') &#123; insert(x - tag); split(rt, m - tag - 1, x, y); rt = y; &#125; else if(c[0] == 'A') &#123; tag += x; &#125; else if(c[0] == 'S') &#123; tag -= x; split(rt, m - tag - 1, x, y); rt = y; ans += siz[x]; &#125; else &#123; if(x &lt;= siz[rt]) out(val[rank(rt, siz[rt] - x + 1)] + tag), pc('\\n'); else out(-1), pc('\\n'); &#125; &#125; out(ans), pc('\\n'); return 0;&#125;// Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"fhq-Treap","slug":"fhq-Treap","permalink":"https://dyrisingsunlight.github.io/tags/fhq-Treap/"}]},{"title":"浅谈fhq-Treap","slug":"浅谈fhq-Treap","date":"2019-08-09T16:00:00.000Z","updated":"2019-08-10T13:32:33.931Z","comments":true,"path":"2019/08/10/浅谈fhq-Treap/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/10/浅谈fhq-Treap/","excerpt":"Problem’s Website普通平衡树（洛谷） 普通平衡树（LOJ） Solution没错，又是这道题。 再上一篇题解中，我们介绍了使用$Treap$的做法，那么本篇题解讲解一下$fhq-Treap$的做法。","text":"Problem’s Website普通平衡树（洛谷） 普通平衡树（LOJ） Solution没错，又是这道题。 再上一篇题解中，我们介绍了使用$Treap$的做法，那么本篇题解讲解一下$fhq-Treap$的做法。 先来普及一下，$fhq-Treap$由$OI$界的著名DALAO范浩强发明，至于他有多巨，看图吧。 他不仅$OI$强，人其实也挺 handsome 的。 P.s.该图片来源毕业季 | 范浩强：游走在学业和科研间的清华创客 好了，我们步入正题。 $fhq-Treap$又叫无旋Treap，顾名思义，就是没有旋转的$Treap$，取而代之的是分裂和合并，正因如此，$fhq-Treap$可以解决$Treap$解决不了的区间问题，而且还可以持久化，这些内容以后我会另外介绍。 首先，我们先明确下文中代码变量的意思。1234int siz[Maxn], val[Maxn], dat[Maxn], ch[Maxn][2];int x, y, z, tot, rt;//siz为子树大小，val为节点权值，dat为rand值，ch记录左右儿子（0为左儿子，1为右儿子）。// x,y,z为暂定的左右儿子编号，tot为总共的节点数，rt为当前树的根节点编号。 在说明基本操作前，我们先来说一下$fhq-Treap$的一些核心思想及操作 分裂 分裂分为两种，一种为权值分裂，另一种为排名分裂。 权值分裂 我们现在遍历到一个点，如果它的权值小于$v$，那么它的左子树会被分到左边的树里，然后我们遍历它的右儿子，如果大于$v$，则把它的右子树分到右边的树里。 那出现了一个小问题：如果到达递归边界id==0怎么办呢？ 那我们就初始化一下，令$x = y = 0$ 如果遍历到了叶子节点，我们就返回。 注意，对于形参中的$x,y$要取地址，这样就可以直接更新全局变量$x,y$。 看下代码吧123456789101112131415inline void split(int id, int v, int &amp;x, int &amp;y) &#123; if(!id) x = y = 0; else &#123; if(val[id] &lt;= v) &#123; x = id; split(ch[id][1], v, ch[id][1], y); &#125; else &#123; y = id; split(ch[id][0], v, x, ch[id][0]); &#125; pushup(id); &#125;&#125; 排名分裂 与权值分裂类似，把权值当成排名(siz)即可。 code123456789101112131415inline void split(int id, int r, int &amp;x, int &amp;y) &#123; if(!id) x=y=0; else &#123; if(r &lt;= siz[ch[id][0]]) &#123; y = id; split(ch[id][0], r, x, ch[id][0]); &#125; else &#123; x = id; split(ch[id][1], r - siz[ch[id][0]] - 1, ch[id][1], y); &#125; pushup(id); &#125;&#125; 给个图感性理解一下： 合并 我们假设第一棵树的权值小于第二棵树的权值，那么我们就比较它们的随机权值。如果$dat[l] &lt; dat[r]$，我们就保留它的左子树，另一棵树作为它的右子树；如果$dat[l] \\ge dat[r]$，那我们可以保留第二棵树的右子树，另一颗树作为它的左子树。 code1234567891011121314inline int merge(int A, int B) &#123; if(!A || !B) return A + B; if(dat[A] &lt; dat[B]) &#123; ch[A][1] = merge(ch[A][1], B); pushup(A); return A; &#125; else &#123; ch[B][0] = merge(A, ch[B][0]); pushup(B); return B; &#125;&#125; 图示 现在我们开始介绍$fhq-Treap$的一些基本操作。 $pushup$ 合并子树大小。 code 123inline void pushup(int id) &#123; siz[id] = siz[ch[id][0]] + siz[ch[id][1]] + 1;&#125; 插入 直接merge即可 code 12345678inline int cre(int v) &#123; siz[++tot] = 1, val[tot] = v, dat[tot] = rand(); return tot;&#125;inline void insert(int v) &#123; split(rt, v, x, y); rt = merge(merge(x, cre(v)), y);&#125; 删除 删除权值为$v$的点，先把整颗树以$v$为权值分裂成两棵树$a,b$,再把$a$树按照$v - 1$分成$c,d$。这时候值为$v$的点一定为$d$的根，那么我们把$d$的两个子儿子merge起来（划重点：这一步就是去除掉v的影响），再把他们重新merge起来得到一个新的树，这颗树就去除掉了v的影响。 code123456inline void Delete(int v) &#123; split(rt, v, x, z); split(x, v - 1, x, y); y = merge(ch[y][0], ch[y][1]); rt = merge(merge(x, y), z);&#125; 得到排名 直接按照$v-1$的权值把树分开，那么$x$树中最大的应该小于等于$v-1$，那么$v$的排名就是$siz[x]+1$。 code123456inline int get_rank(int v) &#123; split(rt, v - 1, x, y); int res = siz[x] + 1; rt = merge(x, y); return res;&#125; 得到排名为几的数据 循环求解。 如果当前$r \\le$左子树的大小，那么就往左子树找；如果$r$恰好等于左子树大小+ 1，说明就是当前节点；否则r减去(左子树大小 + 1)，然后去找右子树。 code1234567891011121314inline int rank(int id, int r) &#123; while(1) &#123; if(r &lt;= siz[ch[id][0]]) id = ch[id][0]; else if(r == siz[ch[id][0]] + 1) return id; else &#123; r -= (siz[ch[id][0]] + 1); id = ch[id][1]; &#125; &#125;&#125;out(val[rank(rt, x)]), pc('\\n'); //out为快输，pc为putchar。 前驱后驱 因为两者具有很大的相似性，所以我们只讲找前驱，后驱请读者根据代码自行理解。 因为要小于$v$，所以我们还是按照$v-1$的权值划分$x$，现在$x$中最大的数一定小于等于$v-1$，所以我们直接输出$x$中最大的数就好。 code123456789101112inline int get_pre(int v) &#123; //前驱 split(rt, v - 1, x, y); int res = val[rank(x, siz[x])]; rt = merge(x, y); return res;&#125;inline int get_next(int v) &#123; //后驱 split(rt, v, x, y); int res = val[rank(y, 1)]; rt = merge(x, y); return res;&#125; 本题的操作就讲完了，当然$fhq-Treap$不止这些东西，以后根据题目再说明吧。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 1e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;int n;int siz[Maxn], val[Maxn], dat[Maxn], ch[Maxn][2];int x, y, z, tot, rt;inline void pushup(int id) &#123; siz[id] = siz[ch[id][0]] + siz[ch[id][1]] + 1;&#125;inline int cre(int v) &#123; siz[++tot] = 1, val[tot] = v, dat[tot] = rand(); return tot;&#125;inline void split(int id, int v, int &amp;x, int &amp;y) &#123; if(!id) x = y = 0; else &#123; if(val[id] &lt;= v) &#123; x = id; split(ch[id][1], v, ch[id][1], y); &#125; else &#123; y = id; split(ch[id][0], v, x, ch[id][0]); &#125; pushup(id); &#125;&#125;inline int merge(int A, int B) &#123; if(!A || !B) return A + B; if(dat[A] &lt; dat[B]) &#123; ch[A][1] = merge(ch[A][1], B); pushup(A); return A; &#125; else &#123; ch[B][0] = merge(A, ch[B][0]); pushup(B); return B; &#125;&#125;inline void insert(int v) &#123; split(rt, v, x, y); rt = merge(merge(x, cre(v)), y);&#125;inline void Delete(int v) &#123; split(rt, v, x, z); split(x, v - 1, x, y); y = merge(ch[y][0], ch[y][1]); rt = merge(merge(x, y), z);&#125;inline int get_rank(int v) &#123; split(rt, v - 1, x, y); int res = siz[x] + 1; rt = merge(x, y); return res;&#125;inline int rank(int id, int r) &#123; while(1) &#123; if(r &lt;= siz[ch[id][0]]) id = ch[id][0]; else if(r == siz[ch[id][0]] + 1) return id; else &#123; r -= (siz[ch[id][0]] + 1); id = ch[id][1]; &#125; &#125;&#125;inline int get_pre(int v) &#123; split(rt, v - 1, x, y); int res = val[rank(x, siz[x])]; rt = merge(x, y); return res;&#125;inline int get_next(int v) &#123; split(rt, v, x, y); int res = val[rank(y, 1)]; rt = merge(x, y); return res;&#125;int main() &#123; n = sc(); while(n--) &#123; int opt = sc(), x = sc(); if(opt == 1) insert(x); else if(opt == 2) Delete(x); else if(opt == 3) out(get_rank(x)), pc('\\n'); else if(opt == 4) out(val[rank(rt, x)]), pc('\\n'); else if(opt == 5) out(get_pre(x)), pc('\\n'); else out(get_next(x)), pc('\\n'); &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"fhq-Treap","slug":"fhq-Treap","permalink":"https://dyrisingsunlight.github.io/tags/fhq-Treap/"}]},{"title":"浅谈Treap","slug":"浅谈Treap","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T15:48:40.560Z","comments":true,"path":"2019/08/08/浅谈Treap/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/08/浅谈Treap/","excerpt":"Problem’s Website普通平衡树 Solution首先这道题可以用多种方法来解决，本篇题解用的是最low的$Treap$，以后可能会另外说明其他几种解法。","text":"Problem’s Website普通平衡树 Solution首先这道题可以用多种方法来解决，本篇题解用的是最low的$Treap$，以后可能会另外说明其他几种解法。 $BST$在讲$Treap$之前，我们先来说一下二叉搜索树。 二叉搜索树($Binary$ $Search$ $Tree$，简称$BST$)，是一种具有特殊性质的二叉树。 性质： 1.树中的每个节点都有一个权值（先假设权值互不相同） 2.若左子树不为空，则左子树上所有节点的权值都小于它根节点的值。3.若右子树不为空，则右子树上所有节点的权值都大于它根节点的值。 4.左右子树都为二叉搜索树。 类似于下图 这种树可以支持多种动态集合操作，条件是所维护的集合存在大小关系。 $Treap$现在我们步入正题，来说明$Treap$。 首先顾名思义，$Treap$ $=$ $Tree$ $+$ $Heap$，也就是树 + 堆，它既满足$BST$，又满足堆的性质。 我们思考一下，为什么要满足的堆的性质呢？ $Answer$: 现在如果有毒瘤出题人将集合中的元素都相等，那么$BST$是不是就退化成了一条链。那这样是不是很费时间？ 那我们怎样使其满足堆的性质呢？ $Answer$：我们可以在每个节点上在rand一个数，确定节点的优先级。 接下来，为了使$Treap$满足要求，我们在必要时需要调整树的结构，那就是旋转。 分为两种，左旋和右旋。 左旋($Zig$)：左旋一棵子树，我们假设这棵树的根节点为$x$，则旋转后$x$成为这棵子树的新根的左子节点，$x$的右子节点会成为子树新的根。 右旋($Zag$):右旋一棵子树，我们假设这棵树的根节点为$x$，则旋转后$x$成为这棵子树的新根的右子节点，$x$的左子节点会成为子树新的根。 画个图感性理解一下： 显然，旋转后的$Treap$仍然满足$BST$和堆的性质。 我们现在看一下code12345678inline void rotate(int &amp;id, int dir) &#123; //id为旋转节点编号，即上文x dir为旋转方向，0为Zig，1为Zag。 int temp = treap[id][dir ^ 1]; //treap[id][0]为根编号为id的左子树，treap[id][1]为右子树。 treap[id][dir ^ 1] = treap[temp][dir]; treap[temp][dir] = id; id = temp; pushup(treap[id][dir]); //pushup为维护一些树的信息，下文会有解释。 pushup(id);&#125; 现在我们来根据题目讲一下$Treap$的一些基本操作。 $Treap$插入元素 1.如果当前节点没有元素，就新建一个。 2.如果有重复的元素，计数器要$+1$。 3.否则，如果左子节点的优先级小于当前节点的优先级，就$Zag$，反之，就$Zig$。 下面是code123456789101112131415inline void insert(int &amp;id, int v) &#123; if(!id) &#123; id = cre(v); //cre函数为新建节点，下文会有解释。 return; &#125; if(v == val[id]) //val为当前节点的权值。 ++cnt[id]; //cnt为计数器，计算重复节点的出现次数。 else &#123; int dir = v &lt; val[id] ? 0 : 1; insert(treap[id][dir], v); if(dat[id] &lt; dat[treap[id][dir]]) //dat为rand的值 rotate(id, dir ^ 1); &#125; pushup(id);&#125; 给个图感性理解下吧~ $Treap$删除元素 $Situation$ $1$: 没有该节点，直接返回。 $Situation$ $2$: 该节点的值有重复，计数器$-1$。 $Situation$ $3$: 该节点有且只有一颗子树 如果只有左子树或左子树优先级大于右子树，就$Zag$（因为只能$Zag$），然后遍历右子树。 否则，就$Zig$，然后遍历左子树。 $Situation$ $4$: 该节点有两颗子树，直接删除。 别忘了根据$BST$的性质进行遍历。 下面是code123456789101112131415161718192021222324252627282930inline void Delete(int &amp;id, int v) &#123; if(!id) return; if(v == val[id]) &#123; if(cnt[id] &gt; 1) &#123; --cnt[id]; pushup(id); return; &#125; if(treap[id][0] || treap[id][1]) &#123; if(!treap[id][1] || dat[treap[id][0]] &gt; dat[treap[id][1]]) &#123; rotate(id, 1); Delete(treap[id][1], v); &#125; else &#123; rotate(id, 0); Delete(treap[id][0], v); &#125; pushup(id); &#125; else id = 0; return; &#125; if(v &lt; val[id]) Delete(treap[id][0], v); else Delete(treap[id][1], v); pushup(id);&#125; 感觉删除操作还是比较好理解的，就不给图了。。。 $Treap$建树 其实这个步骤可以省略，但在本篇题解中，建树会影响下面的操作，所以有必要说明一下。 就是在树上建一个最大值和一个最小值。 直接上code1234inline void build() &#123; rt = cre(-INF), treap[rt][1] = cre(INF); pushup(rt);&#125; 顺便说一下cre函数和pushup函数吧，感觉不需要解释。。。 code如下1234inline int cre(int v) &#123; val[++tot] = v, dat[tot] = rand(), siz[tot] = cnt[tot] = 1; //siz为子树大小 return tot;&#125; 123inline void pushup(int id) &#123; siz[id] = siz[treap[id][0]] + siz[treap[id][1]] + cnt[id];&#125; $Treap$得到排名 $Situation$ $1$: 如果没有该节点，返回0。 $Situation$ $2$: 如果找到该节点，返回该节点左子树的大小$+1$。 $Situation$ $3$: 如果当前值小于左节点，则遍历左子树。 $Situation$ $4$: 否则，在遍历右子树的同时要加上左子树大小和重复的个数。(因为左子树都比该数小) code12345678910inline int get_rank(int id, int v) &#123; if(!id) return 0; if(v == val[id]) return siz[treap[id][0]] + 1; else if(v &lt; val[id]) return get_rank(treap[id][0], v); else return siz[treap[id][0]] + cnt[id] + get_rank(treap[id][1], v);&#125; $Treap$得到排名第几的元素 $Situation$ $1$: 如果没有该节点，返回0。 $Situation$ $2$: 如果排名$\\le$左子树的大小，就遍历左子树。 $Situation$ $3$: 如果排名$\\le$左子树大小$+$重复的元素，就返回该节点。(说明答案就在中区间中) $Situation$ $4$: 否则，遍历右子树，但排名要减去左子树大小$+$重复元素个数。 code12345678910inline int get_val(int id, int rank) &#123; if(!id) return 0; if(rank &lt;= siz[treap[id][0]]) return get_val(treap[id][0], rank); else if(rank &lt;= siz[treap[id][0]] + cnt[id]) return val[id]; else return get_val(treap[id][1], rank - siz[treap[id][0]] - cnt[id]);&#125; $Treap$得到前驱或后驱 思路其实是一样的，只是操作有些小区别，所以只说明求前驱，后驱请读者根据code自行理解。 循环求解，一直查到该节点不存在为止 循环过程中，如果当前节点比目标小，那就往右子树走。 否则，就往左子树走。 注意，做好记录。 code1234567891011121314151617181920inline int get_pre(int v) &#123; //求前驱 int id = rt, pre; while(id) &#123; if(val[id] &lt; v) pre = val[id], id = treap[id][1]; else id = treap[id][0]; &#125; return pre;&#125;inline int get_next(int v) &#123; //求后驱 int id = rt, nxt; while(id) &#123; if(val[id] &gt; v) nxt = val[id], id = treap[id][0]; else id = treap[id][1]; &#125; return nxt;&#125; OK，$Treap$的基本操作就讲完了。 最后是整个题目的具体代码。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 100000 + 10;const int INF = 1e9;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;int n;int rt, tot;int treap[Maxn][2], val[Maxn], dat[Maxn], siz[Maxn], cnt[Maxn];inline int cre(int v) &#123; val[++tot] = v, dat[tot] = rand(), siz[tot] = cnt[tot] = 1; return tot;&#125;inline void pushup(int id) &#123; siz[id] = siz[treap[id][0]] + siz[treap[id][1]] + cnt[id];&#125;inline void build() &#123; rt = cre(-INF), treap[rt][1] = cre(INF); pushup(rt);&#125;inline void rotate(int &amp;id, int dir) &#123; int temp = treap[id][dir ^ 1]; treap[id][dir ^ 1] = treap[temp][dir]; treap[temp][dir] = id; id = temp; pushup(treap[id][dir]); pushup(id);&#125;inline void insert(int &amp;id, int v) &#123; if(!id) &#123; id = cre(v); return; &#125; if(v == val[id]) ++cnt[id]; else &#123; int dir = v &lt; val[id] ? 0 : 1; insert(treap[id][dir], v); if(dat[id] &lt; dat[treap[id][dir]]) rotate(id, dir ^ 1); &#125; pushup(id);&#125;inline void Delete(int &amp;id, int v) &#123; if(!id) return; if(v == val[id]) &#123; if(cnt[id] &gt; 1) &#123; --cnt[id]; pushup(id); return; &#125; if(treap[id][0] || treap[id][1]) &#123; if(!treap[id][1] || dat[treap[id][0]] &gt; dat[treap[id][1]]) &#123; rotate(id, 1); Delete(treap[id][1], v); &#125; else &#123; rotate(id, 0); Delete(treap[id][0], v); &#125; pushup(id); &#125; else id = 0; return; &#125; if(v &lt; val[id]) Delete(treap[id][0], v); else Delete(treap[id][1], v); pushup(id);&#125;inline int get_rank(int id, int v) &#123; if(!id) return 0; if(v == val[id]) return siz[treap[id][0]] + 1; else if(v &lt; val[id]) return get_rank(treap[id][0], v); else return siz[treap[id][0]] + cnt[id] + get_rank(treap[id][1], v);&#125;inline int get_val(int id, int rank) &#123; if(!id) return 0; if(rank &lt;= siz[treap[id][0]]) return get_val(treap[id][0], rank); else if(rank &lt;= siz[treap[id][0]] + cnt[id]) return val[id]; else return get_val(treap[id][1], rank - siz[treap[id][0]] - cnt[id]);&#125;inline int get_pre(int v) &#123; int id = rt, pre; while(id) &#123; if(val[id] &lt; v) pre = val[id], id = treap[id][1]; else id = treap[id][0]; &#125; return pre;&#125;inline int get_next(int v) &#123; int id = rt, nxt; while(id) &#123; if(val[id] &gt; v) nxt = val[id], id = treap[id][0]; else id = treap[id][1]; &#125; return nxt;&#125;int main() &#123; build(); n = sc(); while(n--) &#123; int opt = sc(), x = sc(); if(opt == 1) insert(rt, x); else if(opt == 2) Delete(rt, x); else if(opt == 3) out(get_rank(rt, x) - 1), pc('\\n'); //注意，因为我们之前建树时已经插入了一个最大值和一个最小值，所以求排名和第几大是要稍加修改。 else if(opt == 4) out(get_val(rt, x + 1)), pc('\\n'); //即求排名是得到的答案要-1，求第几大时要+1。 else if(opt == 5) out(get_pre(x)), pc('\\n'); else out(get_next(x)), pc('\\n'); &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"Treap","slug":"Treap","permalink":"https://dyrisingsunlight.github.io/tags/Treap/"}]},{"title":"天天爱跑步","slug":"天天爱跑步","date":"2019-08-06T16:00:00.000Z","updated":"2019-08-07T14:31:59.432Z","comments":true,"path":"2019/08/07/天天爱跑步/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/07/天天爱跑步/","excerpt":"Problem’s Website天天爱跑步 Solution这道题的题意还是很好理解的。 做法好像有很多种，因为我是个 菜鸡 ，所以就说一种比较$low$的做法。","text":"Problem’s Website天天爱跑步 Solution这道题的题意还是很好理解的。 做法好像有很多种，因为我是个 菜鸡 ，所以就说一种比较$low$的做法。 本题要用到的数据结构 树链剖分 动态开点线段树 以上两个内容在我的blog中都有相关内容，如果有不会的同学可以先去学习一下。 基本思路 我们将一个人的路线拆分一下，拆成$s \\to LCA(s, t) \\to t$，那么显然，当$dep[s]-dep[i]==w[i]$或$dep[t]-dep[i]==dis(s,t)-w[i]$时（$dis$为两点间的距离, 前面一个式子用于第一段，后面的式子用于第二段 ），答案可以$+1$，其实我们可以差分来做，但我是 菜鸡，我不会那么做，所以“智商不够，数据结构来凑！”，我们用一个动态开点线段树来维护。 特别注意：对于$LCA$要判重！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 3e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node&#123; int next, to;&#125;Map[Maxn &lt;&lt; 1];int n, m, cnt;int head[Maxn], w[Maxn], s[Maxn], t[Maxn], lca[Maxn], ans[Maxn];int fa[Maxn], son[Maxn], siz[Maxn], top[Maxn], id[Maxn], dep[Maxn];int rt[Maxn * 3], L[Maxn * 30], R[Maxn * 30], sum[Maxn * 30];inline void ADD(int from, int to) &#123; Map[++cnt].next = head[from]; Map[cnt].to = to; head[from] = cnt;&#125;inline void dfs1(int now, int Fa, int Dep) &#123; fa[now] = Fa, dep[now] = Dep, siz[now] = 1; for(re int i = head[now]; i; i = Map[i].next) &#123; int to = Map[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(siz[son[now]] &lt; siz[to]) son[now] = to; &#125;&#125;inline void dfs2(int now, int topf) &#123; id[now] = ++cnt, top[now] = topf; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = Map[i].next) &#123; int to = Map[i].to; if(to == fa[now] || to == son[now]) continue; dfs2(to, to); &#125;&#125;inline int LCA(int x, int y) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); return x;&#125;inline void modify(int &amp;k, int l, int r, int x, int z) &#123; if(!k) k = ++cnt, L[k] = R[k] = sum[k] = 0; sum[k] += z; if(l == r) return ; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(L[k], l, mid, x, z); else modify(R[k], mid + 1, r, x, z);&#125;inline int query(int k, int l, int r, int x, int y) &#123; if(!k) return 0; if(x &lt;= l &amp;&amp; r &lt;= y) return sum[k]; int mid = l + r &gt;&gt; 1, res = 0; if(x &lt;= mid) res += query(L[k], l, mid, x, y); if(y &gt; mid) res += query(R[k], mid + 1, r, x, y); return res;&#125;int main() &#123; n = sc(), m = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y); ADD(y, x); &#125; cnt = 0; dfs1(1, 0, 0), dfs2(1, 1); cnt = 0; for(re int i = 1; i &lt;= n; ++i) w[i] = sc(); for(re int i = 1; i &lt;= m; ++i) &#123; s[i] = sc(), t[i] = sc(); lca[i] = LCA(s[i], t[i]); if(dep[s[i]] - dep[lca[i]] == w[lca[i]]) --ans[lca[i]]; modify(rt[dep[s[i]]], 1, n, id[s[i]], 1); if(fa[lca[i]]) modify(rt[dep[s[i]]], 1, n, id[fa[lca[i]]], -1); &#125; for(re int i = 1; i &lt;= n; ++i) ans[i] += query(rt[dep[i] + w[i]], 1, n, id[i], id[i] + siz[i] - 1); cnt = 0; memset(rt, 0, sizeof(rt)); for(re int i = 1; i &lt;= m; ++i) &#123; modify(rt[dep[s[i]] - (dep[lca[i]] &lt;&lt; 1) + (n &lt;&lt; 1)], 1, n, id[t[i]], 1); if(fa[lca[i]]) modify(rt[dep[s[i]] - (dep[lca[i]] &lt;&lt; 1) + (n &lt;&lt; 1)], 1, n, id[fa[lca[i]]], -1); &#125; for(re int i = 1; i &lt;= n; ++i) &#123; ans[i] += query(rt[w[i] - dep[i] + (n &lt;&lt; 1)], 1, n, id[i], id[i] + siz[i] - 1); out(ans[i]), pc(' '); &#125; pc('\\n'); return 0;&#125;// Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://dyrisingsunlight.github.io/tags/树链剖分/"},{"name":"动态开点线段树","slug":"动态开点线段树","permalink":"https://dyrisingsunlight.github.io/tags/动态开点线段树/"}]},{"title":"运输计划","slug":"运输计划","date":"2019-08-05T16:00:00.000Z","updated":"2019-08-06T14:28:48.560Z","comments":true,"path":"2019/08/06/运输计划/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/06/运输计划/","excerpt":"Problem’s Website运输计划 Solution首先这是一道NOIP的压轴题。 题面好长啊，不少废话，一句话题意： 给定一棵树和m个任务（从$u$点到$v$点），可以使树上的一条边边权为0，让这m个任务中边权之和的最大值最小。","text":"Problem’s Website运输计划 Solution首先这是一道NOIP的压轴题。 题面好长啊，不少废话，一句话题意： 给定一棵树和m个任务（从$u$点到$v$点），可以使树上的一条边边权为0，让这m个任务中边权之和的最大值最小。 最大值最小? 那岂不是可以…… 没错，我们可以二分答案。 那怎样检查答案的正确性呢？ 我们不妨现将每个任务的权值和求出来，然后升序排序，如果当前的mid比最大值还大，那显然没有意义，在有意义的情况下，我们从小到大进行树上差分，最后枚举判断一下每一条边是否可以减少，判断一下如果修改后的最大值不大于当前mid,说明权值还可以缩小，否则就不能再缩小。 看到这，大家肯定有很多疑问，我们一一来解答 如何求每个任务的权值和？ 权值和还是比较好求的，我们在树剖的第一个dfs中记录一下点到根中路径的权值和，那么公式为$dis[u] + dis[v] - 2 \\times dis[LCA(u, v)]$,LCA我们不需要倍增求，直接用树剖记录的$top$数组求即可。 2.为什么要进行树上差分？ 如果是一条满足条件的边修改为0，那么一定存在所有的其他需要修改的航道都经过了这条边（要不然他们就不会减少了）,所以要进行树上差分。 这道压轴题就愉快地AC了！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 3e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node &#123; int next, to, dis;&#125;t[Maxn &lt;&lt; 1];struct MAP &#123; int u, v, d; bool operator &lt; (const MAP &amp;x) const &#123; return d &lt; x.d; &#125;&#125;p[Maxn];int n, m, cnt, l, r , ans;int head[Maxn], fa[Maxn], son[Maxn], siz[Maxn], dep[Maxn], top[Maxn], id[Maxn], rid[Maxn], dis[Maxn], dfa[Maxn], cha[Maxn];inline void ADD(int from, int to, int dis) &#123; t[++cnt].next = head[from]; t[cnt].to = to; t[cnt].dis = dis; head[from] = cnt;&#125;inline void dfs1(int now, int Fa, int Dep) &#123; fa[now] = Fa; dep[now] = Dep; siz[now] = 1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfa[to] = t[i].dis; dis[to] = dis[now] + t[i].dis; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(siz[son[now]] &lt; siz[to]) son[now] = to; &#125;&#125;inline void dfs2(int now, int topf) &#123; id[now] = ++cnt; rid[cnt] = now; top[now] = topf; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == son[now] || to == fa[now]) continue; dfs2(to, to); &#125;&#125;inline int LCA(int x, int y) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); return x;&#125;inline void update(int x, int y) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); ++cha[id[top[x]]]; --cha[id[x] + 1]; x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); --cha[id[y] + 1]; ++cha[id[x] + 1];&#125;inline bool check(int x) &#123; memset(cha, 0, sizeof(cha)); int sum = 0, s = 0; if(p[m].d &lt;= x) return 1; for(re int i = m; i &gt;= 1; --i) &#123; if(p[i].d &lt;= x) break; ++sum; update(p[i].u, p[i].v); &#125; for(re int i = 1; i &lt;= n; ++i) &#123; s += cha[i]; if(s == sum) if(p[m].d - dfa[rid[i]] &lt;= x) return 1; &#125; return 0;&#125;int main() &#123; n = sc(), m = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(), z = sc(); ADD(x, y, z), ADD(y, x, z); &#125; cnt = 0; dfs1(1, 0, 1), dfs2(1, 1); for(re int i = 1; i &lt;= m; ++i) &#123; p[i].u = sc(), p[i].v = sc(); p[i].d = dis[p[i].u] + dis[p[i].v] - (dis[LCA(p[i].u, p[i].v)] &lt;&lt; 1); r = std :: max(r, p[i].d + 1); &#125; std :: sort(p + 1, p + m + 1); while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(check(mid)) ans = mid, r = mid - 1; else l = mid + 1; &#125; out(ans), pc('\\n'); return 0;&#125;//Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://dyrisingsunlight.github.io/tags/树链剖分/"},{"name":"树上差分","slug":"树上差分","permalink":"https://dyrisingsunlight.github.io/tags/树上差分/"}]},{"title":"SDOI_2014旅行","slug":"LvXIng","date":"2019-08-01T16:00:00.000Z","updated":"2019-08-02T03:19:10.535Z","comments":true,"path":"2019/08/02/LvXIng/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/02/LvXIng/","excerpt":"Problem’s WebsiteSDOI_2014旅行 Solution这道题考察了两个知识点，一个是树链剖分，另一个是动态开点线段树。 树剖不会的同学请点击这","text":"Problem’s WebsiteSDOI_2014旅行 Solution这道题考察了两个知识点，一个是树链剖分，另一个是动态开点线段树。 树剖不会的同学请点击这 我们着重来讲一下动态开点线段树 首先我们知道要开一个普通的线段树至少需要元素个数的$4$倍，对于这道题，如果对每一个宗教都开一个线段树显然不行，我们要对线段树进行改变，只保留树上有用的节点，单独用两个数组存左右儿子，查询时，遇到空区就直接返回，下面是两个图，可以帮助大家理解($Drawn$ $by$ $zyb$) 修改9 再修改6 但这种线段树的空间要开操作数的$40$倍，还是要慎用的。 修改函数两个，一个是把原来的去掉，另一个是加上新的内容，请读者根据$code$自行理解。。。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 1e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node &#123; int next, to;&#125;t[Maxn &lt;&lt; 1];struct LST &#123; int sum, maxx, l, r;&#125;lst[Maxn * 40];int n, m, cnt, len;int w[Maxn], c[Maxn], head[Maxn], root[Maxn];int siz[Maxn], top[Maxn], fa[Maxn], dep[Maxn], son[Maxn], id[Maxn];inline void ADD(int from, int to) &#123; t[++cnt].next = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void dfs1(int now, int Fa, int Dep) &#123; fa[now] = Fa; dep[now] = Dep; siz[now] = 1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(siz[son[now]] &lt; siz[to]) son[now] = to; &#125;&#125;inline void dfs2(int now, int topf) &#123; id[now] = ++cnt;// rid[cnt] = now; top[now] = topf; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == son[now] || to == fa[now]) continue; dfs2(to, to); &#125;&#125;inline void modify(int &amp;k, int l, int r, int x, int z) &#123; if(!k) k = ++len; lst[k].maxx = std :: max(lst[k].maxx, z), lst[k].sum += z; if(l == r) return; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(lst[k].l, l, mid, x, z); else modify(lst[k].r, mid + 1, r, x, z);&#125;inline void push(int &amp;k, int l, int r, int x) &#123; if(l == r) &#123; lst[k].maxx = lst[k].sum = 0; return; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) push(lst[k].l, l, mid, x); else push(lst[k].r, mid + 1, r, x); lst[k].maxx = std :: max(lst[lst[k].l].maxx, lst[lst[k].r].maxx); lst[k].sum = lst[lst[k].l].sum + lst[lst[k].r].sum;&#125;inline int querymax(int k, int l, int r, int x, int y) &#123; if(x &gt; r || l &gt; y) return 0; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; return lst[k].maxx; &#125; int mid = l + r &gt;&gt; 1; return std :: max(querymax(lst[k].l, l, mid, x, y), querymax(lst[k].r, mid + 1, r, x, y));&#125;inline int querysum(int k, int l, int r, int x, int y) &#123; if(x &gt; r || l &gt; y) return 0; //y &lt; l || x &gt; r if(x &lt;= l &amp;&amp; r &lt;= y) &#123; //y &gt;= r &amp;&amp; x &lt;= l xlry return lst[k].sum; &#125; int mid = l + r &gt;&gt; 1; return querysum(lst[k].l, l, mid, x, y) + querysum(lst[k].r, mid + 1, r, x, y);&#125;inline int qymax(int x, int y, int cc) &#123; int ans = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); ans = std :: max(ans, querymax(root[cc], 1, n, id[top[x]], id[x])); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); ans = std :: max(ans, querymax(root[cc], 1, n, id[x], id[y])); return ans;&#125;inline int qysum(int x, int y, int cc) &#123; int ans = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); ans += querysum(root[cc], 1, n, id[top[x]], id[x]); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); ans += querysum(root[cc], 1, n, id[x], id[y]); return ans;&#125;int main() &#123; n = sc(), m = sc(); for(re int i = 1; i &lt;= n; ++i) w[i] = sc(), c[i] = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y), ADD(y, x); &#125; cnt = 0; dfs1(1, 0, 1), dfs2(1, 1); for(re int i = 1; i &lt;= n; ++i) modify(root[c[i]], 1, n, id[i], w[i]); while(m--) &#123; char ccc[5]; std :: cin &gt;&gt; ccc; int x = sc(), y = sc(); if(ccc[0] == 'C') &#123; if(ccc[1] == 'C') &#123;// std :: cerr &lt;&lt; root[c[x]] &lt;&lt; std :: endl; push(root[c[x]], 1, n, id[x]); modify(root[y], 1, n, id[x], w[x]); c[x] = y; &#125; else &#123;// std :: cerr &lt;&lt; root[c[x]] &lt;&lt; std :: endl; push(root[c[x]], 1, n, id[x]); modify(root[c[x]], 1, n, id[x], y); w[x] = y; &#125; &#125; else &#123; if(ccc[1] == 'S') &#123; out(qysum(x, y, c[x])), pc('\\n'); &#125; else &#123; out(qymax(x, y, c[x])), pc('\\n'); &#125; &#125; &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://dyrisingsunlight.github.io/tags/树链剖分/"},{"name":"动态开点线段树","slug":"动态开点线段树","permalink":"https://dyrisingsunlight.github.io/tags/动态开点线段树/"}]},{"title":"2019SDSC游记","slug":"2019SDSC游记","date":"2019-07-31T16:00:00.000Z","updated":"2019-08-01T14:09:24.212Z","comments":true,"path":"2019/08/01/2019SDSC游记/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/08/01/2019SDSC游记/","excerpt":"$Day0$上午坐车去山外，路途比较顺利，$1h30min$就到了，相比之前快了不少。 学校环境还行，宿舍设施一般，但有电、有热水。但令我吃惊的是，宿舍里没有脸盆。。。","text":"$Day0$上午坐车去山外，路途比较顺利，$1h30min$就到了，相比之前快了不少。 学校环境还行，宿舍设施一般，但有电、有热水。但令我吃惊的是，宿舍里没有脸盆。。。 宿舍分配也很差劲，我和三个潍坊一中的学生在一起。 山外的饭感觉一般般，适应了一下校园，最后晚上预习了一下明天要学的内容，希望明天不要懵逼。 $Day1$今天rqy讲数论，被公式恶心到了，数论基础基本看了一下，剩下的知识之后专门找时间学习吧。 晚上听rqy的讲座，天才没法比，做好自己就行了。 $Day2$今天真倒霉，上午模拟赛就拿了十分($rank20$，虽然$rank1$才$60$分)。 中午宿舍里几位$sd$过泼水节，本来宿舍里就湿度大，外面还下雨，宿舍就像漏水一样，下午去上课听不懂还发困，伞放在教室外还丢了。。。 $xtbl,wymz$。 $Day3$今天上午模拟赛直接弃疗，自己练习$dp$。 下午讲题分块听懂了一部分，还需多加练习，令我记忆最深刻的是晚上$wqy$的讲座，让我想起了去年$SCzhx$的讲座，又重新激发了我的热情，不要再颓废了，努力！拼搏！ $Day4$今天没有模拟赛，听$wqy$讲课，真好！ 讲了一天字符串（$KMP$，$SA$，$AC$自动机，$SAM$），虽然一部分和$noip$没有很多关系，但基本上理解了，晚上做个规划，目标$2018noipTG400Pts$，加油！ $Day5$上午模拟赛，暴力$70+0+10$，排名中下游，菜的一批。 下午听$wqy$讲计算几何，直接懵逼，自己把上午的模拟赛写了几篇题解，然后发现之前的文章锅连锅，晚上积极补锅，具体发生了什么我忘了……（我不会告诉你们这篇文章和下一篇是$Day7$的时候写的） $Day$6今天$zyb$讲课，讲数据结构，基本上能听懂，上午下午全忘了……只记得晚上搞学术研究，写题解，帮助学弟讲题，导致熄灯后洗澡。。。 $Day7$今天上午$zyb$讲$LCT$，我竟然听懂了，等$SC$结束后专门搞出来。 从早晨开始就一直下雨，到了中午直接成了大暴雨，原本想冲回宿舍，结果遇到了季老师，我好心地帮助$yzch$的一位学弟去食堂。等我在食堂吃完饭，回到宿舍，我的鞋已经全湿了，下午只能穿拖鞋，这也是我第一次穿拖鞋去上课。 $zyb$神仙课前玩游戏、放歌，对$OI$充满了不舍。 下午讲左偏树、可并堆，我没听，直接搞树链剖分，下午$A$了两道模板题，晚上回去用了一个半小时写了篇题解，加深了印象，回去后把这些东西搞明白。 $Day8$今天是$SC$最后一天，昨天晚上熬夜写代码（练习树剖）凌晨$3$点半，也就是说我只睡了$3h$，早晨起来睡眼朦胧，收拾完东西，去吃早餐。 今天是$zzs$讲课，经验及杂题选讲，我直接没听，接着昨晚的计划写树剖，上午效率较低，$A$了一道，还有一道$RE$，准备下午调。 中午吃完饭，回到宿舍退房，退完后发现天气不对，连忙和同学一起带着行李去教室，结果稍微晚了一点，在半路上下起了暴雨，不过影响不大，因为有许多同学因下午导致下午只能呆在宿舍。 下午面对$RE$的代码，直接删掉重写，然后$A$掉了，听$zzs$闲谈了一些东西，就下课了。 在回诸城的路上，帮$lht $调树剖板子，写得真恶心，调了$1h$没调好，直接放弃，然后在车上就一直听歌。 $SC$就这样结束了。 总结今年的$SC$相比去年，可能没有那么多欢乐，但收获和付出的努力却比去年多不少，今年要去$TG$组了，不能再像去年一样了，去年考$PJ$几乎没什么压力，虽然最后差点翻车，但真没放在心上，今年就不一样了，有太多事情阻挠、困扰着我，不管是学业还是父母的决定，回去之后，一定要控制住自己，努力刻苦的学习$OI$和文化课，不管干什么都要认真，要专心致志，抓住事物本质，为了自己的目标！加油！绝不认输！！","categories":[{"name":"游记","slug":"游记","permalink":"https://dyrisingsunlight.github.io/categories/游记/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://dyrisingsunlight.github.io/tags/游记/"}]},{"title":"NOI2015_软件包管理器","slug":"RuanJianBaoGuanLiQi","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-01T14:17:08.781Z","comments":true,"path":"2019/07/30/RuanJianBaoGuanLiQi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/30/RuanJianBaoGuanLiQi/","excerpt":"Problem’s Website NOI_2015软件包管理器Solution 一道经典的树链剖分题，我们把有依赖关系的软件包用树联系起来，对其进行树剖，设1为已安装，0为未安装，赋值前统计1的个数，赋值后取差值即可。 这道题正解是线段树维护，但本菜鸡为了复习ODT，于是就开O2写了个ODT过了这道题。。。 这道题用ODT维护和线段树差不多，核心就是assign函数，也是ODT复杂度的保证。","text":"Problem’s Website NOI_2015软件包管理器Solution 一道经典的树链剖分题，我们把有依赖关系的软件包用树联系起来，对其进行树剖，设1为已安装，0为未安装，赋值前统计1的个数，赋值后取差值即可。 这道题正解是线段树维护，但本菜鸡为了复习ODT，于是就开O2写了个ODT过了这道题。。。 这道题用ODT维护和线段树差不多，核心就是assign函数，也是ODT复杂度的保证。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 2e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;inline int aabs(int x) &#123; return x &gt; 0 ? x : -x;&#125;struct ODT &#123; int l, r; mutable int v; bool operator &lt; (const ODT &amp;x) const &#123; return l &lt; x.l; &#125; ODT(int L, int R = -1, int V = 0) : l(L), r(R), v(V) &#123;&#125;&#125;;std :: set &lt;ODT&gt; s;#define Int std :: set &lt;ODT&gt; :: iteratorInt split(int pos) &#123; Int it = s.lower_bound(ODT(pos)); if(it != s.end() &amp;&amp; it-&gt;l == pos) return it; --it; int L = it-&gt;l, R = it-&gt;r, V = it-&gt;v; s.erase(it), s.insert(ODT(L, pos - 1, V)); return s.insert(ODT(pos, R, V)).first;&#125;int assign(int l, int r, int v) &#123; Int it2 = split(r + 1), it1 = split(l); int sum = 0, SUM = v * (r - l + 1); for(Int it = it1; it != it2; ++it) sum += it-&gt;v * (it-&gt;r - it-&gt;l + 1); s.erase(it1, it2), s.insert(ODT(l, r, v)); return aabs(SUM - sum);&#125;struct node &#123; int next, to;&#125;t[Maxn &lt;&lt; 1];int n, cnt, m;int head[Maxn];int dep[Maxn], fa[Maxn], siz[Maxn], id[Maxn], son[Maxn], top[Maxn];inline void ADD(int from, int to) &#123; t[++cnt].next = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void dfs1(int now, int Fa, int Dep) &#123; dep[now] = Dep; fa[now] = Fa; siz[now] = 1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(siz[son[now]] &lt; siz[to]) son[now] = to; &#125;&#125;inline void dfs2(int now, int topf) &#123; id[now] = ++cnt;// aa[cnt] = a[now]; top[now] = topf;// std :: cerr &lt;&lt; cnt &lt;&lt; std :: endl; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == fa[now] || to == son[now]) continue; dfs2(to, to); &#125;&#125;inline int in(int x, int y) &#123; int res = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); res += assign(id[top[x]], id[x], 1); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); res += assign(id[x], id[y], 1); return res;&#125;inline int un(int x) &#123; return assign(id[x], id[x] + siz[x] - 1, 0);&#125;int main() &#123; n = sc(); s.insert(ODT(1, n + 1, 0)); for(re int i = 2; i &lt;= n; ++i) &#123; int x = sc(); ++x; ADD(x, i); &#125; cnt = 0; dfs1(1, 0, 1); dfs2(1, 1); m = sc(); while(m--) &#123; char c[10]; std :: cin &gt;&gt; c; if(c[0] == 'i') &#123; int x = sc(); ++x; out(in(x, 1)), pc('\\n'); &#125; else &#123; int x = sc(); ++x; out(un(x)), pc('\\n'); &#125; &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://dyrisingsunlight.github.io/tags/树链剖分/"}]},{"title":"SDOI_2011染色","slug":"RanSe","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-01T14:17:05.619Z","comments":true,"path":"2019/07/30/RanSe/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/30/RanSe/","excerpt":"Problems Website SDOI_2011染色","text":"Problems Website SDOI_2011染色 Solution 又是一道熟练剖分的好题，区别是这一次的线段树要维护的信息有所不同，要维护4个东西：$num$(区间内不同颜色的数量)、$lc$(区间最左端的颜色)、$rc$(区间最右端的颜色)、$tag$(染色标记)，在$pushup$时要注意，如果左儿子的$rc$等于右儿子的$lc$，则父亲的$num$等于他们的$num$之和$-1$，因为有重合的颜色。 还有一点，在执行$Q$操作时也要判重，我们设$lc$为当前链的左端点的颜色，$rc$为当前链右端点的颜色，$pos1$为当前要往上跳的路径\\上次的终点颜色，$pos2$为另一条路径\\上一次的终点颜色，在往跳同一条链时，如果$pos1==rc$，则计量数$—$,在同一条链时，如果$lc==pos1$、$rc==pos2$,同样要减计量数。 原因：当出现上述情况时，明显是颜色重合，所以要减。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registertypedef long long ll;const int Maxn = 1e5 + 10;inline ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline ll out(ll x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node &#123; ll next, to;&#125;t[Maxn &lt;&lt; 1];struct LST &#123; ll num, tags, lc, rc;&#125;lst[Maxn &lt;&lt; 2];ll n, m, cnt, pos1, pos2, lc, rc;ll a[Maxn], head[Maxn], dep[Maxn], son[Maxn], fa[Maxn], siz[Maxn], top[Maxn], rid[Maxn], id[Maxn];inline void ADD(ll from, ll to) &#123; t[++cnt].next = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void dfs1(ll now, ll Fa) &#123; dep[now] = dep[Fa] + 1; fa[now] = Fa; siz[now] = 1; for(re int i = head[now]; i; i = t[i].next) &#123; ll to = t[i].to; if(to == Fa) continue; dfs1(to, now); siz[now] += siz[to]; if(siz[son[now]] &lt; siz[to]) son[now] = to; &#125;&#125;inline void dfs2(ll now, ll topf) &#123; top[now] = topf; id[now] = ++cnt; rid[cnt] = now; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; ll to = t[i].to; if(to == son[now] || to == fa[now]) continue; dfs2(to, to); &#125;&#125;inline void pushup(ll k) &#123; lst[k].num = lst[k &lt;&lt; 1].num + lst[k &lt;&lt; 1 | 1].num; if(lst[k &lt;&lt; 1].rc == lst[k &lt;&lt; 1 | 1].lc) --lst[k].num; lst[k].lc = lst[k &lt;&lt; 1].lc; lst[k].rc = lst[k &lt;&lt; 1 | 1].rc;&#125;inline void build(ll k, ll l, ll r) &#123; if(l == r) &#123; lst[k].lc = lst[k].rc = a[rid[l]]; lst[k].num = 1; return; &#125; ll mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid), build(k &lt;&lt; 1 | 1, mid + 1, r); pushup(k);&#125;inline void pushdown(ll k, ll l, ll r) &#123; if(!lst[k].tags) return; lst[k &lt;&lt; 1].lc = lst[k &lt;&lt; 1 | 1].lc = lst[k &lt;&lt; 1].rc = lst[k &lt;&lt; 1 | 1].rc = lst[k &lt;&lt; 1].tags = lst[k &lt;&lt; 1 | 1].tags = lst[k].tags; lst[k &lt;&lt; 1].num = lst[k &lt;&lt; 1 | 1].num = 1; lst[k].tags = 0;&#125;inline void modify(ll k, ll l, ll r, ll x, ll y, ll z) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; lst[k].lc = lst[k].rc = lst[k].tags = z; lst[k].num = 1; return ; &#125; pushdown(k, l, r); ll mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(k &lt;&lt; 1, l, mid, x, y, z); if(y &gt; mid) modify(k &lt;&lt; 1 | 1, mid + 1, r, x, y, z); pushup(k);&#125;inline ll query(ll k, ll l, ll r, ll x, ll y) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; if(x == l) lc = lst[k].lc; if(r == y) rc = lst[k].rc; return lst[k].num; &#125; pushdown(k, l, r); ll mid = l + r &gt;&gt; 1; if(y &lt;= mid) return query(k &lt;&lt; 1, l, mid, x, y); if(x &gt; mid) return query(k &lt;&lt; 1 | 1, mid + 1, r, x, y); ll res = query(k &lt;&lt; 1, l, mid, x, y) + query(k &lt;&lt; 1 | 1, mid + 1, r, x, y); if(lst[k &lt;&lt; 1].rc == lst[k &lt;&lt; 1 | 1].lc) --res; return res;&#125;inline void uptree(ll x, ll y, ll z) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); modify(1, 1, n, id[top[x]], id[x], z); x = fa[top[x]]; &#125; if(id[x] &gt; id[y]) std :: swap(x, y); modify(1, 1, n, id[x], id[y], z);&#125;inline ll qy(ll x, ll y) &#123; ll res = 0; pos1 = pos2 = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y), std :: swap(pos1, pos2); res += query(1, 1, n, id[top[x]], id[x]); if(rc == pos1) --res; pos1 = lc, x = fa[top[x]]; &#125; if(id[x] &gt; id[y]) std :: swap(x, y), std :: swap(pos1, pos2); res += query(1, 1, n, id[x], id[y]); if(lc == pos1) --res; if(rc == pos2) --res; return res;&#125;int main() &#123; n = sc(), m = sc(); for(re int i = 1; i &lt;= n; ++i) a[i] = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y), ADD(y, x); &#125; cnt = 0; dfs1(1, 0), dfs2(1, 1), build(1, 1, n); while(m--) &#123; char c[2]; std :: cin &gt;&gt; c[0]; int x = sc(), y = sc(); if(c[0] == 'Q') &#123; out(qy(x, y)), pc('\\n'); &#125; else &#123; int z = sc(); uptree(x, y, z); &#125; &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://dyrisingsunlight.github.io/tags/树链剖分/"}]},{"title":"JIOI_2014松鼠的新家","slug":"SongShuDeXinJia","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-01T14:17:33.258Z","comments":true,"path":"2019/07/30/SongShuDeXinJia/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/30/SongShuDeXinJia/","excerpt":"Problem’s Wensite JLOI_2014松鼠的新家Solution 这道题有两种解法，一种为树上差分，另一种为树链剖分，下面我简单解释一下。","text":"Problem’s Wensite JLOI_2014松鼠的新家Solution 这道题有两种解法，一种为树上差分，另一种为树链剖分，下面我简单解释一下。 树上差分：一种经典的做法，假设我们要对从$x$到$y$路径上的所有点权$+1$，我们可以在$x,fa[y]$加$1$，在$lca(x, y)$和$fa[lca(x, y)]$减一，最后把整棵树遍历一遍，点权累加，即可得到正确答案。 树链剖分：比较基础的操作，从$x$到$y$的路径上的点权$+1$，但要注意判重。Code 树上差分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 3e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node &#123; int next, to, dis;&#125;t[Maxn &lt;&lt; 1];int n, cnt;int a[Maxn], head[Maxn], dep[Maxn], w[Maxn], siz[Maxn], fa[Maxn], son[Maxn], top[Maxn];inline void ADD(int from, int to) &#123; t[++cnt].next = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void dfs1(int now, int Fa, int Dep) &#123; dep[now] = Dep; fa[now] = Fa; siz[now] = 1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(siz[son[now]] &lt; siz[to]) son[now] = to; &#125;&#125;inline void dfs2(int now, int topf) &#123; top[now] = topf; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == fa[now] || to == son[now]) continue; dfs2(to, to); &#125;&#125;inline void dfs3(int now,int Fa) &#123;// std :: cerr &lt;&lt; now &lt;&lt; \" \" &lt;&lt; father &lt;&lt; std :: endl; for(re int i = head[now]; i; i = t[i].next)&#123; int to = t[i].to; if(to == Fa) continue; dfs3(to, now); w[now] += w[to]; &#125;&#125;inline int LCA(int a,int b) &#123; while(top[a] != top[b]) &#123; if(dep[top[a]] &lt; dep[top[b]]) std :: swap(a,b); a = fa[top[a]]; &#125; if(dep[a] &gt; dep[b]) std :: swap(a,b); return a;&#125;int main() &#123; n = sc(); for(re int i = 1; i &lt;= n; ++i) a[i] = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y), ADD(y, x); &#125; dfs1(1, 0, 1), dfs2(1, 1); for(int i = 2; i &lt;= n; ++i) &#123; int x = a[i - 1], y = a[i]; int lca = LCA(x, y); w[x]++, w[fa[y]]++; w[lca]--, w[fa[lca]]--; &#125; dfs3(1, 1); for(re int i = 1; i &lt;= n; ++i) out(w[i]), pc('\\n'); return 0;&#125;// Coded by dy. 树链剖分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 3e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node &#123; int next, to;&#125;t[Maxn &lt;&lt; 1];struct LST &#123; int data, tag;&#125;lst[Maxn &lt;&lt; 2];int n, cnt;int a[Maxn], head[Maxn];int fa[Maxn], siz[Maxn], son[Maxn], dep[Maxn], id[Maxn], aa[Maxn], top[Maxn];inline void ADD(int from, int to) &#123; t[++cnt].next = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void dfs1(int now, int Fa, int Dep) &#123; dep[now] = Dep; fa[now] = Fa; siz[now] = 1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(siz[son[now]] &lt; siz[to]) son[now] = to; &#125;&#125;inline void dfs2(int now, int topf) &#123; id[now] = ++cnt; aa[cnt] = now; top[now] = topf; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == fa[now] || to == son[now]) continue; dfs2(to, to); &#125;&#125;inline void pushdown(int k, int l, int r) &#123; if(!lst[k].tag) return; lst[k &lt;&lt; 1].tag += lst[k].tag; lst[k &lt;&lt; 1 | 1].tag += lst[k].tag; int len = r - l + 1; lst[k &lt;&lt; 1].data += lst[k].tag * (len - (len &gt;&gt; 1)); lst[k &lt;&lt; 1 | 1].data += lst[k].tag * (len &gt;&gt; 1); lst[k].tag = 0;&#125;inline void modify(int k, int l, int r, int x, int y, int z) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; lst[k].tag += z; lst[k].data += z * (r - l + 1); return ; &#125; pushdown(k, l, r); int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(k &lt;&lt; 1, l, mid, x, y, z); if(y &gt; mid) modify(k &lt;&lt; 1 | 1, mid + 1, r, x, y, z); lst[k].data = lst[k &lt;&lt; 1].data + lst[k &lt;&lt; 1 | 1].data;&#125;inline int query(int k, int l, int r, int x) &#123; if(l == r &amp;&amp; l == x) &#123; return lst[k].data; &#125; int res = 0, mid = l + r &gt;&gt; 1; pushdown(k, l, r); if(x &lt;= mid) res = query(k &lt;&lt; 1, l, mid, x); else res = query(k &lt;&lt; 1 | 1, mid + 1, r, x); return res;&#125;inline void update(int x,int y) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); modify(1, 1, cnt, id[top[x]], id[x], 1); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); modify(1, 1, cnt, id[x], id[y], 1);&#125;int main() &#123; n = sc(); for(re int i = 1; i &lt;= n; ++i) a[i] = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y), ADD(y, x); &#125; cnt = 0; dfs1(1, 0, 1), dfs2(1, 1); for(re int i = 1; i &lt; n; ++i) &#123; update(a[i], a[i + 1]); modify(1, 1, cnt, id[a[i + 1]], id[a[i + 1]], -1); &#125; for(re int i = 1; i &lt;= n; ++i) &#123; out(query(1, 1, cnt, id[i])), pc('\\n'); &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://dyrisingsunlight.github.io/tags/树链剖分/"},{"name":"树上差分","slug":"树上差分","permalink":"https://dyrisingsunlight.github.io/tags/树上差分/"}]},{"title":"浅谈树链剖分","slug":"QianTanShuLianPouFen","date":"2019-07-28T16:00:00.000Z","updated":"2019-08-02T03:18:49.531Z","comments":true,"path":"2019/07/29/QianTanShuLianPouFen/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/29/QianTanShuLianPouFen/","excerpt":"Problem’s Website 模板_树链剖分 ZHOI2008_树的统计Solution 树链剖分前置知识： 线段树 树的dfs遍历 以上内容不会的同学可以先去学习一下，特别是线段树，我的其他几篇Blog有对其的介绍。","text":"Problem’s Website 模板_树链剖分 ZHOI2008_树的统计Solution 树链剖分前置知识： 线段树 树的dfs遍历 以上内容不会的同学可以先去学习一下，特别是线段树，我的其他几篇Blog有对其的介绍。 So，树链剖分到底是啥？ 一句话：在树上做线段树。 首先，我们知道，对一棵树进行dfs遍历，记录每一个点的dfs序，这样就可以把一棵树转化成一个序列，但既然叫树链剖分，肯定不能就这样简单，,我们要通过一些规则将树分成若干条链，那为什么要分链呢？直接对整棵树dfs遍历不就行了吗？ 一开始我就说了，这种做法的正确性肯定是对的，但我们看下图： ，如果对这棵树进行dfs遍历，会用很多时间，如果对一些数据很大题目，很可能就T飞了。。。 所以，我们要分链，目的就是为了降低时间复杂度，那怎样分可以降低呢？很简单，对于一个节点，选择其子树最多的节点。 接下来，我们来说一些专有名词 重儿子：父亲节点的所有儿子中子树结点数目最多的结点； 轻儿子：父亲节点中除了重儿子以外的儿子； 重边：父亲结点和重儿子连成的边； 轻边：父亲节点和轻儿子连成的边； 重链：由多条重边连接而成的路径； 轻链：由多条轻边连接而成的路径.画个图来演示一下我们遍历时，沿着重链进行dfs遍历，上图遍历的顺序见下图 我们再来详细说明一下树链剖分的过程： 首先进行第一次dfs，要求出每个点的深度（dep）、子树大小(siz)、父节点(fa)，和重儿子(son) 1234567891011121314inline void dfs1(int now, int Fa, int Dep) &#123; dep[now] = Dep; siz[now] = 1; fa[now] = Fa; int Maxson = -1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(Maxson &lt; siz[to]) son[now] = to, Maxson = siz[to]; &#125;&#125; 然后进行第二次dfs，求出按照上文提到的规则进行遍历，求出每个点的dfs序(id)、dfs序代表的节点(aa)、每条重链的起点(top) 123456789101112 inline void dfs2(int now, int topf) &#123; id[now] = ++cnt; aa[cnt] = a[now]; top[now] = topf; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == fa[now] || to == son[now]) continue; dfs2(to, to); &#125;&#125; 这样我们就可以按照dfs序建立线段树，并对其进行维护了！ 最后我们介绍一些比较常见的树链剖分操作 下面代码变量的含义在上文，请自行查看。 将树从x到y结点最短路径上所有节点的值都加上z: 首先这两个点有很大可能不在同一条重链上，那我们就让其中深度大的点往上跳到重链的起点，顺便维护该条重链的线段树，最后两个点在同一条重链上，就维护那条链的线段树即可。 123456789 inline void upxy(int x, int y, int z) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); modify(1, 1, n, id[top[x]], id[x], z); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); modify(1, 1, n, id[x], id[y], z);&#125; 求树从x到y结点最短路径上所有节点的值之和\\最大值： 类似于上文，两个点如果不在一条重链，就让其中一个点往上跳，顺便记录信息，最后在一条链上，记录信息。(下面代码为维护区间和，维护区间最大值见下文CodeT2) 1234567891011 inline int qyxy(int x, int y) &#123; int res = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); res = (res + query(1, 1, n, id[top[x]], id[x])) % p; x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); res = (res + query(1, 1, n, id[x], id[y])) % p; return res;&#125; 将以x为根节点的子树内所有节点值都加上z： 我们计算可得，一棵子树的右节点为当前节点的dfs序号+子树大小-1，那我们就线段树区间修改即可。 123 inline void upx(int x, int z) &#123; modify(1, 1, n, id[x], id[x] + siz[x] - 1, z);&#125; 求以x为根节点的子树内所有节点值之和： 类似于上文，用线段树区间查询即可。 123 inline int qyx(int x) &#123; return query(1, 1, n, id[x], id[x] + siz[x] - 1) % p;&#125; 讲到这里，两道题目其实已经解决了，下面是整理后的代码。 2019.8.2 Update: 关于树链剖分的一些性质和其时间复杂度证明。（以下内容来自一本通提高版，由我读后，根据理解自己撰写的） 一些性质： 1.如果$(u,v)$为轻边，则$siz[v] \\le siz[u] /2$ 证明：反证法，如果$siz[v] &gt; siz[u]$,则$siz[v]$要比其他儿子的子树大小要大，那么$(u,v)$必不可能为轻边。 2.从根节点到某一点$node$的路径上的轻边个数不超过$log n$. 证明：根据轻重边的定义，我们可知，当$node$为叶子节点时，轻边的数量最多，有性质$1$可知，每经过一条轻边，子树大小就会比原来少一半，所以至少有$log n$条轻边。 约定：下文中所出现的重路径即为重链（特别地，一个叶子节点也算一条重路径）。 3.对于每个点，从它到根节点的路径上都有不超过$log n$条轻边和$log n$条重路径。 证明：显然每条重路径的起点和终点都是由轻边构成，由性质$2$可知，每个点到根节点的轻边数量为$log n$，所以重路径数量也为$log n$。 树链剖分的时间复杂度及其证明： 对一棵树进行分链后，对于路径$(u,v)$,我们可以分别处理$u,v$两点到其$LCA$的路径，根据性质$3$，路径最多分解成$log n$条重路径和$log n$条轻边，对于重路径，我们可以用一棵线段树来维护，对于轻边，我们直接跳过，访问下一条重路径，因为轻边的两端点一定在两条重路径上，这两种操作的时间复杂度分别为$\\Theta(log^2n)$和$\\Theta(logn)$，总复杂度为$\\Theta(log^2n)$ Code T1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 1e5 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node &#123; int next, to;&#125;t[Maxn &lt;&lt; 1];struct LST &#123; int data, tag;&#125;lst[Maxn &lt;&lt; 2];int n, m, s, p, cnt;int a[Maxn], head[Maxn];int id[Maxn], top[Maxn], son[Maxn], siz[Maxn], aa[Maxn], dep[Maxn], fa[Maxn];inline void ADD(int from, int to) &#123; t[++cnt].next = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void build(int k, int l, int r) &#123; if(l == r) &#123; lst[k].data = aa[l]; if(lst[k].data &gt; p) lst[k].data %= p; return; &#125; int mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid), build(k &lt;&lt; 1 | 1, mid + 1, r); lst[k].data = (lst[k &lt;&lt; 1].data + lst[k &lt;&lt; 1 | 1].data) % p;&#125;inline void pushdown(int k, int l, int r) &#123; if(!lst[k].tag) return; lst[k &lt;&lt; 1].tag += lst[k].tag; lst[k &lt;&lt; 1 | 1].tag += lst[k].tag; int len = r - l + 1; lst[k &lt;&lt; 1].data = (lst[k &lt;&lt; 1].data + lst[k].tag * (len - (len &gt;&gt; 1))) % p; lst[k &lt;&lt; 1 | 1].data = (lst[k &lt;&lt; 1 | 1].data + lst[k].tag * (len &gt;&gt; 1)) % p; lst[k].tag = 0;&#125;inline void modify(int k, int l, int r, int x, int y, int z) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; lst[k].tag += z; lst[k].data = (lst[k].data + z * (r - l + 1)) % p; return; &#125; int mid = l + r &gt;&gt; 1; pushdown(k, l, r); if(x &lt;= mid) modify(k &lt;&lt; 1, l, mid, x, y, z); if(y &gt; mid) modify(k &lt;&lt; 1 | 1, mid + 1, r, x, y, z); lst[k].data = (lst[k &lt;&lt; 1].data + lst[k &lt;&lt; 1 | 1].data) % p;&#125;inline int query(int k, int l, int r, int x, int y) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; return lst[k].data % p; &#125; int res = 0, mid = l + r &gt;&gt; 1; pushdown(k, l, r); if(x &lt;= mid) res = (res + query(k &lt;&lt; 1, l, mid, x, y)) % p; if(y &gt; mid) res = (res + query(k &lt;&lt; 1 | 1, mid + 1, r, x, y)) % p; return res % p;&#125;inline void upxy(int x, int y, int z) &#123; z %= p; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); modify(1, 1, n, id[top[x]], id[x], z); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); modify(1, 1, n, id[x], id[y], z);&#125;inline int qyxy(int x, int y) &#123; int res = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); res = (res + query(1, 1, n, id[top[x]], id[x])) % p; x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); res = (res + query(1, 1, n, id[x], id[y])) % p; return res;&#125;inline void upx(int x, int z) &#123;// z %= p; modify(1, 1, n, id[x], id[x] + siz[x] - 1, z);&#125;inline int qyx(int x) &#123; return query(1, 1, n, id[x], id[x] + siz[x] - 1) % p;&#125;inline void dfs1(int now, int Fa, int Dep) &#123; dep[now] = Dep; siz[now] = 1; fa[now] = Fa; int Maxson = -1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(Maxson &lt; siz[to]) son[now] = to, Maxson = siz[to]; &#125;&#125;inline void dfs2(int now, int topf) &#123; id[now] = ++cnt; aa[cnt] = a[now]; top[now] = topf; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == fa[now] || to == son[now]) continue; dfs2(to, to); &#125;&#125;int main() &#123; n = sc(), m = sc(), s = sc(), p = sc(); for(re int i = 1; i &lt;= n; ++i) a[i] = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y), ADD(y, x); &#125; cnt = 0; dfs1(s, 0, 1), dfs2(s, s), build(1, 1, n); while(m--) &#123; int flag = sc(); if(flag == 1) &#123; int x = sc(), y = sc(), z = sc(); upxy(x, y, z); &#125; else if(flag == 2) &#123; int x = sc(), y = sc(); out(qyxy(x, y)), pc('\\n'); &#125; else if(flag == 3) &#123; int x = sc(), z = sc(); upx(x, z); &#125; else &#123; int x = sc(); out(qyx(x)), pc('\\n'); &#125; &#125; return 0;&#125;// Coded by dy. T2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 6e4 + 10;const int INF = 30000 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;struct node &#123; int next, to;&#125;t[Maxn &lt;&lt; 1];struct LST &#123; int sum, maxx;&#125;lst[Maxn &lt;&lt; 2];int n, cnt, m;int head[Maxn], a[Maxn];int id[Maxn], top[Maxn], dep[Maxn], fa[Maxn], aa[Maxn], son[Maxn], siz[Maxn];inline void ADD(int from, int to) &#123; t[++cnt].next = head[from]; t[cnt].to = to; head[from] = cnt;&#125;inline void build(int k, int l, int r) &#123; if(l == r) &#123; lst[k].sum = lst[k].maxx = aa[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid), build(k &lt;&lt; 1 | 1, mid + 1, r); lst[k].maxx = std :: max(lst[k &lt;&lt; 1].maxx, lst[k &lt;&lt; 1 | 1].maxx); lst[k].sum = lst[k &lt;&lt; 1].sum + lst[k &lt;&lt; 1 | 1].sum;&#125;inline void modify(int k, int l, int r, int x, int z) &#123; if(l == r &amp;&amp; l == x) &#123; lst[k].sum = lst[k].maxx = z; return ; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(k &lt;&lt; 1, l, mid, x, z); else modify(k &lt;&lt; 1 | 1, mid + 1, r, x, z); lst[k].maxx = std :: max(lst[k &lt;&lt; 1].maxx, lst[k &lt;&lt; 1 | 1].maxx); lst[k].sum = lst[k &lt;&lt; 1].sum + lst[k &lt;&lt; 1 | 1].sum;&#125;inline int query_max(int k, int l, int r, int x, int y) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; return lst[k].maxx; &#125; int res = -INF, mid = l + r &gt;&gt; 1; if(x &lt;= mid) res = std :: max(res, query_max(k &lt;&lt; 1, l, mid, x, y)); if(y &gt; mid) res = std :: max(res, query_max(k &lt;&lt; 1 | 1, mid + 1, r, x, y)); return res;&#125;inline int query_sum(int k, int l, int r, int x, int y) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; return lst[k].sum; &#125; int res = 0 , mid = l + r &gt;&gt; 1; if(x &lt;= mid) res += query_sum(k &lt;&lt; 1, l, mid, x, y); if(y &gt; mid) res += query_sum(k &lt;&lt; 1 | 1, mid + 1, r, x, y); return res;&#125;inline void update(int x, int z) &#123; modify(1, 1, n, id[x], z);&#125;inline int qymax(int x, int y) &#123; int res = -INF; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); res = std :: max(res, query_max(1, 1, n, id[top[x]], id[x])); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); res = std :: max(res, query_max(1, 1, n, id[x], id[y])); return res;&#125;inline int qysum(int x, int y) &#123; int res = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std :: swap(x, y); res += query_sum(1, 1, n, id[top[x]], id[x]); x = fa[top[x]]; &#125; if(dep[x] &gt; dep[y]) std :: swap(x, y); res += query_sum(1, 1, n, id[x], id[y]); return res;&#125;inline void dfs1(int now, int Fa,int Dep) &#123; dep[now] = Dep; fa[now] = Fa; siz[now] = 1; int Maxson = -1; for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == Fa) continue; dfs1(to, now, Dep + 1); siz[now] += siz[to]; if(siz[to] &gt; Maxson) Maxson = siz[to], son[now] = to; &#125;&#125;inline void dfs2(int now, int topf) &#123; top[now] = topf; id[now] = ++cnt; aa[cnt] = a[now]; if(!son[now]) return; dfs2(son[now], topf); for(re int i = head[now]; i; i = t[i].next) &#123; int to = t[i].to; if(to == son[now] || to == fa[now]) continue; dfs2(to, to); &#125;&#125;int main() &#123; n = sc(); for(re int i = 1; i &lt; n; ++i) &#123; int x = sc(), y = sc(); ADD(x, y), ADD(y, x); &#125; for(re int i = 1; i &lt;= n; ++i) a[i] = sc(); cnt = 0; dfs1(1, 0, 1), dfs2(1, 1), build(1, 1, n); m = sc(); while(m--) &#123; char c[10]; std :: cin &gt;&gt; c; if(c[0] == 'C') &#123; int x = sc(), z = sc(); update(x, z); &#125; else if(c[1] == 'M') &#123; int x = sc(), y = sc(); out(qymax(x, y)), pc('\\n'); &#125; else &#123; int x = sc(), y = sc(); out(qysum(x, y)), pc('\\n'); &#125; &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://dyrisingsunlight.github.io/tags/树链剖分/"}]},{"title":"ST表模板","slug":"STBiaoMuBan","date":"2019-07-27T16:00:00.000Z","updated":"2019-08-01T14:22:00.373Z","comments":true,"path":"2019/07/28/STBiaoMuBan/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/28/STBiaoMuBan/","excerpt":"Problem’s Website 模板_ST表","text":"Problem’s Website 模板_ST表 Solution ST表是一种利用倍增实现快速查找区间内极值的黑科技，但一般的ST表都是静态的，本菜鸡不会动态修改。。。 我们设$st[i][j]$为从第$i$个位置开始，长度为$2^j$中的极值，那怎样处理呢？代码为(以取最大值为例) 12st[i][0] = a[i];st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); 第二行的大家可能不太懂，我画个图解释一下 那怎样区间求极值呢？假设区间为$[x,y]$代码为 12int p = (int)log2(y - x + 1);ans = max(st[x][p], st[y - (1 &lt;&lt; p) + 1][p]); 我再来画个图来解释一下 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 100010;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;int n, m;int st[Maxn][20];int main() &#123; n = sc(), m = sc(); for(re int i = 1; i &lt;= n; ++i) st[i][0] = sc(); int lim = (int)log2(n);// std :: cerr &lt;&lt; lim &lt;&lt; std :: endl; for(re int j = 1; j &lt;= lim; ++j) for(re int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; ++i) st[i][j] = std :: max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for(re int i = 1; i &lt;= m; ++i) &#123; int x = sc(), y = sc(); int p = (int)log2(y - x + 1); out(std :: max(st[x][p], st[y - (1 &lt;&lt; p) + 1][p])), pc('\\n'); &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"https://dyrisingsunlight.github.io/tags/倍增/"}]},{"title":"分块区间修改区间查询","slug":"FenKuaiQuJianXiuGaiQuJianChaXun","date":"2019-07-27T16:00:00.000Z","updated":"2019-08-01T14:15:04.042Z","comments":true,"path":"2019/07/28/FenKuaiQuJianXiuGaiQuJianChaXun/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/28/FenKuaiQuJianXiuGaiQuJianChaXun/","excerpt":"Problem’s Website 模板_线段树2Solution 这道题可以用多种方法解决，例如线段树、树状数组，这些内容本菜鸡曾经写过，可以去我的其他Blog查看，本篇题解说一些分块做法。","text":"Problem’s Website 模板_线段树2Solution 这道题可以用多种方法解决，例如线段树、树状数组，这些内容本菜鸡曾经写过，可以去我的其他Blog查看，本篇题解说一些分块做法。 分块是一种根号数据结构，优雅的暴力，时间复杂度为$\\Theta(m \\sqrt{n})$，大意就是把整个序列分成$\\sqrt{n}$块，带两个标记，一个乘法标记、加法标记，每次区间修改$[x,y]$把两个元素所在的块中下传标记，修改时，如果$x,y$在同一块内，就维护区间修改，否则就把在一个块的内容区间修改，把两边剩余的块暴力修改。 听到上面的解释可能有点懵，我把代码中的变量解释一下，然后详解在下面的Code中。 $sum[i]$为第$i$块的区间和。 $l[i], r[i]$为第$i$块的左右端点。 $pos[i]$为第i个元素在第几个块。 $add[i]mul[i]$为加法乘法标记。 $tot[i]$为第$i$个块的元素个数。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define gc getchar()using namespace std;typedef long long ll;const int Maxn = 100000 + 10;ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;ll n, m, sq, mod;ll a[Maxn];ll pos[Maxn], l[400], r[400], sum[400], add[400], tot[400], mul[400];void pushdown(ll x) &#123; //下传标记，把x所在的块的标记更新到块内每个元素上 for(int i = l[pos[x]]; i &lt;= r[pos[x]]; i++) a[i] = (a[i] * mul[pos[x]] + add[pos[x]]) % mod; //更新 mul[pos[x]] = 1; add[pos[x]] = 0; //标记初始化 &#125;void modify1(ll x, ll y, ll num) &#123; //乘法 pushdown(x); //先把x所在块pushdown if(pos[x] == pos[y]) &#123; //x,y在同一块内 for(int i = x; i &lt;= y; i++) &#123; //更新 sum[pos[i]] += a[i] * (num - 1); a[i] *= num; a[i] %= mod; &#125; sum[pos[x]] %= mod; return ; &#125; pushdown(y); //把y所在的块pushdown for(int i = pos[x] + 1; i &lt;= pos[y] - 1; i++) &#123; //整块修改 sum[i] *= num; sum[i] %= mod; mul[i] *= num; mul[i] %= mod; add[i] *= num; add[i] %= mod; //注意乘法是加法标记也要维护 &#125; for(int i = x; i &lt;= r[pos[x]]; i++) &#123; //修改左边多出的块 // cout &lt;&lt; i &lt;&lt; \" \"; sum[pos[i]] += (num - 1) * a[i]; a[i] *= num; a[i] %= mod; &#125;// cout &lt;&lt; endl; sum[pos[x]] %= mod; for(int i = l[pos[y]]; i &lt;= y; i++) &#123; //修改右边多出的块 // cout &lt;&lt; i &lt;&lt; \" \"; sum[pos[i]] += (num - 1) * a[i]; a[i] *= num; a[i] %= mod; &#125;// cout &lt;&lt; endl; sum[pos[y]] %= mod;&#125;void modify2(ll x, ll y, ll num) &#123; //加法，同上 pushdown(x); if(pos[x] == pos[y]) &#123; for(int i = x; i &lt;= y; i++) &#123; a[i] += num, sum[pos[i]] += num; &#125; sum[pos[x]] %= mod; return ; &#125; pushdown(y); for(int i = pos[x] + 1; i &lt;= pos[y] - 1; i++) &#123; sum[i] += num * tot[i]; add[i] += num; &#125; for(int i = x; i &lt;= r[pos[x]]; i++) &#123; a[i] += num, sum[pos[i]] += num; &#125; for(int i = l[pos[y]]; i &lt;= y; i++) &#123; a[i] += num, sum[pos[i]] += num; &#125; sum[pos[x]] %= mod; sum[pos[y]] %= mod;&#125;ll query(ll x, ll y) &#123; //区间查询，基本含义同上 ll res = 0; if(pos[x] == pos[y]) &#123; for(int i = x; i &lt;= y; i++) res += (a[i] * mul[pos[i]] + add[pos[i]]); return res; &#125; for(int i = pos[x] + 1; i &lt;= pos[y] - 1; i++) res += sum[i]; for(int i = x; i &lt;= r[pos[x]]; i++) res += (a[i] * mul[pos[i]] + add[pos[i]]); for(int i = l[pos[y]]; i &lt;= y; i++) res += (a[i] * mul[pos[i]] + add[pos[i]]); return res % mod;&#125;int main() &#123; n = sc(); m = sc(); mod = sc(); sq = (ll)sqrt(n); for(int i = 1; i &lt;= n; i++) &#123; a[i] = sc(); pos[i] = (i - 1) / sq + 1; //用公式计算出第i个元素在第几个块 if(!l[pos[i]]) l[pos[i]] = i; //如果左端点为标记，就标记上 r[pos[i]] = i; //不断更新右端点，到最后一定正确 tot[pos[i]]++; //元素个数++ sum[pos[i]] += a[i]; //区间和维护 mul[pos[i]] = 1; //乘法标记要初始化为1 &#125; while(m--) &#123; ll flag = sc(), x = sc(), y = sc(); if(flag == 1) &#123; ll num = sc(); modify1(x, y, num); //区间乘法 &#125; else if(flag == 2) &#123; ll num = sc(); modify2(x, y, num); //区间加法 &#125; else &#123; printf(\"%lld\\n\", query(x, y)); //区间求和 &#125; &#125; return 0;&#125;// Coded by dy. rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://dyrisingsunlight.github.io/tags/分块/"}]},{"title":"248","slug":"248","date":"2019-07-27T16:00:00.000Z","updated":"2019-08-01T14:12:53.364Z","comments":true,"path":"2019/07/28/248/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/28/248/","excerpt":"Problem’s Website 248","text":"Problem’s Website 248 Solution 这道题是一道区间dp模板题，区间dp，根据名称，我们可以得出是在区间内做dp，一般设$f[i][j]$为左端点为$i$,右端点为$j$是的某一状态，对于这道题来说，$f[i][j]$为把$i$到$j$合并的最大值。 我们首先从大到小枚举左右端点，如果相邻两个相等，就可以合并，所以伪代码为 123456for i (n-1) ~ 1 for j (i+1) ~ n for k i ~ j if(f[i][k] == f[k+1][j]) f[i][j] = max(~, f[i][k]+1); ans = max(~, f[i][j]); 答案即为ans. Code123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 300;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;int n, ans;int f[Maxn][Maxn];int main() &#123; n = sc(); for(re int i = 1; i &lt;= n; ++i) f[i][i] = sc(), ans = std :: max(ans, f[i][i]); for(re int i = n - 1; i &gt;= 1; --i) for(re int j = i + 1; j &lt;= n; ++j) for(re int k = i; k &lt; j; k++) &#123; if(f[i][k] == f[k + 1][j]) &#123; f[i][j] = std :: max(f[i][j], f[i][k] + 1); &#125; ans = std :: max(ans, f[i][j]); &#125; out(ans), pc('\\n'); return 0;&#125;// Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"页面","slug":"Page","date":"2019-07-26T16:00:00.000Z","updated":"2019-08-01T14:16:34.908Z","comments":true,"path":"2019/07/27/Page/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/27/Page/","excerpt":"Problem’s Website 页面","text":"Problem’s Website 页面 Solution 这道题听说是算法导论中的原题，是一道贪心题，如果内存已满，那我们就用当前内容替换内存中下一次出现最远的内容，我们可以用一个数组把当前内容下一次出现的位置记录下来，用STL堆来维护内存。Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define gc getchar()#define pc(x) putchar(x)#define re registerconst int Maxn = 200000 + 10;inline int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(int x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;int n, k, ans;int a[Maxn], lst[Maxn], nxt[Maxn];bool pd[Maxn];std :: priority_queue &lt;std :: pair &lt;int, int&gt; &gt; q, in;int main() &#123;// freopen(\"page.in\", \"r\", stdin);// freopen(\"page.out\", \"w\", stdout); n = sc(), k = sc(); for(re int i = 1; i &lt;= n; ++i) &#123; a[i] = sc(); nxt[lst[a[i]]]=i; lst[a[i]]=i; &#125; for(re int i = 1; i &lt;= Maxn - 10; ++i) &#123; if(lst[i]) nxt[lst[i]] = n + 1; &#125; int cnt = 0; for(re int i = 1; i &lt;= n; ++i) &#123; if(pd[a[i]]) &#123; in.push(std :: make_pair(i, a[i])); q.push(std :: make_pair(nxt[i], a[i])); continue; &#125; if(cnt &lt; k) &#123; pd[a[i]] = 1; q.push(std :: make_pair(nxt[i], a[i])); ++ans; ++cnt; &#125; else &#123; while(!q.empty() &amp;&amp; !in.empty() &amp;&amp; q.top() == in.top()) q.pop(), in.pop(); int top = q.top().second; q.pop();// std :: cerr &lt;&lt; top &lt;&lt; std :: endl; pd[top] = 0, pd[a[i]] = 1; q.push(std :: make_pair(nxt[i], a[i])); ++ans; &#125; &#125; out(ans), pc('\\n'); return 0;&#125;// Coded by dy. rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://dyrisingsunlight.github.io/tags/贪心/"}]},{"title":"曼哈顿","slug":"Manhattan","date":"2019-07-26T16:00:00.000Z","updated":"2019-08-01T14:16:07.338Z","comments":true,"path":"2019/07/27/Manhattan/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/27/Manhattan/","excerpt":"Problem’s Website 曼哈顿","text":"Problem’s Website 曼哈顿 Solution 首先我们可以写一个$\\Theta(n^2)$的暴力，加上卡常可以拿到70分的好成绩，而且可以用来对拍。 然后说正解，这道题目有很多种解法，这里说两种。 第一种为分治，将横纵坐标分开计算，分别升序排序，然后类似于归并，进行计算，因为这种算法并未出自出题人，所以这里不细讲，请自行看代码理解。 第二种为出题人的解法，我们可以把求ans的式子写出来 $ans=\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}(|x_i-x_j|+|y_i-y_j|)$ $=(\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}(|x_i-x_j|))+(\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}(|y_i-y_j|))$ ，由于式子是独立的，所以我们可以分开计算，我们把其中 $(\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}(|x_i-x_j|))$拿出来观察，第$i$个空缺（也就是$x_{i+1}-x_i$） ，这个空缺会被统计入答案，当且仅当一个点在一侧，另一个点在另一侧，所以这一部分对答案的贡献就是 $2i(n-i)(x_{i+1}-x_i)$。所以我们可以直接排序，时间复杂度为$\\Theta(n log n)$.Code 分治（$Coded$ $by$ $Jhonson$） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 300010;int a[N], b[N], c[N];inline int get_num()&#123; register int now = 0; register char ch = getchar(); register bool sign = false; while (!isdigit(ch)) &#123; if (ch == '-') sign = true; ch = getchar(); &#125; while (isdigit(ch)) &#123; now = (now &lt;&lt; 1) + (now &lt;&lt; 3) + ch - '0'; ch = getchar(); &#125; return (sign == false ? now : -now);&#125;long long ans = 0;inline void solve(int l, int r)&#123; if (l == r) return; register int mid = (l + r) &gt;&gt; 1; solve(l, mid), solve(mid + 1, r); register long long ret = 0; for (register int i = mid + 1; i &lt;= r; ++i) &#123; ret += c[i] - c[mid]; &#125; for (register int i = l; i &lt;= mid; ++i) &#123; ans += (c[mid] - c[i]) * (r - mid) + ret; &#125;&#125;int main()&#123; freopen(\"manhattan.in\", \"r\", stdin); freopen(\"manhattan.out\", \"w\", stdout); register int n; n = get_num(); for (register int i = 1; i &lt;= n; ++i) &#123; a[i] = get_num(), b[i] = get_num(); &#125; sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); for (register int i = 1; i &lt;= n; ++i) c[i] = a[i]; solve(1, n); for (register int i = 1; i &lt;= n; ++i) c[i] = b[i]; solve(1, n); printf(\"%lld\\n\", ans); fclose(stdin); fclose(stdout); return 0;&#125; 正常解法（$Coded$ $by$ $dy(me)$） 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)#define re registertypedef long long ll;const int Maxn = 300000 + 10;inline ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;inline void out(ll x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;int n;ll a[Maxn], b[Maxn];ll ans;int main() &#123; scanf(\"%d\", &amp;n); for(re int i = 1; i &lt;= n; ++i) a[i] = sc(), b[i] = sc(); std :: sort(a + 1, a + n + 1); std :: sort(b + 1, b + n + 1); for(re int i = 1; i &lt; n; ++i) ans += (a[i + 1] - a[i]) * i * (n - i); for(re int i = 1; i &lt; n; ++i) ans += (b[i + 1] - b[i]) * i * (n - i); out(ans), pc('\\n'); return 0;&#125;// Coded by dy. rp+","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://dyrisingsunlight.github.io/tags/模拟/"},{"name":"分治","slug":"分治","permalink":"https://dyrisingsunlight.github.io/tags/分治/"}]},{"title":"树状数组区间修改区间查询","slug":"ShuZhuangShuZuQuJianXiuGaiQuJianChaXun","date":"2019-07-26T16:00:00.000Z","updated":"2019-08-01T14:17:30.038Z","comments":true,"path":"2019/07/27/ShuZhuangShuZuQuJianXiuGaiQuJianChaXun/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/27/ShuZhuangShuZuQuJianXiuGaiQuJianChaXun/","excerpt":"相关题目链接 线段树1","text":"相关题目链接 线段树1 Solution 首先看到题目标题，我们就知道要用线段树，但这道题还可以用其他方法来AC，比如树状数组，不仅代码量少，而且常数还小，根据树状数组模板2我们知道，树状数组的区间修改是要用差分的，这点我的另一篇Blog介绍过，不懂的点击这。 接下来我们直接将如果用树状数组实现区间修改区间查询。我们用a数组表示原序列，d数组表示差分数组,我们可得 $\\sum\\limits_{i=1}^{p}a[i]=\\sum\\limits_{i=1}^{p}\\sum\\limits_{j=1}^{i}d[j]$ ,在右侧的式子中，$d[1]$被用了$p$次，$d[2]$被用了$p-1$次,我们可以推出位置p的前缀和\\sum\\limits_{i=1}^{p}\\sum\\limits_{j=1}^{i}d[j]=\\sum\\limits_{i=1}^{p}d[i]*(p*i-1)=\\sum\\limits_{i=1}^{p}d[i]-\\sum\\limits_{i=1}^{p}d[i]*i,我们可以维护两个数组前缀和$sum1[i]=d[i]$,另一个数组$sum2[i]=d[i]*i$ 查询 位置$p$的前缀和即： $(p + 1) * sum1$数组中$p$的前缀和- sum2数组中p的前缀和。区间[l, r]的和即：位置r的前缀和 - 位置l的前缀和。 修改 对于sum1数组的修改同问题2中对$d$数组的修改。 对于sum2数组的修改也类似，我们给 sum2[l] 加上 $l \\times x$ ，给 sum2[r + 1] 减去 $(r + 1) \\times x$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define pc(x) putchar(x)typedef long long ll;const int Maxn = 100000 + 10;ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while(!isdigit(cch)) &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(isdigit(cch)) &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;void out(ll x) &#123; if(x &lt; 0) pc('-'), x = -x; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;ll n, m;ll sum1[Maxn], sum2[Maxn];ll lowbit(ll x) &#123; return x &amp; (-x);&#125; void modify(ll x, ll num) &#123; for(int i = x; i &lt;= n; i += lowbit(i)) sum1[i] += num, sum2[i] += num * x;&#125;void update(ll x, ll y, ll num) &#123; modify(x, num); modify(y + 1, -num);&#125;ll ask(ll x) &#123; ll ans = 0; for(int i = x; i; i -= lowbit(i)) ans += (x + 1) * sum1[i] - sum2[i]; return ans;&#125;ll query(ll x, ll y) &#123; return ask(y) - ask(x - 1);&#125;int main() &#123; n = sc(); m = sc(); for(int i = 1; i &lt;= n; ++i) update(i, i, sc()); while(m--) &#123; ll flag = sc(), x = sc(), y = sc(); if(flag == 1) &#123; ll num = sc(); update(x, y, num); &#125; else &#123; out(query(x, y)), pc('\\n'); &#125; &#125; return 0;&#125;// Coded by dy. rp++*","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://dyrisingsunlight.github.io/tags/树状数组/"}]},{"title":"时钟","slug":"ShiZhong","date":"2019-07-25T16:00:00.000Z","updated":"2019-08-01T14:17:17.632Z","comments":true,"path":"2019/07/26/ShiZhong/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/26/ShiZhong/","excerpt":"Problem’s Website 时钟","text":"Problem’s Website 时钟 Solution 一道比较好的dfs，我们直接对3、6、9、12取模，把9种变化方式用数组存起来，用一个数组存变化的方式，因为是从1-9dfs，所以可以保证输出顺序是字典序最小的。Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-1; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;int node[10][10]=&#123; &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,1,1,0,1,1,0,0,0,0&#125;, &#123;0,1,1,1,0,0,0,0,0,0&#125;, &#123;0,0,1,1,0,1,1,0,0,0&#125;, &#123;0,1,0,0,1,0,0,1,0,0&#125;, &#123;0,0,1,0,1,1,1,0,1,0&#125;, &#123;0,0,0,1,0,0,1,0,0,1&#125;, &#123;0,0,0,0,1,1,0,1,1,0&#125;, &#123;0,0,0,0,0,0,0,1,1,1&#125;, &#123;0,0,0,0,0,1,1,0,1,1&#125;&#125;;int a[11],now[11],num[11];namespace Dy &#123; void dfs(int way) &#123; for(int i=1; i&lt;=9; i++) now[i]=a[i]; for(int i=1; i&lt;=9; i++) for(int j=1; j&lt;=9; j++) &#123; now[i]=now[i]+node[j][i]*num[j]; if(now[i]&gt;5) now[i]-=4;// cout&lt;&lt;now[i]&lt;&lt;\" \"; &#125;// cout&lt;&lt;endl; bool flag=0; for(int i=1; i&lt;=9; i++) if(now[i]!=4) &#123; flag=1; break; &#125; if(!flag) &#123; for(int i=1; i&lt;=9; i++) for(int j=1; j&lt;=num[i]; j++) printf(\"%d \",i);// cout&lt;&lt;endl; way=10; return ; &#125; if(way==10) return ; for(int i=0; i&lt;=3; i++) num[way]=i,dfs(way+1); &#125; void RPpp() &#123;// cout&lt;&lt;node[1][3]&lt;&lt;endl; for(int i=1; i&lt;=9; i++) &#123; int x=sc(); a[i]=x/3; &#125; dfs(1); &#125;&#125;;int main() &#123; Dy::RPpp(); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://dyrisingsunlight.github.io/tags/dfs/"}]},{"title":"SHOI2001_Panda的烦恼","slug":"PandaDeFanNao","date":"2019-07-25T16:00:00.000Z","updated":"2019-08-01T14:16:37.286Z","comments":true,"path":"2019/07/26/PandaDeFanNao/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/26/PandaDeFanNao/","excerpt":"Problem’s Website SHOI2001_Panda的烦恼","text":"Problem’s Website SHOI2001_Panda的烦恼 Solution 这道题我们可以乱搞，用一个数组存计算的数，另一个数组存下一步要乘的数，这个方法是借鉴了洛谷首篇题解的方法。Code123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 100010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;int n,k,cnt;int a[Maxn],ans[Maxn]=&#123;1&#125;,b[Maxn];namespace Dy &#123; void RPpp() &#123; n=sc(); k=sc(); for(int i=1; i&lt;=n; i++) a[i]=sc(); while(cnt&lt;k) &#123; int maxx=0x7fffffff,maxi; for(int i=1; i&lt;=n; i++) &#123; if(ans[b[i]]*a[i]&lt;maxx) &#123; maxx=ans[b[i]]*a[i]; maxi=i; &#125; &#125; b[maxi]++; if(ans[cnt]!=maxx) ans[++cnt]=maxx; &#125; printf(\"%d\",ans[k]); &#125;&#125;;int main() &#123; Dy::RPpp(); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"乱搞","slug":"乱搞","permalink":"https://dyrisingsunlight.github.io/tags/乱搞/"}]},{"title":"绝望","slug":"Hopeless","date":"2019-07-25T16:00:00.000Z","updated":"2019-08-01T14:15:14.068Z","comments":true,"path":"2019/07/26/Hopeless/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/26/Hopeless/","excerpt":"Problem’s Website] Hopeless","text":"Problem’s Website] Hopeless Solution Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define gc getchar()#define pc(x) putchar(x)typedef long long ll;const int Maxn = 1e5 + 10;ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;void out(ll x) &#123; if(x &gt;= 10) out(x / 10); pc(x % 10 + '0');&#125;ll t, n, h;ll a[Maxn], f[Maxn];int main() &#123; freopen(\"hopeless.in\", \"r\", stdin); freopen(\"hopeless.out\", \"w\", stdout); t = sc(); while(t--) &#123; n = sc(); f[h = 0] = 0; for(int i = 0; i &lt; n; ++i) a[i] = sc(); std :: sort(a, a + n); for(int i = 0; i &lt; n; ++i) &#123; ll last = a[i]; while(a[i] &gt;&gt; (h + 1)) f[++h] = 0; ll t = 1; for(int j = 0; j &lt; h; ++j) if((last &gt;&gt; j) &amp; 1) t += f[j]; f[h] = std :: max(f[h], t); &#125; ll ans = 0; for(int i = 0; i &lt;= h; ++i) ans += f[i]; out(ans); pc('\\n'); &#125; return 0;&#125;// !dy rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"子串变换","slug":"ZiChuanBianHua","date":"2019-07-25T16:00:00.000Z","updated":"2019-08-01T14:19:12.817Z","comments":true,"path":"2019/07/26/ZiChuanBianHua/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/26/ZiChuanBianHua/","excerpt":"Problem’s Website 字串变换Solution 这道题是一道比较基础的搜索题，但要会用一个很方便的STL函数——string类型的replace()，不会的请点击这，其他就直接bfs就可以了。","text":"Problem’s Website 字串变换Solution 这道题是一道比较基础的搜索题，但要会用一个很方便的STL函数——string类型的replace()，不会的请点击这，其他就直接bfs就可以了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;int cnt=1;string st,end;string a[10],b[10];queue &lt;string&gt; q;queue &lt;int&gt; ans;map &lt;string,bool&gt; vis;namespace Dy &#123; void AKNOIP() &#123; cin&gt;&gt;st&gt;&gt;end; while(cin&gt;&gt;a[cnt]&gt;&gt;b[cnt]) cnt++; cnt--; q.push(st); ans.push(0); while(!q.empty()&amp;&amp;q.front()!=end&amp;&amp;ans.front()&lt;=10) &#123; if(vis[q.front()]==1) &#123; q.pop(); ans.pop(); continue; &#125; vis[q.front()]=1; string now,noww; int num; for(int i=1; i&lt;=cnt; i++) &#123; now=q.front(); while(1) &#123; num=now.find(a[i]); if(num==-1) break; noww=q.front(); noww.replace(num,a[i].length(),b[i]); q.push(noww); ans.push(ans.front()+1); now[num]='&amp;'; &#125; &#125; q.pop(); ans.pop(); &#125; if(q.empty()||ans.front()&gt;10) &#123; printf(\"NO ANSWER!\"); return ; &#125; printf(\"%d\",ans.front()); &#125;&#125;;int main() &#123; Dy::AKNOIP(); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"https://dyrisingsunlight.github.io/tags/bfs/"}]},{"title":"让我们异或吧","slug":"RangWoMenYiHuoBa","date":"2019-07-12T16:00:00.000Z","updated":"2019-08-01T14:17:01.384Z","comments":true,"path":"2019/07/13/RangWoMenYiHuoBa/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/13/RangWoMenYiHuoBa/","excerpt":"Problem’s Website 让我们异或吧","text":"Problem’s Website 让我们异或吧 Solution 做这道题的前置知识： 异或（^），位运算的一种，规则为两个数对位异或，相同为0，不同为1，即0^1=1,1^1=0,0^0=0,1^0=1 异或满足交换律：a^b = b^a 异或满足结合律：(a^b)^c = a^(b^c) 异或自己为0：a^a = 0 异或0不变：a^0 = a 知道了这些，我们再来分析这道题，要求两点路径上权值的异或值，我们可以预处理一个数组，Dis[i]表示从根到i上路径的异或值，对于两个点，答案即为Dis[u]^Dis[v]，Dis[u]和Dis[v]中相同的部分(即根节点到他们的LCA)异或两次会变成0，所以这样是正确的。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 100010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct TREE &#123; int next,to,dis;&#125;edge[Maxn*2];int n,cnt,m;int head[Maxn*2],deep[Maxn],Dis[Maxn];namespace DY &#123; void ADD(int from,int to,int dis) &#123; edge[++cnt].next=head[from]; edge[cnt].to=to; edge[cnt].dis=dis; head[from]=cnt; &#125; void D_F(int now) &#123; for(int i=head[now]; i; i=edge[i].next) &#123; int to=edge[i].to; if(!deep[to]) &#123; deep[to]=deep[now]+1; Dis[to]=Dis[now]^edge[i].dis; D_F(to); &#125; &#125; &#125; void main() &#123; scanf(\"%d\",&amp;n); for(int i=1; i&lt;n; i++) &#123; int u,v,num; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;num); ADD(u,v,num); ADD(v,u,num); &#125; deep[1]=1; D_F(1); scanf(\"%d\",&amp;m); while(m--) &#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); printf(\"%d\\n\",Dis[u]^Dis[v]); &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"}]},{"title":"小白逛公园","slug":"XiaoBaiGuangGongYuan","date":"2019-07-11T16:00:00.000Z","updated":"2019-08-01T14:18:58.283Z","comments":true,"path":"2019/07/12/XiaoBaiGuangGongYuan/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/12/XiaoBaiGuangGongYuan/","excerpt":"Peoblem’s Website 小白逛公园","text":"Peoblem’s Website 小白逛公园 Solution 通过读题，我们不难得出要求一段序列的最大子段和，并且还要支持单点修改，那么线段树无疑是最佳的做法。 基础的单点修改就不说了，说一下要维护的标记以及标记上传。 v表示当前区间的和 maxl表示当前区间必须包含最左端的数的最大子段和 maxr表示当前区间必须包含最右端的数的最大子段和 maxv表示整段区间的最大子段和 对于pushup，v直接把左右儿子的v加起来，maxl则是要对左儿子的v+右儿子的maxl取max，同理，maxr要对右儿子的v+左儿子的maxr取max,maxv要对左儿子和右儿子的maxv以及左儿子的maxr与右儿子的maxl之和取最大值，可能说的有点乱，但还是比较好理解的。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;const int Maxn = 500010;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;struct TREE &#123; int v, maxl, maxr, maxv;&#125;tree[Maxn &lt;&lt; 2];int n, m;int a[Maxn];void pushup(int k, int l, int r) &#123; tree[k].v = tree[l].v + tree[r].v; tree[k].maxl = max(tree[l].maxl, tree[l].v + tree[r].maxl); tree[k].maxr = max(tree[r].maxr, tree[r].v + tree[l].maxr); tree[k].maxv = max(max(tree[l].maxv, tree[r].maxv), tree[l].maxr + tree[r].maxl);// cout &lt;&lt; tree[k].maxv &lt;&lt; endl;&#125;void build(int k, int l, int r) &#123; if(l == r) &#123; tree[k].v = tree[k].maxl = tree[k].maxr = tree[k].maxv = a[l]; return ; &#125; int mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); pushup(k, k &lt;&lt; 1, k &lt;&lt; 1 | 1);&#125;void modify(int k, int l, int r, int id, int num) &#123;// cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; if(l == r) &#123; tree[k].v = tree[k].maxl = tree[k].maxr = tree[k].maxv = num; return ; &#125; int mid = l + r &gt;&gt; 1; if(id &lt;= mid) modify(k &lt;&lt; 1, l, mid, id, num); else modify(k &lt;&lt; 1 | 1, mid + 1, r, id, num); pushup(k, k &lt;&lt; 1, k &lt;&lt; 1 | 1);&#125;TREE query(int k,int l, int r, int x, int y) &#123;// cerr &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; if(x &lt;= l &amp;&amp; y &gt;= r) return tree[k]; int mid = l + r &gt;&gt; 1; if(y &lt;= mid) return query(k &lt;&lt; 1, l, mid, x, y); else if(x &gt; mid) return query(k &lt;&lt; 1 | 1, mid + 1, r, x, y); else &#123; TREE d, d1 = query(k &lt;&lt; 1, l, mid, x, y), d2 = query(k &lt;&lt; 1 | 1, mid + 1, r, x, y);// cout &lt;&lt; d1.v &lt;&lt; \" \" &lt;&lt; d1.maxl &lt;&lt; \" \" &lt;&lt; d1.maxr &lt;&lt; \" \" &lt;&lt; d1.maxv &lt;&lt; endl; d.maxl = max(d1.maxl, d1.v + d2.maxl); d.maxr = max(d2.maxr, d2.v + d1.maxr); d.maxv = max(max(d1.maxv, d2.maxv), d1.maxr + d2.maxl);// cout &lt;&lt; d1.maxv &lt;&lt; endl; return d; &#125;&#125;int main() &#123; n = sc(); m = sc(); for(int i = 1; i &lt;= n; i++) a[i] = sc(); build(1, 1, n); while(m--) &#123; int flag = sc(); if(flag == 1) &#123; int x = sc(), y = sc(); if(x &gt; y) swap(x, y); printf(\"%d\\n\", query(1, 1, n, x, y).maxv); &#125; else &#123; int x = sc(), num = sc(); modify(1, 1, n, x, num); &#125; &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"}]},{"title":"货车运输","slug":"HuoCheYunShu","date":"2019-07-10T16:00:00.000Z","updated":"2019-08-01T14:15:28.878Z","comments":true,"path":"2019/07/11/HuoCheYunShu/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/11/HuoCheYunShu/","excerpt":"Problem’s Website 货车运输","text":"Problem’s Website 货车运输 Solution 对于这道题目，重点是建模，我们可以把每条道路的载重看成道路的边权，因为要求载重最大，我们可以对图搞一个最大生成树，然后对于两个点u,v,其两点的最短路径中的最大边权即为最大载重，最短路径肯定是两点的LCA。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 10010#define Maxm 50010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct EDGE &#123; int u,v,dis; bool operator &lt; (const EDGE &amp;x) const &#123; return dis&gt;x.dis; &#125;&#125;a[Maxm];struct TREE &#123; int next,to,dis;&#125;edge[Maxn*2];int n,m,cnt,q;int father[Maxn],head[Maxn*2],deep[Maxn];bool vis[Maxn];int f[Maxn][21],Dis[Maxn][21];namespace DY &#123; void ADD(int from,int to,int dis) &#123; edge[++cnt].next=head[from]; edge[cnt].to=to; edge[cnt].dis=dis; head[from]=cnt; &#125; void D_F(int son,int fa) &#123; vis[son]=1; deep[son]=deep[fa]+1; for(int i=1; i&lt;=20; i++) &#123; f[son][i]=f[f[son][i-1]][i-1]; Dis[son][i]=min(Dis[son][i-1],Dis[f[son][i-1]][i-1]); &#125; for(int i=head[son]; i; i=edge[i].next) &#123; int to=edge[i].to; if(to==fa||vis[to]) continue;// deep[to]=deep[son]+1; f[to][0]=son; Dis[to][0]=edge[i].dis; D_F(to,son); &#125; &#125; int find(int x) &#123; return x==father[x]? x: father[x]=find(father[x]); &#125; int LCA(int x,int y) &#123; if(find(x)!=find(y)) return -1; int res=0x7fffffff/3; if(deep[x]&lt;deep[y]) swap(x,y); for(int i=20; i&gt;=0; i--) &#123; if(deep[f[x][i]]&gt;=deep[y]) &#123; res=min(res,Dis[x][i]); x=f[x][i]; &#125; &#125; if(x==y) return res; for(int i=20; i&gt;=0; i--) &#123; if(f[x][i]!=f[y][i]) &#123; res=min(res,min(Dis[x][i],Dis[y][i])); x=f[x][i]; y=f[y][i]; &#125; &#125; return min(res,min(Dis[x][0],Dis[y][0])); &#125; void main() &#123; n=sc(); m=sc(); for(int i=1; i&lt;=m; i++) a[i].u=sc(),a[i].v=sc(),a[i].dis=sc(); sort(a+1,a+1+m); for(int i=1; i&lt;=n; i++) father[i]=i; for(int i=1; i&lt;=m; i++) &#123; int aa=find(a[i].u); int bb=find(a[i].v); if(aa!=bb) &#123;// num+=a[i].dis; father[aa]=bb; ADD(a[i].u,a[i].v,a[i].dis); ADD(a[i].v,a[i].u,a[i].dis); &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; if(!vis[i]) &#123;// deep[i]=1; D_F(i,0);// f[1][0]=1; Dis[i][0]=0x7fffffff/3; &#125; &#125; q=sc(); while(q--) &#123; int u=sc(),v=sc(); printf(\"%d\\n\",LCA(u,v)); &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"}]},{"title":"统计单词个数","slug":"TongJiDanCiGeShu","date":"2019-07-08T16:00:00.000Z","updated":"2019-08-01T14:18:55.578Z","comments":true,"path":"2019/07/09/TongJiDanCiGeShu/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/09/TongJiDanCiGeShu/","excerpt":"Problem’s Website 统计单词个数","text":"Problem’s Website 统计单词个数 Solution 这是一道关于字符串和dp的题目 首先要把题意读明白，下面是样例解释 12345678this/isabookyoua/reaoh1:is(this)2:is(isabookyoua)3:sab(isabookyoua)4:a(isabookyoua)5:ok(isabookyoua)6:a(isabookyoua)7:a(reaoh) 题意搞懂后，我们来想正解，本题的状态不难想出，设f[i][j]为长度为i的字符串分成j块包含的单词个数，答案为f[len][k]，经过思考，发现状态转移只有一个f数组还不够，于是我们再维护一个sum数组，sum[i][j]表示从i到j的单词个数，维护这个数组需要用到STL：string类型的find()函数和substr()函数，不懂的可以点击对应名称进行学习。状态转移比较好理解，枚举字符串长度和分割的块数，然后枚举断点，方程为 1f[i][j] = max(f[i][j], f[l][j - 1] + sum[l + 1][i]; Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;string s;int n, k, m, len;int f[210][50], sum[210][210];string a[10];bool check(int l, int r) &#123; string x = s.substr(l, r - l + 1); for(int i = 1; i &lt;= m; i++) if(x.find(a[i]) == 0) return true; return false;&#125;int main() &#123; n = sc(); k = sc(); s += '~'; for(int i = 1; i &lt;= n; i++) &#123; string ch; cin &gt;&gt; ch; s += ch; &#125; len = s.size() - 1; m = sc(); for(int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i]; for(int i = len; i &gt;= 1; i--) &#123; for(int j = i; j &gt;= 1; j--) &#123; sum[j][i] = sum[j + 1][i]; if(check(j, i)) sum[j][i]++; &#125; &#125; for(int i = 1; i &lt;= k; i++) f[i][i] = f[i - 1][i - 1] + sum[i][i]; for(int i = 1; i &lt;= len; i++) f[i][1] = sum[1][i]; for(int i = 1; i &lt;= len; i++) &#123; for(int j = 1; j &lt; i &amp;&amp; j &lt;= k; j++) for(int l = j; l &lt; i; l++) f[i][j] = max(f[i][j], f[l][j - 1] + sum[l + 1][i]); &#125; printf(\"%d\\n\", f[len][k]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"异象石","slug":"YiXiangShi","date":"2019-07-08T16:00:00.000Z","updated":"2019-08-01T14:19:10.540Z","comments":true,"path":"2019/07/09/YiXiangShi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/09/YiXiangShi/","excerpt":"Problem’s Website 异象石","text":"Problem’s Website 异象石 Solution 首先我们可以得出这是一颗树，我们可以用一些关于树的基本操作，比如我们可以求出节点的dfs序，根据dfs序升序排序，把异象石的节点首尾相连，累加相邻节点的路径长度，得到的结果正好是答案的两倍，可以画图观察一下。 那么我们可以用set来维护dfs序，用LCA来计算路径长度，就可以把这道题A掉。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define gc getchar()#define ll long long#define Int set &lt;int&gt; :: iteratorusing namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;struct TREE &#123; int next, to, dis;&#125;tree[100010 &lt;&lt; 1];int n, cnt, m, id;int f[100010][21], df[100010], rdf[100010], deep[100010];ll d[100010][21]; ll ans;set &lt;int&gt; s;int head[100010 &lt;&lt; 1];void ADD(int from, int to, int dis) &#123; tree[++cnt].next = head[from]; tree[cnt].to = to; tree[cnt].dis = dis; head[from] = cnt;&#125;void D_F(int son, int fa) &#123; for(int i = 0; i &lt;= 19; i++) &#123; f[son][i + 1] = f[f[son][i]][i]; d[son][i + 1] = d[son][i] + d[f[son][i]][i]; &#125; for(int i = head[son]; i; i = tree[i].next) &#123; int to = tree[i].to, dis = tree[i].dis; if(to == fa) continue; f[to][0] = son; d[to][0] = dis; deep[to] = deep[son] + 1; D_F(to, son); &#125;&#125;ll LCA(int x, int y) &#123; ll res = 0; if(deep[x] &gt; deep[y]) swap(x, y); ll de = deep[y] - deep[x]; for(int i = 0; i &lt;= 20; i++) if(de &amp; (1 &lt;&lt; i)) res += d[y][i], y = f[y][i]; if(x == y) return res; for(int i = 20; i &gt;= 0; i--) &#123; if(f[x][i] != f[y][i]) &#123; res += d[x][i] + d[y][i]; x = f[x][i]; y = f[y][i]; &#125; &#125; return res + d[x][0] + d[y][0];&#125;void dfs(int now) &#123; df[now] = ++id; rdf[id] = now; for(int i = head[now]; i; i = tree[i].next) &#123; int to = tree[i].to; if(!df[to]) dfs(to); &#125;&#125;Int L(Int now) &#123; if(now == s.begin()) return --s.end(); return --now;&#125;Int R(Int now) &#123; if(now == --s.end()) return s.begin(); return ++now;&#125;int main() &#123; n = sc(); for(int i = 1; i &lt; n; i++) &#123; int x = sc(), y = sc(), z = sc(); ADD(x, y, z); ADD(y, x, z); &#125; D_F(1, 0); dfs(1); m = sc(); while(m--) &#123; char c[2]; cin &gt;&gt; c[0]; if(c[0] == '?') &#123; printf(\"%lld\\n\", (ans &gt;&gt; 1)); &#125; else if(c[0] == '+') &#123; int ID = sc(); Int now; if(s.size()) &#123; now = s.lower_bound(df[ID]); if(now == s.end()) now = s.begin(); int first = *L(now); ans += LCA(ID, rdf[first]) + LCA(ID, rdf[*now]) - LCA(rdf[first], rdf[*now]); &#125; s.insert(df[ID]); &#125; else if(c[0] == '-') &#123; int ID = sc(); Int now = s.find(df[ID]); int first = *L(now); now = R(now); ans -= LCA(ID, rdf[first]) + LCA(ID, rdf[*now]) - LCA(rdf[first], rdf[*now]); s.erase(df[ID]); &#125; &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"}]},{"title":"垃圾陷阱","slug":"LaJiXianJing","date":"2019-07-07T16:00:00.000Z","updated":"2019-08-01T14:15:42.260Z","comments":true,"path":"2019/07/08/LaJiXianJing/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/08/LaJiXianJing/","excerpt":"Problems Website 垃圾陷阱","text":"Problems Website 垃圾陷阱 Solution 一道背包题目，可以用二维解，但有一种比较神奇的状态，我们设f[i]为高度i时卡门的生命，这样就变成了一个01背包，决策无疑只有吃垃圾或垫垃圾。Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;struct node &#123; int t, l, h; bool operator &lt; (const node &amp;x) const &#123; return t &lt; x.t; &#125;&#125;a[110];int d, g;int f[110]; //f[high] = lifeint main() &#123; d = sc(); g = sc(); for(int i = 1; i &lt;= g; i++) &#123; a[i].t = sc(); a[i].l = sc(); a[i].h = sc(); &#125; sort(a + 1, a + 1 + g); memset(f, -1, sizeof(f)); f[0] = 10; for(int i = 1; i &lt;= g; i++) &#123; for(int j = d; j &gt;=0; j--) &#123; if(f[j] &gt;= a[i].t) &#123; if(j + a[i].h &gt;= d) &#123; printf(\"%d\\n\", a[i].t); return 0; &#125; f[j + a[i].h] = max(f[j], f[j + a[i].h]); f[j] += a[i].l; &#125; &#125; &#125; printf(\"%d\\n\", f[0]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"HH的项链","slug":"HHDeXiangLian","date":"2019-07-07T16:00:00.000Z","updated":"2019-08-01T14:15:11.970Z","comments":true,"path":"2019/07/08/HHDeXiangLian/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/08/HHDeXiangLian/","excerpt":"Problem’s Website [SDOI2009]HH的项链","text":"Problem’s Website [SDOI2009]HH的项链 Solution 首先这道题模拟是不可能AC的。 其次这道题可以用莫队AC，但我不会。 我们来说一下比较大众化的做法，离线处理+树状数组，我们可以先按照询问区间的右端点升序排序，然后用一个数组存一个元素在一个区间中出现的位置，用树状数组记录区间内的元素个数。Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;struct node &#123; int l, r, id; bool operator &lt; (const node &amp;x) const &#123; return r &lt; x.r; &#125;&#125;b[500010];int n, m;int a[500010], ans[500010], tree[1000010], place[1000010];int lowbit(int x) &#123; return x &amp; (-x);&#125;void update(int id, int num) &#123; while(id &lt;= n) &#123; tree[id] += num; id += lowbit(id); &#125;&#125;int query(int id) &#123; int sum = 0; while(id &gt; 0) &#123; sum += tree[id]; id -= lowbit(id); &#125; return sum;&#125;int main() &#123; n = sc(); for(int i = 1; i &lt;= n; i++) a[i] = sc(); m = sc(); for(int i = 1; i &lt;= m; i++) &#123; b[i].l = sc(); b[i].r = sc(); b[i].id = i; &#125; sort(b + 1, b + 1 + m); int next = 1; for(int i = 1; i &lt;= m; i++) &#123; for(int j = next; j &lt;= b[i].r; j++) &#123; if(place[a[j]]) update(place[a[j]], -1); update(j, 1); place[a[j]] = j; &#125; next = b[i].r + 1; ans[b[i].id] = query(b[i].r) - query(b[i].l - 1); &#125; for(int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://dyrisingsunlight.github.io/tags/树状数组/"}]},{"title":"玛丽卡","slug":"MaLiKa","date":"2019-07-06T16:00:00.000Z","updated":"2019-08-01T14:15:57.388Z","comments":true,"path":"2019/07/07/MaLiKa/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/07/MaLiKa/","excerpt":"Problem’s Website 玛丽卡","text":"Problem’s Website 玛丽卡 Solution 这道题的题意可能不太好懂，大体意思是切掉一张图中的一条边，使从1到n的最短路最长，输出长度。 因为在很多比赛中，SPFA会被卡，保险起见，这道题我们用堆优化的Dijkstra，我们先跑一遍Dij，记录一下路径，然后分别切断，跑Dij，求出最大时间，即为答案，注意一点，这道题我们用链式前向星要多记录一个from,为一条边的出发点，方便切边。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define gc getchar()#define INF 0x7fffffff / 3using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;struct node &#123; int next, to, from, dis;&#125;edge[499510 &lt;&lt; 1];struct heap &#123; int id, num; bool operator &lt; (const heap &amp;x) const &#123; return num &gt; x.num; &#125;&#125;;int n, m, cnt, ans;int head[499510], dis[1010], pre[1010];bool vis[1010];priority_queue &lt;heap&gt; q;void ADD(int from, int to, int dis) &#123; edge[++cnt].next = head[from]; edge[cnt].from = from; edge[cnt].to = to; edge[cnt].dis = dis; head[from] = cnt;&#125;void Dijkstra(bool pd) &#123; memset(dis, 0x7f, sizeof(dis)); memset(vis, 0, sizeof(vis)); while(!q.empty()) q.pop(); dis[1] = 0; q.push((heap)&#123;1, 0&#125;); while(!q.empty()) &#123; heap now = q.top(); q.pop(); if(vis[now.id]) continue; vis[now.id] = true; for(int i = head[now.id]; i; i = edge[i].next) &#123; int to = edge[i].to; if(dis[to] &gt; dis[now.id] + edge[i].dis) &#123; dis[to] = dis[now.id] + edge[i].dis; if(pd) pre[to] = i; if(!vis[to]) q.push((heap)&#123;to, dis[to]&#125;); &#125; &#125; &#125;&#125;int main() &#123; n = sc(); m = sc(); for(int i = 1; i &lt;= m; i++) &#123; int x = sc(), y = sc(), z = sc(); ADD(x, y, z); ADD(y, x, z); &#125; Dijkstra(true); int now = n; while(now != 1) &#123; int la = edge[pre[now]].dis; edge[pre[now]].dis = INF; Dijkstra(false); ans = max(ans, dis[n]); edge[pre[now]].dis = la; now = edge[pre[now]].from; &#125; printf(\"%d\\n\", ans); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://dyrisingsunlight.github.io/tags/最短路/"}]},{"title":"创意吃鱼法","slug":"ChungYiChiYuFa","date":"2019-07-06T16:00:00.000Z","updated":"2019-08-01T14:13:16.663Z","comments":true,"path":"2019/07/07/ChungYiChiYuFa/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/07/ChungYiChiYuFa/","excerpt":"Problem’s Website 创意吃鱼法","text":"Problem’s Website 创意吃鱼法 Solution 这道题类似于[USACO5.3]巨大的牛棚Big Barn，这道题要求出子矩阵中1组成的最长的对角线长度，我们回想一下巨大的牛棚是如何AC的，那道题我们设f[i][j]为以i,j为右下角的最大正方形边长，状态转移方程为 12if(!Map[i][j]) f[i][j] = min(f[i - 1][j - 1], min(f[i - 1][j], f[i][j - 1])); 这道题我们可以设f[i][j]为以i,j为右下角的正方形1组成最大对角线的长度，对于f[i][j]，我们肯定要和f[i - 1][j - 1]比较，同时，既然是1组成的对角线，我们可以记录两个数组分别存从i,j向上下、左右一直为0的长度，我们就可以与这两个数组相比，状态转移方程为 12if(Map[i][j]) f[i][j] = min(f[i - 1][j - 1], min(s1[i][j - 1], s2[i - 1][j])); 当然这道题遍历两遍，一遍从左上角到右下角，一遍从右上角到左下角，状态转移方程稍有不同，请读者自行查看Code Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, m, ans;int Map[2510][2510], f[2510][2510], s1[2510][2510], s2[2510][2510];int main() &#123; n = sc(); m = sc(); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) &#123; Map[i][j] = sc(); if(!Map[i][j]) &#123; s1[i][j] = s1[i][j - 1] + 1; s2[i][j] = s2[i - 1][j] + 1; &#125; if(Map[i][j]) f[i][j] = min(f[i - 1][j - 1], min(s2[i - 1][j], s1[i][j - 1])) + 1; ans = max(ans, f[i][j]); &#125; &#125; memset(s1, 0, sizeof(s1)); memset(s2, 0, sizeof(s2)); memset(f, 0, sizeof(f)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = m; j &gt;= 1; j--) &#123; if(!Map[i][j])&#123; s1[i][j] = s1[i][j + 1] + 1; s2[i][j] = s2[i - 1][j] + 1; &#125; if(Map[i][j]) f[i][j] = min(f[i - 1][j + 1], min(s1[i][j + 1], s2[i - 1][j])) + 1; ans = max(ans, f[i][j]); &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125; rp++\\","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"单调栈","slug":"DanDiaoZhan","date":"2019-07-06T16:00:00.000Z","updated":"2019-08-01T14:13:25.088Z","comments":true,"path":"2019/07/07/DanDiaoZhan/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/07/DanDiaoZhan/","excerpt":"Problem’s Website Largest Rectangle in a Histogram City Game","text":"Problem’s Website Largest Rectangle in a Histogram City Game Solution 这两道题都是关于单调栈，通俗来说，就是一个具有单调性的栈（如果栈都不会，请点击这）。 关于T1的解法，请见下图（摘自王婷婷-STL&amp;基础数据结构2019.1.26） T2其实是T1的拓展，是一个二维的单调栈，根据数据范围，θ(n^2)可以AC，于是我们可以第一次枚举第1行，第二次枚举第1-2行，第i次枚举第1-i行，一样的单调栈处理，要注意如果当前第i行第j个位置为’R’，要把表示高度的数组a[j]清零。Code T1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define gc getchar()#define ll long longusing namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n;stack &lt;int&gt; qx;stack &lt;int&gt; qy;ll ans;int a[100010]; int main() &#123; while(true) &#123; ans = 0; while(!qx.empty()) &#123; qx.pop(); qy.pop(); &#125; n = sc(); if(!n) break; for(int i = 1; i &lt;= n; i++) a[i] = sc(); a[n + 1] = 0; for(int i = 1; i &lt;= n + 1; i++) &#123; if(!qx.empty() &amp;&amp; qx.top() &lt; a[i]) &#123; qx.push(a[i]); qy.push(1); &#125; else &#123; int wide = 0; while(!qx.empty() &amp;&amp; qx.top() &gt; a[i]) &#123; wide += qy.top(); ans = max(ans, (ll)wide * qx.top()); qx.pop(); qy.pop(); &#125; qx.push(a[i]); qy.push(wide + 1); &#125; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125; T2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, m, ans;int sum[1010][1010];int a[1010];stack &lt;int&gt; qx;stack &lt;int&gt; qy;int main() &#123; n = sc(); m = sc(); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; char c[2]; int x = 0; cin &gt;&gt; c[0]; if(c[0] == 'F') x = 1; sum[i][j] = x; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) a[j] = sum[i][j] ? a[j] + 1 : 0; while(!qx.empty()) &#123; qx.pop(); qy.pop(); &#125; for(int j = 1; j &lt;= m + 1; j++) &#123; if(!qx.empty() &amp;&amp; a[j] &gt; qx.top()) &#123; qx.push(a[j]); qy.push(1); &#125; else &#123; int wide = 0; while(!qx.empty() &amp;&amp; qx.top() &gt; a[j]) &#123; wide += qy.top(); ans = max(ans, wide * qx.top()); qx.pop(); qy.pop(); &#125; qx.push(a[j]); qy.push(wide + 1); &#125; &#125; &#125; printf(\"%d\\n\", 3 * ans); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://dyrisingsunlight.github.io/tags/栈/"}]},{"title":"棋盘制作","slug":"QiPanZhiZuo","date":"2019-07-06T16:00:00.000Z","updated":"2019-08-01T14:16:53.057Z","comments":true,"path":"2019/07/07/QiPanZhiZuo/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/07/QiPanZhiZuo/","excerpt":"Problem’s Website [ZJOI2007]棋盘制作","text":"Problem’s Website [ZJOI2007]棋盘制作 Solution 又是一个求最大矩阵和正方形的问题，方法还是dp，有个专有名词——悬线法，最普通的状态转移方程为 1f[i][j] = min(f[i - 1][j - 1], min(f[i - 1][j], f[i][j - 1])); 而这道题要满足是一个棋盘，我们可以设Left[i][j]为i，j能到达的最左位置，Right[i][j]为i,j能到达的最右位置，up[i][j]为i,j能向上延伸的最大长度，状态转移方程为 12Left[i][j] = max(Left[i][j], Left[i - 1][j]);Right[i][j] = min(Right[i][j], Rigth[i - 1][j]); 具体解释见代码。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, m, ans1, ans2;int Left[2010][2010], Right[2010][2010], up[2010][2010], Map[2010][2010];int main() &#123; n = sc(); m = sc(); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; Map[i][j] = sc(); Left[i][j] = Right[i][j] = j; // 先初始化为当前位置 up[i][j] = 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) //从左向右更新 for(int j = 2; j &lt;= m; j++) if(Map[i][j] != Map[i][j - 1]) //符合棋盘的规定 Left[i][j] = Left[i][j - 1]; for(int i = 1; i &lt;= n; i++) //从右向左更新 for(int j = m - 1; j &gt;= 1; j--) if(Map[i][j] != Map[i][j + 1]) Right[i][j] = Right[i][j + 1]; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(i &gt; 1 &amp;&amp; Map[i][j] != Map[i - 1][j]) &#123; //状态转移 Left[i][j] = max(Left[i][j], Left[i - 1][j]); //求出向左延伸位置的最右边 Right[i][j] = min(Right[i][j], Right[i - 1][j]); //向右延伸位置的最左边 up[i][j] = up[i - 1][j] + 1; &#125; int a = Right[i][j] - Left[i][j] + 1; int b = min(a, up[i][j]); ans1 = max(ans1, b * b); //最大正方形面积 ans2 = max(ans2, a * up[i][j]); //最大矩形面积 &#125; &#125; printf(\"%d\\n%d\\n\", ans1, ans2); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"多米诺骨牌","slug":"DuoMiNuoGuPai","date":"2019-07-05T16:00:00.000Z","updated":"2019-08-01T14:13:31.061Z","comments":true,"path":"2019/07/06/DuoMiNuoGuPai/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/06/DuoMiNuoGuPai/","excerpt":"Problem’s Website 多米诺骨牌","text":"Problem’s Website 多米诺骨牌 Solution 这道题可以看做一个线性dp，也可以看做背包问题，根据题意，我们发现一张牌转两次及以上是没有意义的，那么我们可以设f[i][j]表示到第i个数上下点数之差为j的旋转次数，对于i和i+1，状态转移方程为 1f[i][j] = min(f[i - 1][j - a[i]),f[i - 1][j + a[i]] + 1); a[i]为上下一张牌上下点数之差，为了防止数组下标出现负数，我们把每个j加上一个num，最后通过枚举找到差值最小的f[i][j],记录最小转动次数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define num 5000using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, ans;int a[1010], f[1010][10010];int main() &#123; n = sc(); for(int i = 1; i &lt;= n; i++) &#123; int x = sc(), y = sc(); a[i] = x - y; &#125; memset(f, 0x7f, sizeof(f)); f[0][0 + num] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = -5000 ; j &lt;= 5000; j++) &#123; f[i][j + num] = min(f[i - 1][j + num - a[i]], f[i - 1][j + num + a[i]] + 1); &#125; &#125; for(int i = 0; i &lt;= 5000; i++) &#123; ans = min(f[n][i + num], f[n][num - i]); if(ans &lt;= 1000) &#123; printf(\"%d\\n\", ans); return 0; &#125; &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"紧急集合|聚会","slug":"JuHui","date":"2019-07-05T16:00:00.000Z","updated":"2019-08-01T14:15:32.789Z","comments":true,"path":"2019/07/06/JuHui/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/06/JuHui/","excerpt":"Problem’s Website 紧急集合 / 聚会","text":"Problem’s Website 紧急集合 / 聚会 Solution 这是一道求树上三点的最短距离题，我们知道，树上两点的最短距离为两点到两点的LCA的距离之和，那么三个点的最短距离如何求呢？ 肯定也和LCA有关，假设我们现在有a,b,c三个点，aa = LCA(a, b),bb = LCA(b, c),cc = LCA(c, a),结论是：aa,bb,cc中不同与其他两点的点为最短路径的必经之点，至于证明，本蒟蒻不太会，胡乱证明一下，见下图：Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 500010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct TREE &#123; int next,to;&#125;edge[Maxn*2];int cnt,n,m;int head[Maxn*2],deep[Maxn];int f[Maxn][21];namespace DY &#123; void ADD(int from,int to) &#123; edge[++cnt].next=head[from]; edge[cnt].to=to; head[from]=cnt; &#125; void D_F(int son,int fa) &#123; deep[son]=deep[fa]+1; for(int i=1; i&lt;=19; i++) f[son][i]=f[f[son][i-1]][i-1]; for(int i=head[son]; i; i=edge[i].next) &#123; int to=edge[i].to; if(to==fa) continue; f[to][0]=son; D_F(to,son); &#125; &#125; int LCA(int x,int y) &#123; if(deep[x]&lt;deep[y]) swap(x,y); for(int i=20; i&gt;=0; i--) &#123; if(deep[f[x][i]]&gt;=deep[y]) x=f[x][i]; if(x==y) return x; &#125; for(int i=20; i&gt;=0; i--) &#123; if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; &#125; return f[x][0]; &#125; void main() &#123; n=sc(); m=sc(); for(int i=1; i&lt;n; i++) &#123; int u=sc(),v=sc(); ADD(u,v); ADD(v,u); &#125; D_F(1,0); while(m--) &#123; int aa=sc(),bb=sc(),cc=sc(),d1; int a1=LCA(aa,bb); int b1=LCA(aa,cc); int c1=LCA(bb,cc); if(a1==b1) d1=c1; else if(a1==c1) d1=b1; else if(b1==c1) d1=a1; int res=deep[aa]+deep[bb]+deep[cc]-deep[a1]-deep[b1]-deep[c1]; printf(\"%d %d\\n\",d1,res); &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"}]},{"title":"回文切割","slug":"HuiWenQieGe","date":"2019-07-04T16:00:00.000Z","updated":"2019-08-01T14:15:26.291Z","comments":true,"path":"2019/07/05/HuiWenQieGe/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/05/HuiWenQieGe/","excerpt":"Problem’s Website 切割回文","text":"Problem’s Website 切割回文 Solution 区间dp，我们设f[i]为到第i位需要切割的次数，答案为f[strlen(ss)],我们需要预处理一下，对于判断回文串，最好的方法就是马拉车算法，不懂得可以见我的另一篇题解马拉车算法， 我们首先枚举右端点i，在枚举左端点j，判断一下j-i是否为回文串，如果是，则进行转移，但要注意，我们这样转移会使方案数多1所以最后要-1。Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int t, len = 1, mid, r;int p[1010 &lt;&lt; 1], f[1010 &lt;&lt; 1];char ss[1010], s[1010 &lt;&lt; 1];bool check(int ll, int rr) &#123; if((((p[ll + rr] &lt;&lt; 1) - 1) &gt;&gt; 1) &gt;= rr - ll + 1) return true; return false;&#125;int main() &#123; t = sc(); while(t--) &#123; len = 1; mid = r = 0; memset(f, 0x7f, sizeof(f)); memset(p, 0, sizeof(p)); f[0] = 0; scanf(\"%s\", ss + 1); s[0] = '|'; s[1] = '|'; for(int i = 1; i &lt;= strlen(ss + 1); i++) &#123; s[++len] = ss[i]; s[++len] = '|'; &#125; for(int i = 1; i &lt;= len; i++) &#123; if(i &lt; r) p[i] = min(r - i, p[(mid &lt;&lt; 1) - i]); else p[i] = 1; while(s[i + p[i]] == s[i - p[i]]) p[i]++; if(p[i] + i &gt; r) r = p[i] + i, mid = i; &#125;// cout &lt;&lt; len &lt;&lt; endl;// for(int i = 1; i &lt;= len; i++)// cout &lt;&lt; p[i] &lt;&lt; \" \"; for(int i = 1; i &lt;= strlen(ss + 1); i++) for(int j = 1; j &lt;= i; j++) if(check(j, i)) f[i] = min(f[i], f[j - 1] + 1); printf(\"%d\\n\", f[strlen(ss + 1)] - 1); &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[]},{"title":"马拉车算法","slug":"manacher","date":"2019-07-04T16:00:00.000Z","updated":"2019-08-01T14:16:03.764Z","comments":true,"path":"2019/07/05/manacher/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/05/manacher/","excerpt":"Problems Website 【模板】manacher算法","text":"Problems Website 【模板】manacher算法 Solution 这道题要判断最大回文串的长度，根据数据范围，朴素算法肯定会超时，于是我们要用到一种新算法，manacher算法（马拉车算法）。 通过观察，我们发现回文串按长度可分为两种，一种为奇数串，一种为偶数串，奇数串的回文中心为一个，而偶数串的回文中心有两个，例如 1234ABCBA奇数串，回文中心为CABCCBA偶数串，回文中心为CC 我们可以将上面的两个串变为 12~|A|B|C|B|A|~|A|B|C|C|B|A| 就可以保证对称中心为一个字符。 下面是一些回文串的性质，内容为转载，来自洛谷 对于一个回文串，有且仅有一个对称中心。且叫它回文对称中心。 在一个回文串内，任选一段区间 X ，一定存在关于”回文对称中心“对称的一个区间，且把这个区间叫做关于区间X的对称区间。 区间和对称区间一定全等。（ 1）(十分显然) 由（1）得 ,若一个区间的对称区间是回文串，这个区间必定是一个回文串。在大的回文串内，它们回文半径相等。 (2)然而我们通过确定关系预先得到的回文半径，它的数值，必定小于等于这个位置真实的回文串半径。（十分显然）以上内容可以帮助理解马拉车算法，也可以解释马拉车算法为何有很优秀的复杂度。 马拉车算法的基本思路：根据(2)，我们只需要记录每个回文串的回文中心以及对应的回文半径，我们设p[i]为以字符i为回文中心的最大回文串的半径，mid为已知回文串中最右侧回文串的回文中心，r为已知回文串中最右侧回文串的最右端，转移过程如下 12345678if i的对称点为j，且mid &lt;= i &lt; r p[i] = min(p[mid*2-i], r-i);//因为(i+j)/2 = mid//移项得//j = 2 * mid - i// r-i为我们已知的范围剩余长度else p[i] = 1; 最后答案即为max(p[i] - 1)，因为p[]存的是回文串的半径。 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;char s[11000010 &lt;&lt; 1];int cnt = 1, r, mid, ans;int p[11000010 &lt;&lt; 1];void sc() &#123; char cch = gc; s[0] = '~'; s[1] = '|'; while(cch &lt; 'a' || cch &gt; 'z') cch = gc; while(cch &gt;= 'a' &amp;&amp; cch &lt;= 'z') &#123; s[++cnt] = cch; s[++cnt] = '|'; cch = gc; &#125;&#125;int main() &#123; sc(); for(int i = 1; i &lt;= cnt; i++) &#123; if(p[i] &lt; r) p[i] = min(r - i, p[(mid &lt;&lt; 1) - i]); else p[i] = 1; while(s[i + p[i]] == s[i - p[i]]) //为了防止下标溢出，我们才在字符串最前面加了'~' p[i]++; if(p[i] + i&gt; r) //更新 r = p[i] + i, mid = i; if(p[i] &gt; ans) ans = p[i] - 1; &#125; printf(\"%d\\n\", ans); return 0;&#125; rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"马拉车","slug":"马拉车","permalink":"https://dyrisingsunlight.github.io/tags/马拉车/"}]},{"title":"数据包的调度机制","slug":"ShuJuBaoDeDiaoDuJiZhi","date":"2019-07-04T16:00:00.000Z","updated":"2019-08-01T14:17:19.924Z","comments":true,"path":"2019/07/05/ShuJuBaoDeDiaoDuJiZhi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/05/ShuJuBaoDeDiaoDuJiZhi/","excerpt":"Problem’s Website 数据包的调度机制","text":"Problem’s Website 数据包的调度机制 Solution 这道题是一道区间dp，状态的设法有很多种，可以设f[i][j]为从i到j的最小延迟值，答案为f[1][n]，状态转移时，我们先枚举区间长度l，再分别枚举左右端点i,j，再枚举i-j之间的点k，方程为 1f[i][j] = min(f[i][j], f[i][k - 1] + f[k + 1][j] + a[k] * (l - 1) + (sum[j] - sum[k]) * (k - i)); 要注意我们枚举的k表示最后一个出栈的是k，那么前面的出栈的顺序为k—i+1,所以我们可以用前缀和来维护。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define INF 0x7fffffff - 1using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int t, n;int f[110][110];int a[110], sum[110];int main() &#123; t = sc(); while(t--) &#123; memset(sum, 0, sizeof(sum)); memset(f, 0, sizeof(f)); n = sc(); for(int i = 1; i &lt;= n; i++) a[i]= sc(), sum[i] = sum[i - 1] + a[i]; for(int l = 1; l &lt;= n; l++) &#123; for(int i = 1; i &lt;= n - l + 1; i++) &#123; int j = i + l - 1; f[i][j] = INF; for(int k = i; k &lt;= j; k++) f[i][j] = min(f[i][j], f[i][k - 1] + f[k + 1][j] + a[k] * (l - 1) + (sum[j] - sum[k]) * (k - i)); &#125; &#125; printf(\"%d\\n\", f[1][n]); &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"乘积最大","slug":"ChengJiZuiDa","date":"2019-07-03T16:00:00.000Z","updated":"2019-08-01T14:13:04.156Z","comments":true,"path":"2019/07/04/ChengJiZuiDa/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/04/ChengJiZuiDa/","excerpt":"Problem’s Website 乘积最大","text":"Problem’s Website 乘积最大 Solution 首先这道题要dp求解，其次根据数据范围，在计算过程中要用高精。 dp：我们设f[i][j]表示第i个数后放第j个乘号的最大值，dp[i]表示最最后一个乘号放在第i位数的最大值。我们首先枚举i，f[i][1]可以直接计算，再从2到k枚举j,枚举i之前的数，进行转移，方程为 123if(f[rei][j - 1].vis) &#123; f[i][j] = Max(f[i][j], GJ(f[rei][j - 1], calc(rei + 1, i));&#125; dp[i]在之后转移，方程为 12if(f[i][j].vis) dp[i] = GJ(f[i][j], calc(i + 1, n)); 高精，具体说是高精乘，本人表示不想解释，因为自己都快忘了。。。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct node &#123; bool vis; int bit; int num[50];&#125;f[50][10], dp[50];int n, k;char s[50];int a[50];node calc(int l, int r) &#123; node aa; aa.bit = r - l + 1; aa.vis = true; for(int i = 1; i &lt;= aa.bit; i++) aa.num[i] = a[r - i + 1]; return aa;&#125;node Max(node a, node b) &#123; if(!a.vis || a.bit &lt; b.bit) return b; if(!b.vis || a.bit &gt; b.bit) return a; for(int i = a.bit; i &gt;= 1; i--) if(a.num[i] &gt; b.num[i]) return a; else if(a.num[i] &lt; b.num[i]) return b;&#125;node GJ(node a, node b) &#123; node aa; aa.vis = true; aa.bit = a.bit + b.bit - 1; for(int i = 1; i &lt;= aa.bit; i++) aa.num[i] = 0; for(int i = 1; i &lt;= a.bit; i++) for(int j = 1; j &lt;= b.bit; j++) aa.num[i + j - 1] += a.num[i] * b.num[j]; int mod = 0; for(int i = 1; i &lt;= aa.bit; i++) &#123; aa.num[i] += mod; mod = aa.num[i] / 10; aa.num[i] %= 10; &#125; while(mod &gt; 0) &#123; aa.num[++aa.bit] = mod % 10; mod /= 10; &#125; return aa;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;k); scanf(\"%s\", s + 1); for(int i = 1; i &lt;= strlen(s + 1); i++) a[i] = s[i] - '0'; for(int i = 1; i &lt;= n; i++) &#123; dp[i].vis = false; for(int j = 1; j &lt;= k; j++) f[i][j].vis = false; &#125; for(int i = 1; i &lt;= n - 1; i++) &#123; f[i][1] = calc(1, i); for(int j = 2; j &lt;= k; j++) &#123; for(int rei = j - 1; rei &lt; i; rei++) &#123; if(f[rei][j - 1].vis) f[i][j] = Max(f[i][j], GJ(f[rei][j - 1], calc(rei + 1, i))); &#125; &#125; if(f[i][k].vis) dp[i] = GJ(f[i][k], calc(i + 1, n)); &#125; node ans; for(int i = 1; i &lt;= n - 1; i++) &#123; node tmp = Max(dp[i], ans); ans = tmp; &#125; for(int i = ans.bit; i &gt;= 1; i--) printf(\"%d\", ans.num[i]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"},{"name":"高精度","slug":"高精度","permalink":"https://dyrisingsunlight.github.io/tags/高精度/"}]},{"title":"模板_最长公共子序列","slug":"LCS","date":"2019-07-03T16:00:00.000Z","updated":"2019-08-01T14:15:46.460Z","comments":true,"path":"2019/07/04/LCS/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/04/LCS/","excerpt":"Problem’s Website 【模板】最长公共子序列","text":"Problem’s Website 【模板】最长公共子序列 Solution P.s. : LIS = Longest Increasing Subsequence，最长上升子序列 LCS = Longest Common Subsequence，最长公共子序列 这道题是LCS问题 首先我们来考虑朴素一点的dp，设f[i][j]为第一个序列到i，第二个序列到j的LCS，答案为f[n][n]，状态转移方程显然得 1234if(a[i - 1] == b[j - 1]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); else f[i][j] = max(f[i][j], max(f[i - 1][j], f[i][j - 1])); 这种方法的时间复杂度为θ(n^2)，对这道题来说，肯定会超时，但可以水过这道题Openjudge_1808:公共子序列 我们再来考虑正解，我们可以用一个数组Map[i]来记录i这个数在a[]中出现的位置，也就是离散化，然后LCS的长度为Map[b[i]]的LIS长度，因为离散化后，a[]数组相当于进行了升序排序，Map[b[i]]即a[i]==b[j]时，a[i]在a[]中的位置，对位置求出LIS，就相当于求出了a[]与b[]的LIS，关于LIS的求法，不会的见下文，这种方法的时间复杂度为θ(nlogn)，可以A掉这道题。 LIS问题 θ(n^2)的求法为设f[i]为到第i为的LIS长度，则基本代码为 12345678 dp[1] = 1;for(int i = 2; i &lt;= n; i++) &#123; dp[i] = 1; for(int j = 1; j &lt;= i; j++) &#123; if(a[i] &gt; a[j] &amp;&amp; dp[j] + 1 &gt; dp[i]) dp[i] = dp[j] + 1; &#125;&#125; 优化。假设我们已经枚举到了i，下一位为j，如果a[j]&gt;a[i]，那么LIS长度可以+1，如果a[j]&lt;a[i]，我们可以二分找到在a[i]之前且刚好比a[j]大的数，用a[j]替换掉，运用人类智慧，显然这样是正确的，代码为 12345678910 for(int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); if(x &gt; a[top]) a[++top] = x; else &#123; int id = upper_bound(a + 1, a + top + 1, x) - a; a[id] = x; &#125;&#125; printf(\"%d\\n\", top); 以上两种求LIS的方法都可以把Openjudge_1759:最长上升子序列水掉 Code1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, top;int a[100010], b[100010], Map[100010], f[100010];int main() &#123; n = sc(); for(int i = 1; i &lt;= n; i++) a[i] = sc(), Map[a[i]] = i; for(int i = 1; i &lt;= n; i++) b[i] = sc(); for(int i = 1; i &lt;= n; i++) &#123; if(f[top] &lt; Map[b[i]]) f[++top] = Map[b[i]]; else &#123; int id = upper_bound(f + 1, f + top + 1, Map[b[i]]) - f; f[id] = Map[b[i]]; &#125; &#125; printf(\"%d\\n\", top); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"跑路","slug":"PaoLu","date":"2019-07-02T16:00:00.000Z","updated":"2019-08-01T14:16:39.770Z","comments":true,"path":"2019/07/03/PaoLu/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/03/PaoLu/","excerpt":"Problem’s Website 跑路","text":"Problem’s Website 跑路 Solution 根据题意，是最短路问题，观察数据范围，我们可以直接使用通俗易懂、儒雅随和的Floyd。 但分析样例，发现这道题并不是简单的Floyd，要尽量使道路为2的次方倍，我们可以维护一个倍增数组f[i][j][k]，表示从i到j走2^k步能否到达，先枚举一遍图，找出可以1s到达的两点，然后再跑Floyd。Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, m;int vis[60][60];bool f[60][60][70];int main() &#123; memset(vis, 0x3f, sizeof(vis)); n = sc(); m = sc(); for(int i = 1; i &lt;= m; i++) &#123; int from = sc(), to = sc(); vis[from][to] = 1; f[from][to][0] = 1; &#125; for(int i = 1; i &lt;= 64; i++) for(int j = 1; j &lt;= n; j++) for(int k = 1; k &lt;= n; k++) for(int l = 1; l &lt;= n; l++) if(f[j][k][i - 1] &amp;&amp; f[k][l][i - 1]) &#123; f[j][l][i] = 1; vis[j][l] = 1; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) for(int k = 1; k &lt;= n; k++) vis[j][k] = min(vis[j][k], vis[j][i] + vis[i][k]); printf(\"%d\\n\", vis[1][n]); return 0;&#125;// dyyyyyyy rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://dyrisingsunlight.github.io/tags/最短路/"},{"name":"倍增","slug":"倍增","permalink":"https://dyrisingsunlight.github.io/tags/倍增/"}]},{"title":"色板游戏","slug":"SeBanYouXi","date":"2019-07-02T16:00:00.000Z","updated":"2019-08-01T14:17:11.179Z","comments":true,"path":"2019/07/03/SeBanYouXi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/03/SeBanYouXi/","excerpt":"Problem’s Website 色板游戏","text":"Problem’s Website 色板游戏 Solution 首先这道题要维护区间内的颜色种类，那么显然要用线段树。 对于30种颜色，我们可以用状压来记录。Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;='9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;struct LST &#123; int data, tag;&#125;lst[100010 &lt;&lt; 2];int n, m, o;void build(int k, int l, int r) &#123; if(l == r) &#123; lst[k].data = (1 &lt;&lt; 1); return ; &#125; int mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); lst[k].data = lst[k &lt;&lt; 1].data | lst[k &lt;&lt; 1 | 1].data;&#125;void pushdown(int k, int l, int r ) &#123; if(lst[k].tag == 0) return ; lst[k &lt;&lt; 1].tag = lst[k &lt;&lt; 1 | 1].tag = lst[k].tag; lst[k &lt;&lt; 1].data = lst[k &lt;&lt; 1 | 1].data = (1 &lt;&lt; lst[k].tag); lst[k].tag = 0;&#125;void modify(int k, int l, int r, int x, int y, int num) &#123; if(l &gt;= x&amp;&amp; r &lt;= y) &#123; lst[k].tag = num; lst[k].data = (1 &lt;&lt; num); return ; &#125; pushdown(k, l, r); int mid = l + r &gt;&gt; 1; if(x &lt;= mid) modify(k &lt;&lt; 1, l, mid, x, y, num); if(y &gt; mid) modify(k &lt;&lt; 1 | 1, mid + 1, r, x, y, num); lst[k].data = lst[k &lt;&lt; 1].data | lst[k &lt;&lt; 1 | 1].data;&#125;int query(int k, int l, int r, int x, int y) &#123; if(l &gt;= x &amp;&amp; r &lt;= y) return lst[k].data; pushdown(k, l, r); int mid = l + r &gt;&gt; 1; int res = 0; if(x &lt;= mid) res |= query(k &lt;&lt; 1, l, mid, x, y); if(y &gt; mid) res |= query(k &lt;&lt; 1 | 1, mid + 1, r, x, y); return res; &#125;int main() &#123;// freopen(\"AK.txt\", \"w\", stdout);/s n = sc(); m = sc(); o = sc(); build(1, 1, n); for(int i = 1; i &lt;= o; i++) &#123; char c[2]; cin &gt;&gt; c[0]; int from = sc(), to = sc(); if(c[0] == 'C') &#123; int num = sc(); if(from &gt; to) swap(from, to); modify(1, 1, n, from, to, num); &#125; else &#123; int ans = 0; if(from &gt; to) swap(from, to); int res = query(1, 1, n, from, to); for(int i = 1; i &lt;= m; i++) if(res &amp; (1 &lt;&lt; i)) ans++; printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"状压","slug":"状压","permalink":"https://dyrisingsunlight.github.io/tags/状压/"},{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"}]},{"title":"Power Strings","slug":"PowerStrings","date":"2019-07-01T16:00:00.000Z","updated":"2019-08-01T14:16:43.068Z","comments":true,"path":"2019/07/02/PowerStrings/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/07/02/PowerStrings/","excerpt":"Problem’s Website Power Strings","text":"Problem’s Website Power Strings Solution 根据kmp算法，一个字符串循环节的长度为len-next[len]，不懂的可以自行模拟一下，那么对于这道题来说，如果有循环节，那么len-next[len] | len，这样我们就可以A掉这道题。Code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define Maxn 1000010using namespace std;char s[Maxn];int next[Maxn];int main() &#123; while(1) &#123; scanf(\"%s\", s + 1); int len = strlen(s + 1); if(len == 1 &amp;&amp; s[1] == '.') break; memset(next, 0,sizeof(next)); int j = 0; for(int i = 2; i &lt;= len; i++) &#123; if(j &gt; 0 &amp;&amp; s[j + 1] != s[i]) j = next[j]; if(s[j + 1] == s[i]) j++; next[i] = j; &#125; if(!(len % (len - next[len]))) printf(\"%d\\n\", len / (len - next[len])); else printf(\"1\\n\"); &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://dyrisingsunlight.github.io/tags/KMP/"}]},{"title":"糖果","slug":"TangGuo","date":"2019-06-29T16:00:00.000Z","updated":"2019-08-01T14:17:43.102Z","comments":true,"path":"2019/06/30/TangGuo/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/30/TangGuo/","excerpt":"Website: 糖果","text":"Website: 糖果 Solution 类似于背包，我们设f[i][j]为第i件物品，取模k为j的最大值，我们不难得出，状态转移为选或不选，不选就是1f[i][j]=f[i-1][j] 选就是1f[i][(f[i-1][j]+a[i])%k]=max(~,f[i-1][j]+a[i]) 为了节省更多空间，我用了滚动数组，对于本题来说，数据较小，可省略。 Code12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define Maxn 110using namespace std;int n, k;int a[Maxn];int f[2][Maxn];int main() &#123; // g++ 糖果.cpp -o 糖果.exe -Wall scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; k; j++) f[i &amp; 1][j] = f[i - 1 &amp; 1][j]; for(int j = 0; j &lt; k; j++) f[i &amp; 1][(f[i - 1 &amp; 1][j] + a[i]) % k] = max(f[i &amp; 1][(f[i - 1 &amp; 1][j] + a[i]) % k], f[i - 1 &amp; 1][j] + a[i]); &#125; printf(\"%d\\n\", f[n &amp; 1][0]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"Mobile Service","slug":"MobileService","date":"2019-06-29T16:00:00.000Z","updated":"2019-08-01T14:16:09.955Z","comments":true,"path":"2019/06/30/MobileService/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/30/MobileService/","excerpt":"题目链接： Mobile Service","text":"题目链接： Mobile Service 题目思路： 这种题一看就是dp题，我们可以设f[i][j][k]为完成第i个命令时，第一个人在j位置，第二个人在k位置时最小花费，动动脑筋，我们不难推出 ，这道题的数据范围告诉我们，尽量要优化空间，相信大家都想到了， 要用滚动数组，对于状态i来说，状态只由i-1转移过来，这样我们可以把f[i][j][k],优化为f[i&amp;1][j][k], i&amp;1相当于i%2，只有1或0出现，这样就可以两者相互转化。代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxl 210#define Maxn 1010#define Maxx 2139062143using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while(cch &lt; '0' || cch &gt; '9') &#123; if(cch == '-') ff = -1; cch = gc; &#125; while(cch &gt;= '0' &amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int l, n;int c[Maxl][Maxl];int p[Maxn];int f[2][Maxl][Maxl];int main() &#123; // g++ \"Mobile Service.cpp\" -o \"Mobile Service.exe\" -Wall l = sc(); n = sc(); for(int i = 1; i &lt;= l; i++) for(int j = 1; j &lt;= l; j++) c[i][j] = sc(); for(int i = 1; i &lt;= n; i++) p[i] = sc(); p[0] = 3; memset(f, 0x7f, sizeof(f)); f[0][1][2] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int x = 1; x &lt;= l; x++) &#123; for(int y = 1; y &lt;= l; y++) &#123; if(f[i - 1 &amp; 1][x][y] != Maxx) &#123; int z = p[i - 1]; if(x != p[i] &amp;&amp; y != p[i]) f[i &amp; 1][x][y] = min(f[i &amp; 1][x][y], f[i - 1 &amp; 1][x][y] + c[z][p[i]]); if(y != p[i] &amp;&amp; z != p[i]) f[i &amp; 1][z][y] = min(f[i &amp; 1][z][y], f[i - 1 &amp; 1][x][y] + c[x][p[i]]); if(x != p[i] &amp;&amp; z != p[i]) f[i &amp; 1][x][z] = min(f[i &amp; 1][x][z], f[i - 1 &amp; 1][x][y] + c[y][p[i]]); f[i - 1 &amp; 1][x][y] = Maxx; &#125; &#125; &#125; &#125; int ans = 0x7fffffff; for(int i = 1; i &lt;= l; i++) for(int j = 1; j &lt;= l; j++) ans = min(ans, f[n &amp; 1][i][j]); printf(\"%d\\n\", ans); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"小Z的笔记/笔记","slug":"XiaoZDBiJi","date":"2019-06-26T16:00:00.000Z","updated":"2019-08-01T14:19:00.565Z","comments":true,"path":"2019/06/27/XiaoZDBiJi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/27/XiaoZDBiJi/","excerpt":"题目链接：小Z的笔记","text":"题目链接：小Z的笔记 题目思路：dp，二维不会想，我们直接来一维，我们用dp[i]来表示第i位最少要擦掉几个字母，对于第j位，假设j和i可以相邻，那么状态转移方程明显为 1dp[i] = min(dp[i], dp[j] - j + i - 1); 也就是说，我们要把j+1 —— i-1删掉，但这样的时间复杂度为θ(n^2)， 只能过30%的数据，我们要对此进行优化。 优化：我们发现，对于每一次状态转移，我们要找的是最小的dp[j]，我们可以用一个数组单独来存最小的的dp[j],我们用数组f[i]表示字母i最小的dp[j]-j，这样时间复杂度就降为了θ(n)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 100010using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, m;bool pd[30][30];char s[Maxn];int f[Maxn], dp[Maxn];int main() &#123;// freopen(\"note.in\", \"r\", stdin);// freopen(\"note.out\", \"w\", stdout); n = sc(); scanf(\"%s\", s + 1); m = sc(); for(int i = 1; i &lt;= m; i++) &#123; char c[2]; cin &gt;&gt; c[0] &gt;&gt; c[1]; c[0] = c[0] - 'a' + 1; c[1] = c[1] - 'a' + 1; int aa = c[0]; int bb = c[1]; pd[aa][bb] = pd[bb][aa] = 1; &#125; memset(dp, 0x7f, sizeof(dp)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= 26; j++) if(! pd[s[i] - 'a' +1][j]) dp[i] = min(dp[i], f[j] + i - 1); f[s[i] - 'a' + 1] = min(f[s[i] - 'a' + 1], dp[i] - i); &#125; printf(\"%d\\n\", dp[n]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"exgcd及逆元","slug":"exgcdNiYuan","date":"2019-06-26T16:00:00.000Z","updated":"2019-08-01T14:14:44.679Z","comments":true,"path":"2019/06/27/exgcdNiYuan/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/27/exgcdNiYuan/","excerpt":"相关题目链接： 同余方程 模板_乘法逆元","text":"相关题目链接： 同余方程 模板_乘法逆元 题目相关内容：数论之exgcd以及线性递推求逆元。 exgcd 基本模型，形如ax+by=c的方程，要是方程有整数解，我们可得c=gcd(a,b)，我们可以用exgcd求出其最小整数解，我们已知a,b，当b=0是，显然得a=1，我们考虑一下gcd的过程，加入当前我们已求得bx2+a%by2=gcd(a,b)的解为x2,y2,那如何得出x1,y1呢？具体证明过程请见下图 exgcd的时间复杂度与gcd类似，最坏情况下为θ(nlogn) exgcd求逆元 逆元：求关于x的同余方程 ax≡1(mod b) 的最小正整数解，x即为a的逆元。 根据裴蜀定理，要使同余方程ax≡1(mod b)有解，要满足gcd(a,p)|b，由题意得，b=1，所以gcd(a,p)=1 我们再来分析一下这个同余方程 所以，我们可以通过exgcd来解这个方程，同时这也求出了a的逆元。 代码（T1 AC） 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long longusing namespace std;ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;ll n, m;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if(!b) &#123; x = 1; y = 0; return a; &#125; ll gcd = exgcd(b, a % b, x, y); ll x2 = x, y2 = y; x = y2; y = x2 - a / b * y2; return gcd;&#125;int main() &#123; ll x = 0, y = 0; n = sc(); m = sc(); exgcd(n, m, x, y); printf(\"%lld\\n\", (x + m) % m); return 0;&#125; 代码（T2 80Pts） 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long longusing namespace std;ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;ll n, m;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if(!b) &#123; x = 1; y = 0; return a; &#125; ll gcd = exgcd(b, a % b, x, y); ll x2 = x, y2 = y; x = y2; y = x2 - a / b * y2; return gcd;&#125;int main() &#123; ll x = 0, y = 0; n = sc(); m = sc(); for(int i = 1; i &lt;= n; i++) &#123; x = 0, y = 0; exgcd(i, m, x, y); printf(\"%lld\\n\", (x + m) % m); &#125; return 0;&#125; 线性递推求逆元 首先，我们声明在下列计算中同余均是在mod p意义下 我们可以简单计算1^(-1)≡1 考虑任意正整数i，假定i-1的逆元已经正确计算，我们递推方程的计算过程如下： 代码（T2 AC）1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long long#define Maxn 3000010using namespace std;ll sc() &#123; ll xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;ll n, m;ll f[Maxn];int main() &#123; n = sc(); m = sc(); f[1] = 1; for(int i = 2; i &lt;= n; i++) f[i] = (m - m / i) * f[m % i] % m; for(int i = 1; i &lt;= n; i++) printf(\"%lld\\n\", f[i]); return 0;&#125; rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://dyrisingsunlight.github.io/tags/数论/"}]},{"title":"模板_KMP字符串匹配","slug":"KMP","date":"2019-06-25T16:00:00.000Z","updated":"2019-08-01T14:15:38.320Z","comments":true,"path":"2019/06/26/KMP/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/26/KMP/","excerpt":"题目链接： 模板_KMP字符串匹配","text":"题目链接： 模板_KMP字符串匹配 KMP算法 此算法为字符串匹配算法，此算法的优点在于，如果在匹配过程中失配，我们不需要从头开始，而是直接从某一特定位置开始，这样可以极大地节省时间复杂度，此算法的时间复杂度为θ(n) 关于特定位置 我们来看一组样例 12模式串：abcab文本串：abcacababcab 首先，前四位按位匹配成功，遇到第五位不同，而这时，我们选择将abcab向右移三位，或者可以直接理解为移动到模式串中与失配字符相同的那一位。可以简单地理解为，我们将两个已经遍历过的模式串字符重合，导致我们可以不用一位一位地移动，而是根据相同的字符来实现快速移动。 即变为 12模式串： abcabc文本串：abcabdababcabc 所以，对于模式串中的某一位置i，i的特定位置为j，满足j≤i 并且满足str1(i)=str1(j)str1(i)=str1(j) 并且在 j!=1j!=1 时理应满足 str1(1)str1(1)至str1(j-1)str1(j−1) 分别与 str(i-j+1)str(i−j+1)~str1(i-1)str1(i−1) 按位相等，我们把i的特殊位置用一个next数组来存 代码实现简述 我们首先要在模式串中找到每个位置的next，对于当前枚举到i，判断它前面的j是否等于i如果相等，把j记入next[i]，如果不相等，我们要缩小位置，令j=next[j]。然后模式串和文本串匹配，和之前找next方式基本一样，具体解释见代码。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define Maxn 1000010using namespace std;char a[Maxn], b[Maxn];int next[Maxn];int main() &#123; scanf(\"%s\", a + 1); scanf(\"%s\", b + 1); int len1 = strlen(a + 1); int len2 = strlen(b + 1); int j = 0; for(int i = 2; i &lt;= len2; i++) &#123; //注意我们从2开始枚举，且j从0开始，所以i相当于i-1，换言说j相当于j+1 while(j &gt; 0 &amp;&amp; b[j + 1] != b[i]) //如果不匹配，则往前跳 j = next[j]; if(b[j + 1] == b[i]) //如果相等，要j++，因为j相当于j+1 j++; next[i] = j; &#125; j = 0; for(int i = 1; i &lt;= len1; i++) &#123; //模式串和文本串匹配时从1开始 while(j &gt; 0 &amp;&amp; a[i] != b[j + 1]) //如果不匹配，则往前跳 j = next[j]; if(b[j + 1] == a[i]) //因为j从0开始，所以j要+1 j++; if(j == len2) &#123; //如果相等，输出位置 printf(\"%d\\n\", i - len2 + 1); j = next[j]; &#125; &#125; for(int i = 1; i &lt;= len2; i++) printf(\"%d \", next[i]); return 0;&#125; rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://dyrisingsunlight.github.io/tags/KMP/"}]},{"title":"mst(欧拉函数)","slug":"mst","date":"2019-06-24T16:00:00.000Z","updated":"2019-08-01T14:16:22.855Z","comments":true,"path":"2019/06/25/mst/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/25/mst/","excerpt":"题面","text":"题面 题目思路：根据题意，我们可以和jmy一样一眼看出最小生成树的边权和，因为每条边的边权为gcd(i,j)，如果两个数互质，即gcd(i,j)=1，则边权为最小，所以MST的边权和为n-1（即每条边边权都为1），那么怎样求MST的个数呢？ 我们假设已经枚举到了第i个点，与i互质的点有k个，那么根据乘法原理，总方案数要乘上k，所以这个题目可以转换成从第2个点到第n个点比小于等于它且与它互质的数目的乘积。 这时，我们要用到一个数论知识： 欧拉函数欧拉函数写作φ(x)（φ读作fài）,表示比不大于x且与x互质的数的数目， 这个函数有一些性质： 1.φ(1)= 1 2.φ(x)= x-1（x为质数，与x互质的数即为1到x-1，所以数目为x-1） 3.φ(p^k)=p^k-p^(k-1) （我们知道比p^k小的正整数有p^k - 1个，其中不与p互质的数有p^(k-1)-1 个，它们是 1p,2p,3p … ( p ^ (k-1)-1) p， 所以φ(p^k) = (p^k-1) - (p^(k-1)-1) = p^k - p^(k-1) = p^k-p^(k-1) ） 4.我们可以把3.中的式子变一下型，提出一个p^k来，就变成了(p^k)*(1-1/p) 5.欧拉函数为积性函数，对于本函数来说，性质如下图 具体证明方法请自行查阅。 6.更进一步，请看下图（转自shl） 7.我们可以通过线性筛来求欧拉函数，更确切的说，线性筛可以求出任何一个积性函数。 1线性筛：为埃拉托色尼筛法的进阶版，时间复杂度为O(n)，可以保证每个数只被筛一次，具体代码及解释如下 1234567for(int i = 2; i &lt;= n; i++) &#123; //从2开始枚举 if(! pd[i]) a[++cnt] = i; //如果当前数为质数，加到a数组中 for(int j = 1; j &lt;= cnt &amp;&amp; i * a[j] &lt;= n; j++) &#123; pd[i * a[j]] = 1; //标记合数 if(i % a[j] == 0) break; //重点！如果i % a[j] == 0，说明a[j]为i的最小因数，如果继续循环，则a[j+1]可能等于a[i]*一个未知数，这样就不能保证每个数只判断一次 &#125;&#125; 8.0 我们再来说一下如何用线性筛求欧拉函数，因为欧拉函数为积性函数，如果i mod p != 0, 那么 φ(i p) = φ(i) φ(p)，如果 i mod p == 0, 那么 φ(i p) == p φ(i)。我们这样就AC了 8.1 关于i mod p == 0, 那么 φ(i p) == p φ(i) 的证明，见下图 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long long#define Maxn 20010#define mod 100000007using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, cnt;int a[Maxn], f[Maxn];bool pd[Maxn];ll ans = 1;int main() &#123; freopen(\"mst.in\", \"r\", stdin); freopen(\"mst.out\", \"w\", stdout); n = sc(); f[1] = 1; pd[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(! pd[i]) &#123; a[++cnt] = i; f[i] = i - 1; &#125; for(int j = 1; j &lt;= cnt &amp;&amp; i * a[j] &lt;= n; j++) &#123; pd[i * a[j]] = 1; if(! (i % a[j])) &#123; f[i * a[j]] = f[i] * (f[a[j]] + 1); break; &#125; else f[i * a[j]] = f[i] * f[a[j]]; &#125; &#125;// for(int i = 1; i &lt;= n; i++)// printf(\"%d \", f[i]);// printf(\"\\n\"); for(int i = 2; i &lt;= n; i++) ans = (ans * f[i] % mod) % mod; printf(\"%lld\\n\", ans % mod); return 0;&#125; rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://dyrisingsunlight.github.io/tags/数论/"}]},{"title":"买汽水","slug":"MaiQiShui","date":"2019-06-24T16:00:00.000Z","updated":"2019-08-01T14:15:54.724Z","comments":true,"path":"2019/06/25/MaiQiShui/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/25/MaiQiShui/","excerpt":"题面","text":"题面 题目思路：这是一道模拟赛压轴题，当时我天真的认为这是一道简单的01背包题，但一看数据范围，顿时懵逼，就算用map代替数组，但也会TLE。一般的背包题的物品数量和物品价值都是适量的，而本题物品数量不多，但物品价值远远超出了普通的限度。本题的正解是爆搜，高大上一点叫折半搜索，英文名Meet In The Middle，即二分搜索，枚举方案数，最后将两边的方案数进行匹配。本题还有一些优化，类似于dfs中进行归并排序，优化常数，但这些我不会。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long long#define Maxn 50#define Maxm 1000010using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch = gc; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int n, m;ll len1, len2, now;ll a[Maxm&lt;&lt;1], b[Maxm&lt;&lt;1];int v[Maxn];void dfs1(int nowl,int nowr, int sum) &#123; if(nowl == nowr) &#123; a[++len1] = sum; if(sum + v[nowl] &lt;=m) a[++len1] = sum + v[nowl]; return ; &#125; dfs1(nowl + 1, nowr, sum); //两种选择，选 或 不选 if(sum + v[nowl] &lt;= m) dfs1(nowl + 1, nowr, sum + v[nowl]);&#125;void dfs2(int nowl,int nowr, int sum) &#123; if(nowl == nowr) &#123; b[++len2] = sum; if(sum + v[nowl] &lt;=m) b[++len2] = sum + v[nowl]; return ; &#125; dfs2(nowl + 1, nowr, sum); if(sum + v[nowl] &lt;= m) dfs2(nowl + 1, nowr, sum + v[nowl]);&#125;int main() &#123; n = sc(); m = sc(); for(int i = 1; i &lt;= n; i++) v[i] = sc(); int L = n &gt;&gt; 1; dfs1(1, L, 0); //折半搜索 dfs2(L + 1, n, 0); sort(a + 1, a + len1 + 1); sort(b + 1, b + len2 + 1); int l = 1, r = len2; //进行匹配，伪指针优化 while(l &lt;= len1) &#123; //因为序列是有序的，所以我们可以用一个变量当做指针，每次匹配时直接从上一个匹配完的位置开始即可 while(l &lt;= len1 &amp;&amp; a[l] + b[r] &lt;= m) &#123; //可以优化时间 if(now &lt; a[l] + b[r]) now = a[l] + b[r]; l++; &#125; r--; &#125; printf(\"%lld\\n\", now); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://dyrisingsunlight.github.io/tags/dfs/"}]},{"title":"模板_树状数组2","slug":"MuBanShuZhuangShuZu","date":"2019-06-23T16:00:00.000Z","updated":"2019-08-01T14:16:31.936Z","comments":true,"path":"2019/06/24/MuBanShuZhuangShuZu/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/24/MuBanShuZhuangShuZu/","excerpt":"题目链接：【模板】树状数组 2","text":"题目链接：【模板】树状数组 2 题目思路：基本的树状数组操作就不讲了，讲一下对于本题的差分思路。 差分： 原数组 差分数组 即为 我们可以得出 即 如果我们把原数组都加上2，即变为 差分数组变为 因为a[i]-a[i-1]是不变的，变得只有b[1]和b[3 + 1] (在这个样例中后者可以省略) 所以对a[x,y]进行修改,只用修改b[x]与b[y+1] 对于本题，我们可以把原数组记录下来，在用树状数组维护差分数组（即在原数基础上的变化），输出原数组加上变化值即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n, m;int a[500010], b[500010];int qwery(int x) &#123; int sum = 0; while(x &gt; 0) &#123; sum += a[x]; x -= ( x &amp; -x); &#125; return sum;&#125;void updata(int x,int i) &#123; while( x &lt;= n) &#123; a[x] += i; x += (x &amp; -x); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1 ;i &lt;= n; i++) scanf(\"%d\", &amp;b[i]); for(int i=1;i&lt;=m;i++) &#123; char c; cin &gt;&gt; c; if(c == '1') &#123; int x, y, k; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;k); updata(x, k); updata(y + 1, -k); &#125; if(c=='2') &#123; int x; scanf(\"%d\", &amp;x); printf(\"%d\\n\", b[x] + qwery(x)); &#125; &#125; return 0;&#125; rp++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://dyrisingsunlight.github.io/tags/树状数组/"},{"name":"差分","slug":"差分","permalink":"https://dyrisingsunlight.github.io/tags/差分/"}]},{"title":"关押罪犯","slug":"GuanYaZuiFan","date":"2019-06-23T16:00:00.000Z","updated":"2019-08-01T14:15:09.540Z","comments":true,"path":"2019/06/24/GuanYaZuiFan/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/24/GuanYaZuiFan/","excerpt":"题目链接：关押罪犯 题目思路：根据题意，这道题很明显要用并查集，用种类并查集来模拟两个监狱，根据怒气值降序排序，尽量将怒气大的罪犯分开，具体解释见代码。","text":"题目链接：关押罪犯 题目思路：根据题意，这道题很明显要用并查集，用种类并查集来模拟两个监狱，根据怒气值降序排序，尽量将怒气大的罪犯分开，具体解释见代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 20010#define Maxm 100010using namespace std;int sc() &#123; int xx=0,ff=1; char cch=gc; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-1; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=(xx&lt;&lt;1)+(xx&lt;&lt;3)+(cch^'0'); cch=gc; &#125; return xx*ff;&#125;struct node &#123; int x,y,num; bool operator &lt; (const node &amp;xx) const &#123; return num&gt;xx.num; &#125;&#125;a[Maxm];int n,m;int fa[Maxn&lt;&lt;1];int find(int x) &#123; return x==fa[x]? x: fa[x]=find(fa[x]);&#125;int main() &#123; n=sc(); m=sc(); for(int i=1; i&lt;=(n&lt;&lt;1); i++) //初始化并查集时要开双倍空间，每一倍模拟一个监狱 fa[i]=i; for(int i=1; i&lt;=m; i++) &#123; a[i].x=sc(); a[i].y=sc(); a[i].num=sc(); &#125; sort(a+1, a+m+1); //排序 for(int i=1; i&lt;=m+1; i++) &#123; //循环到m+1，因为降序排序，第m+1的值肯定是0 int xx=find(a[i].x); int yy=find(a[i].y); if(xx==yy) &#123; printf(\"%d\\n\",a[i].num); return 0; &#125;// fa[fa[a[i].x]]=fa[find(a[i].y+n)];// fa[fa[a[i].y]]=fa[find(a[i].x+n)]; fa[find(a[i].x)]=fa[find(a[i].y+n)]; //将两人分到两个监狱 fa[find(a[i].y)]=fa[find(a[i].x+n)]; &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://dyrisingsunlight.github.io/tags/并查集/"}]},{"title":"NOI_2002银河英雄传说","slug":"YinHeYingXiongChuanShuo","date":"2019-06-23T16:00:00.000Z","updated":"2019-08-01T14:19:03.906Z","comments":true,"path":"2019/06/24/YinHeYingXiongChuanShuo/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/24/YinHeYingXiongChuanShuo/","excerpt":"题目链接：[NOI2002]银河英雄传说 题目思路： 根据题意，这道题明显要用带权并查集，我们用size数组表示一个集合内的容量，d[i]表示元素i之前的元素数量，我们可以在find()函数和合并过程中来维护d[]数组，具体解释见代码。","text":"题目链接：[NOI2002]银河英雄传说 题目思路： 根据题意，这道题明显要用带权并查集，我们用size数组表示一个集合内的容量，d[i]表示元素i之前的元素数量，我们可以在find()函数和合并过程中来维护d[]数组，具体解释见代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 30010using namespace std;int sc() &#123; int xx = 0, ff = 1; char cch; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int t;int fa[Maxn], size[Maxn], d[Maxn];int find( int x) &#123; if (x == fa[x]) return x; int xx = find( fa[x]); d[x] += d[fa[x]]; return fa[x] = xx;&#125;int aabs(int x) &#123; return x &gt; 0 ? x : - x;&#125;int main() &#123; t = sc(); for (int i = 1; i &lt;= 30000; i++) &#123; //赋初值,size数组为1 fa[i] = i; size[i] = 1; &#125; for (int i = 1; i &lt;= t; i++) &#123; char c[2]; cin &gt;&gt; c[0]; int x = sc(), y = sc(); //一定要在合并前find()，因为find()函数不仅是找爸爸，还要维护d数组！！！ int xx = find( x); int yy = find( y); if (c[0] == 'M') &#123;// cout &lt;&lt; xx &lt;&lt; \" \"&lt;&lt; yy &lt;&lt; endl; fa[xx] = yy; d[xx] = size[yy]; size[yy] += size[xx]; //注意我这样合并yy是父亲，则要把xx的元素数加到yy上 &#125; else &#123;// int x = sc(), y = sc();// cout &lt;&lt; fa[x] &lt;&lt; \" \" &lt;&lt; fa[y] &lt;&lt; endl; if(fa[x] == fa[y]) printf (\"%d\\n\", aabs( d[x] - d[y]) - 1); //两艘战舰之间的数目不难推出为|d[x]-d[y]|-1 else printf (\"-1\\n\"); &#125; &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://dyrisingsunlight.github.io/tags/并查集/"}]},{"title":"2048","slug":"2048","date":"2019-06-23T16:00:00.000Z","updated":"2019-08-01T14:12:46.774Z","comments":true,"path":"2019/06/24/2048/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/24/2048/","excerpt":"题目链接：2048","text":"题目链接：2048 题目思路：这种鬼题一看就要用dp，我们不妨用数组f[i]表示组成i的方案数，根据题意，有用的数是2的整数次幂，但最后答案的方案数要乘上2的无用的数次幂，我们可以用一个数组来存有用的数，以便于判断。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long long#define mo 998244353llusing namespace std;int sc() &#123; int xx = 0, ff = 1; char cch; while (cch &lt; '0' || cch &gt; '9') &#123; if (cch == '-') ff = -1; cch = gc; &#125; while (cch &gt;= '0'&amp;&amp; cch &lt;= '9') &#123; xx = (xx &lt;&lt; 1) + (xx &lt;&lt; 3) + (cch ^ '0'); cch = gc; &#125; return xx * ff;&#125;int num[2500];int n, tot;ll f[2500];int main() &#123; for (int i = 0; i &lt;= 11; i++) //用num数组来存有用的数 num[1&lt;&lt;i] = i; n = sc(); for (int i = 1; i &lt;= n; i++) &#123; int x = sc(); if(!num[x] &amp;&amp; x != 1) &#123; // 要特判1 tot++; //无用数+1 continue; &#125; for (int j = 2048; j &gt;= 1; j--) &#123; //倒序，相当于01背包，每个数只能用一次 if(f[j]) &#123; if(j + x &lt;= 2048) //输入的数+循环的到的数小于2048 f[j + x] = (f[j + x] + f[j]) % mo; //方案数相加 else f[2048] = (f[2048] + f[j]) % mo; //否则方案数加给2048 &#125; &#125; f[x]++; //不要忘记给输入的数的方案数+1 &#125;// cout &lt;&lt; tot &lt;&lt; endl; for(int i = 1; i &lt;= tot; i++) &#123; //根据题意，最后答案要乘2的无用数数目次幂 f[2048] = (f[2048] * 2ll) % mo; &#125; printf (\"%lld\\n\", f[2048]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"Blog介绍","slug":"Blog introduction and index","date":"2019-06-21T16:00:00.000Z","updated":"2019-09-17T14:37:58.129Z","comments":true,"path":"2019/06/22/Blog introduction and index/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/22/Blog introduction and index/","excerpt":"$\\mathrm{Blog}$介绍本$\\mathrm{Blog}$为$\\mathcal{Dy}$($Rising$$Sunlight$)的博客，基于$Hexo$，搭建在$Github$平台上形成。精于心，简于形。 ——$NexT$从$2019.8.28$开始，因为本$Blog$需要在本地更新，所以我的洛谷$Blog$会暂时记录我的一些文章，正文以本$Blog$为准。","text":"$\\mathrm{Blog}$介绍本$\\mathrm{Blog}$为$\\mathcal{Dy}$($Rising$$Sunlight$)的博客，基于$Hexo$，搭建在$Github$平台上形成。精于心，简于形。 ——$NexT$从$2019.8.28$开始，因为本$Blog$需要在本地更新，所以我的洛谷$Blog$会暂时记录我的一些文章，正文以本$Blog$为准。 特别感谢：手把手教你搭建属于自己的hexo+github博客hexo的next主题个性化配置教程2018最新版Hexo博客Next主题6.0配置优化Hexo NexT主题更改语言在HEXO博客中使用LaTeX公式的简单方法Hexo的Next主题详细配置Hexo Next主题添加搜索功能Hexo Next主题嵌入网易云音乐Hexo Next主题添加友情链接本人因技术有限，Blog并不美观。。。","categories":[{"name":"介绍","slug":"介绍","permalink":"https://dyrisingsunlight.github.io/categories/介绍/"}],"tags":[]},{"title":"旅游","slug":"LvYou","date":"2019-06-20T16:00:00.000Z","updated":"2019-08-01T14:15:51.045Z","comments":true,"path":"2019/06/21/LvYou/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/21/LvYou/","excerpt":"题目链接：旅游","text":"题目链接：旅游 如果没有权限查看题目，请看下图 题目思路：根据题意，我们可以知道城市布局为一棵树，因为住宿在一个城市中可以游览与它距离为1的所有城市，那么相当于求一颗树的最大独立集。 关于如何求树的最大独立集：树形dp，用一个数组f[i][0或1]表示第i个节点不住或住的最大天数，我们显然能够得到 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#define gc getchar()#define Maxn 500010using namespace std;int sc() &#123; int xx=0,ff=1; char cch=gc; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-1; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=(xx&lt;&lt;1)+(xx&lt;&lt;3)+(cch^'0'); cch=gc; &#125; return xx*ff;&#125;struct TREE &#123; int next,to;&#125;tree[Maxn&lt;&lt;1];int n,s,cnt;int head[Maxn&lt;&lt;1];int f[Maxn][2];void ADD(int from,int to) &#123; tree[++cnt].next=head[from]; tree[cnt].to=to; head[from]=cnt;&#125;void dfs(int son,int fa) &#123; f[son][0]=0; f[son][1]=1; for(int i=head[son]; i; i=tree[i].next) &#123; int to=tree[i].to; if(to!=fa) &#123; dfs(to,son); f[son][0]+=max(f[to][0],f[to][1]); f[son][1]=max(f[son][1],f[son][1]+f[to][0]); &#125; &#125;&#125;int main() &#123; int size = 64 &lt;&lt; 20; char *p = (char*)malloc(size) + size; __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p)); n=sc(); s=sc(); for(int i=1; i&lt;=n-1; i++) &#123; int x=sc(),y=sc(); ADD(x,y); ADD(y,x); &#125; dfs(s,-1); printf(\"%d\\n\",f[s][1]); exit(0);&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"躲藏","slug":"DuoCang","date":"2019-06-20T16:00:00.000Z","updated":"2019-08-01T14:13:28.391Z","comments":true,"path":"2019/06/21/DuoCang/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/21/DuoCang/","excerpt":"题目链接：躲藏 如果没有权限看题，请看下图","text":"题目链接：躲藏 如果没有权限看题，请看下图 题目思路：dp，因为求的是Cwbc作为子序列出现的次数，且不区分大小写，那我们就把整个序列全化为大写，用四个变量（e1,e2,e3,e4）来记录以c、w、b、c出现的次数，我们不难得出 代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long long#define Maxn 200010#define mo 2000120420010122using namespace std;char s[Maxn];ll e1,e2,e3,e4;int main() &#123; while(scanf(\"%s\",s+1)!=EOF) &#123; e1=e2=e3=e4=0; int lens=strlen(s+1); for(int i=1; i&lt;=lens; i++) &#123; if(s[i]&gt;='a'&amp;&amp; s[i]&lt;='z') s[i]-=32; if(s[i]=='C') e1++; if(s[i]=='W') e2+=(e1)%mo; if(s[i]=='B') e3+=(e2)%mo; if(s[i]=='C') e4+=(e3)%mo; &#125; printf(\"%lld\\n\",e4%mo); &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"}]},{"title":"博弈","slug":"BoYi","date":"2019-06-20T16:00:00.000Z","updated":"2019-08-01T14:12:57.121Z","comments":true,"path":"2019/06/21/BoYi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/21/BoYi/","excerpt":"题目链接：博弈","text":"题目链接：博弈 如果没有权限看题，请看下图 题目思路：通过手玩样例，我们可以得出一些结论： 如果k==1，那么可以不断地删数，即为平局。 我们可以把区间内的每个数判断一下，看能用几次k把那个数弄为0，把次数累加，最后发现，胜利结果与总次数的奇偶性有关。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long longusing namespace std;int l,r,k;ll tot;int main() &#123; while(scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;k)!=EOF) &#123; if(k==1) &#123; printf(\"Draw\\n\"); continue; &#125; tot=0; for(int i=l; i&lt;=r; i++) &#123; ll time=1; while(time&lt;=i) &#123; tot+=time; time*=k; &#125; tot&amp;=1; &#125;// cout&lt;&lt;tot&lt;&lt;endl; if(!(tot&amp;1)) &#123; printf(\"Cwbc\\n\"); &#125; else &#123; printf(\"XHRlyb\\n\"); &#125; &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://dyrisingsunlight.github.io/tags/模拟/"}]},{"title":"零点","slug":"LingDian","date":"2019-06-20T16:00:00.000Z","updated":"2019-08-01T14:15:48.857Z","comments":true,"path":"2019/06/21/LingDian/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/21/LingDian/","excerpt":"题目链接：零点","text":"题目链接：零点 如果没有权限看题，请看下图 题目思路：就是模拟了，根据题意模拟即可，具体解释见代码。 附件：关于求y=kx+b的相关公式 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long long#define Maxn 700010#define Maxx 300000using namespace std;ll sc() &#123; ll xx=0,ff=1; char cch=gc; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=(xx&lt;&lt;1)+(xx&lt;&lt;3)+(cch^48); cch=gc; &#125; return xx*ff;&#125;ll n,cnt;ll lax,lay,x,y;ll ans[Maxn];int main() &#123; n=sc(); lax=sc(); lay=sc(); //lax lay 为上一个点的横纵坐标 if(!lay) ans[++cnt]=lax; //如果第一个点的纵坐标为0，则lax为一个零点 for(ll i=2; i&lt;=n; i++) &#123; x=sc(); y=sc(); if(i==2&amp;&amp; ((lay&gt;0&amp;&amp;y&gt;lay&amp;&amp;(y-lay)*(x-lax)&gt;0)|| (lay&lt;0&amp;&amp;y&lt;lay&amp;&amp;(y-lay)*(x-lax)&lt;0))) //处理射线，当射线满足形似'/'或'\\'时 if((lay*(x-lax)%(y-lay))==0) &#123; //零点为整点 ans[++cnt]=lax-lay*(x-lax)/(y-lay); //由公式求出零点 if(cnt&gt;Maxx) &#123; printf(\"-1\\n\"); return 0; &#125; &#125; if(lay==0&amp;&amp;y==0) &#123; //如果当前点和上一点在x轴上 if(i==2||i==n) &#123; //如果在射线上，那么数量肯定会超过3e5 printf(\"-1\\n\"); return 0; &#125; for(ll j=lax+1; j&lt;=x; j++) &#123; //否则就把它们之间的零点存入 ans[++cnt]=j; if(cnt&gt;Maxx) &#123; printf(\"-1\\n\"); return 0; &#125; &#125; &#125; else if(lay!=0&amp;&amp;y==0) &#123; //如果上一点不在x轴上，而当前点在x轴上，存入 ans[++cnt]=x; if(cnt&gt;Maxx) &#123; printf(\"-1\\n\"); return 0; &#125; &#125; else if(lay*y&lt;0) &#123; //如果前后两点在x轴两侧 if((lay*(x-lax)%(y-lay))==0) &#123; //同上 ans[++cnt]=lax-lay*(x-lax)/(y-lay); if(cnt&gt;Maxx) &#123; printf(\"-1\\n\"); return 0; &#125; &#125; &#125; if(i==n&amp;&amp; ((y&lt;0&amp;&amp;y&gt;lay&amp;&amp;(y-lay)*(x-lax)&gt;0)|| (y&gt;0&amp;&amp;y&lt;lay&amp;&amp;(y-lay)*(x-lax)&lt;0))) //处理第二条射线，思路和第一条射线基本一样，但做法不同 if((lay*(x-lax)%(y-lay))==0) &#123; ans[++cnt]=lax-lay*(x-lax)/(y-lay); if(cnt&gt;Maxx) &#123; printf(\"-1\\n\"); return 0; &#125; &#125; lax=x; lay=y; //更新上一个点坐标 &#125; printf(\"%lld\\n\",cnt); //输出 for(ll i=1; i&lt;=cnt; i++) printf(\"%lld \",ans[i]); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://dyrisingsunlight.github.io/tags/模拟/"}]},{"title":"幻方","slug":"HuanFang","date":"2019-06-20T16:00:00.000Z","updated":"2019-08-01T14:15:16.377Z","comments":true,"path":"2019/06/21/HuanFang/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/21/HuanFang/","excerpt":"题目链接：幻方","text":"题目链接：幻方 如果没有权限看题，请看下图 题目思路：通过读题，发现题目的重点是读入，我们通过自己画一个图来把数据转化成一个三维图形（输入的数据相当于自己站在正方体里面看六个面，要转化为站在外面看六个面），在通过状压的方式记录来自不同方向的激光，最后枚举判断即可。本题的重点难点在于转化图形建模。 附件：可以根据下图来转化。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;// int f[210][210],b[210][210],u[210][210],d[210][210],l[210][210],r[210][210];int vis[210][210][210],ans;char now[210];int main() &#123; while(scanf(\"%d\",&amp;n)!=EOF) &#123; memset(vis,0,sizeof(vis)); ans=0; for(int i=1;i&lt;=n;i++) &#123; //line of read //front scanf(\"%s\",now+1); for(int j=1;j&lt;=n;j++) //row of read if(now[j]=='#') for(int k=1;k&lt;=n;k++) //other vis[n-j+1][k][n-i+1]|=1; &#125; for(int i=1;i&lt;=n;i++) &#123; //back scanf(\"%s\",now+1); for(int j=1;j&lt;=n;j++) if(now[j]=='#') for(int k=1;k&lt;=n;k++) vis[j][k][n-i+1]|=1; &#125; for(int i=1;i&lt;=n;i++) &#123; //left scanf(\"%s\",now+1); for(int j=1;j&lt;=n;j++) if(now[j]=='#') for(int k=1;k&lt;=n;k++) vis[k][j][n-i+1]|=(1&lt;&lt;1); &#125; for(int i=1;i&lt;=n;i++) &#123; //right scanf(\"%s\",now+1); for(int j=1;j&lt;=n;j++) if(now[j]=='#') for(int k=1;k&lt;=n;k++) vis[k][n-j+1][n-i+1]|=(1&lt;&lt;1); &#125; for(int i=1;i&lt;=n;i++) &#123; //up scanf(\"%s\",now+1); for(int j=1;j&lt;=n;j++) if(now[j]=='#') for(int k=1;k&lt;=n;k++) vis[j][i][k]|=(1&lt;&lt;2); &#125; for(int i=1;i&lt;=n;i++) &#123; //down scanf(\"%s\",now+1); for(int j=1;j&lt;=n;j++) if(now[j]=='#') for(int k=1;k&lt;=n;k++) vis[j][n-i+1][k]|=(1&lt;&lt;2); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) if(vis[i][j][k]==7) ans++; printf(\"%d\\n\",ans); &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://dyrisingsunlight.github.io/tags/模拟/"},{"name":"状压","slug":"状压","permalink":"https://dyrisingsunlight.github.io/tags/状压/"}]},{"title":"传染病控制","slug":"ChuanRanBingKongZhi","date":"2019-06-18T16:00:00.000Z","updated":"2019-08-01T14:13:11.107Z","comments":true,"path":"2019/06/19/ChuanRanBingKongZhi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/19/ChuanRanBingKongZhi/","excerpt":"题目链接：传染病控制","text":"题目链接：传染病控制 题目思路： 第一种思路：贪心，由题意得，本题可以建模为一棵树，在每一层上切断一条边，让被感染的节点数最少。如果我们用一个数组把每个子树所包含的节点数记录下来，在每次切割时切节点数最大的节点，这其实是不对的，下图为HACK数据。 第二种思路（正解）：对于切割一条边，我们可以换一种想法，假设当前一层有x,y,z三个节点，我们要切掉x，那么y、z会被感染，那么其实z的子节点可以合并到y上，这样就方便我们爆搜。如下图所示。根据数据范围，我们可以简单地用邻接矩阵来建树，具体含义见代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#define gc getchar()#define Maxn 310#define INF 0x7fffffffusing namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;int Map[Maxn][Maxn],tree[Maxn][Maxn];int n,m,ans=INF;int findroot(int x,int i) &#123; //找相邻节点 if(i==1) return tree[x][2]; return tree[x][1];&#125;void dfs(int now,int sum) &#123; if(sum+tree[now][0]-1&gt;=ans) return ; //剪枝 if(tree[now][0]&lt;=1) &#123; //如果已经是最后一层，取最小值，跳出 ans=min(ans,sum); return ; &#125; for(int i=1; i&lt;=tree[now][0]; i++) &#123; //枚举每一个子节点 int y=tree[now][i]; int root=findroot(now,i); //找相邻节点 int re=tree[root][0]; //记录原节点数，用来回溯 for(int j=1; j&lt;=tree[now][0]; j++) &#123; int yy=tree[now][j]; if(y!=yy&amp;&amp; yy!=root) &#123; for(int k=1; k&lt;=tree[yy][0]; k++) //把一个节点的子树转移到另一个节点上 tree[root][++tree[root][0]]=tree[yy][k]; &#125; &#125; dfs(root,sum+tree[now][0]-1); //往下爆搜 tree[root][0]=re; //回溯 &#125;&#125;void build(int x) &#123; for(int i=1; i&lt;=n; i++) &#123; if(Map[x][i]) &#123; tree[x][++tree[x][0]]=i; //tree数组就不解释了，自行理解。。。 Map[x][i]=Map[i][x]=0; build(i); &#125; &#125;&#125;int main() &#123; n=sc(); m=sc(); for(int i=1; i&lt;=m; i++) &#123; int x=sc(),y=sc(); Map[x][y]=Map[y][x]=1; //Map数组不解释，自行理解。。。 &#125; build(1); //建树 dfs(1,1); printf(\"%d\",ans); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://dyrisingsunlight.github.io/tags/dfs/"}]},{"title":"仓鼠找sugar","slug":"CangShuZhaoSugar","date":"2019-06-17T16:00:00.000Z","updated":"2019-08-01T14:13:00.635Z","comments":true,"path":"2019/06/18/CangShuZhaoSugar/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/18/CangShuZhaoSugar/","excerpt":"题目链接：仓鼠找sugar","text":"题目链接：仓鼠找sugar 题目思路：首先，我们知道，在一棵树上两个节点(x,y)的最短距离就是x-&gt;LCA(x,y)-&gt;y，那么我们可以得出，从x到y，LCA(x,y)是必经之点，那么对于四个点(x1,y1;x2,y2)来说，如果它们的最短路上有交点，则max(deep[LCA(x1,y1)]，deep[LCA(x2,y2)]）后的LCA一定在任意两个点的最短路上，那根据之前的结论，我们就求出任意两个点的LCA，就深度取max,如果不小于max(deep[LCA(x1,y1)], deep[LCA(x2,y2)])，那就说明合法，否则，就不合法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 1000010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct TREE &#123; int next,to;&#125;tree[Maxn*2];int n,m,cnt;int head[Maxn],deep[Maxn];int f[Maxn][22];void ADD(int from,int to) &#123; tree[++cnt].next=head[from]; tree[cnt].to=to; head[from]=cnt;&#125;void D_F(int son,int fa) &#123; deep[son]=deep[fa]+1; for(int i=0; i&lt;=19; i++) f[son][i+1]=f[f[son][i]][i]; for(int i=head[son]; i; i=tree[i].next) &#123; int to=tree[i].to; if(to==fa) continue; f[to][0]=son; D_F(to,son); &#125;&#125;int LCA(int x,int y) &#123; if(deep[x]&lt;deep[y]) swap(x,y); for(int i=20; i&gt;=0; i--) &#123; if(deep[f[x][i]]&gt;=deep[y]) x=f[x][i]; if(x==y) return x; &#125; for(int i=20; i&gt;=0; i--) &#123; if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; &#125; return f[x][0];&#125;int main() &#123; n=sc(); m=sc(); for(int i=1; i&lt;n; i++) &#123; int x=sc(),y=sc(); ADD(x,y); ADD(y,x); &#125; D_F(1,0); while(m--) &#123; int x1=sc(),y1=sc(),x2=sc(),y2=sc(); int mid1=LCA(x1,y1),mid2=LCA(x2,y2); int MID=max(deep[mid1],deep[mid2]); int maxx=max(deep[LCA(x1,x2)],max(deep[LCA(x1,y2)],max(deep[LCA(y1,x2)],deep[LCA(y1,y2)]))); if(maxx&gt;=MID) printf(\"Y\\n\"); else printf(\"N\\n\"); &#125; return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"}]},{"title":"NOI2001_食物链","slug":"ShiWuLian","date":"2019-06-17T16:00:00.000Z","updated":"2019-08-01T14:17:13.789Z","comments":true,"path":"2019/06/18/ShiWuLian/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/18/ShiWuLian/","excerpt":"题目链接：食物链 题目思路：通过题目，我们不难发现有动物之间有三个关系，分别为同类、食物、天敌，于是我们可以开3*n的空间来进行并查集，分别对应上面的关系，进行一些合理的判断，就可以AC。","text":"题目链接：食物链 题目思路：通过题目，我们不难发现有动物之间有三个关系，分别为同类、食物、天敌，于是我们可以开3*n的空间来进行并查集，分别对应上面的关系，进行一些合理的判断，就可以AC。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,k,ans;int f[50010*3];int find(int x)&#123; if(f[x]!=x) f[x]=find(f[x]); return f[x];&#125;void un(int x,int y)&#123; f[find(y)]=find(x);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); for(int i=1;i&lt;=3*n;i++) f[i]=i; for(int i=1;i&lt;=k;i++) &#123; int c,x,y; scanf(\"%d%d%d\",&amp;c,&amp;x,&amp;y); if(x&gt;n||y&gt;n) //判断动物序号是否超出范围 &#123; ans++; continue; &#125; if(c==1) //动物为同类 &#123; if(find(x+n)==find(y)||find(x+2*n)==find(y)) //x的食物和y的同类为同类 或 x的天敌和y的同类是同类，显然不符题意 &#123; ans++; continue; &#125; un(x,y); //x,y的同类为同类 un(x+n,y+n); //x,y的食物合并 un(x+2*n,y+2*n); //x,y的天敌合并 &#125; else if(c==2) //动物为被吃关系 &#123; if(find(x)==find(y)||find(x+2*n)==find(y)) //x的同类和y的同类为同类 或 x的天敌和y的同类是同类，不符题意 &#123; ans++; continue; &#125; un(x,y+2*n); //x的同类和y的天敌合并 un(x+n,y); //x的食物和y的同类合并 un(x+2*n,y+n); //x的天敌和y的食物合并 &#125; &#125; printf(\"%d\",ans); return 0;&#125; rp++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://dyrisingsunlight.github.io/tags/并查集/"}]},{"title":"砝码称重","slug":"famachengzhong","date":"2019-06-16T16:00:00.000Z","updated":"2019-08-01T14:14:48.813Z","comments":true,"path":"2019/06/17/famachengzhong/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/17/famachengzhong/","excerpt":"题目思路：根据数据范围，我们可以爆搜枚举每一种情况，然后到达边界时dp一下。dp其实是一个变式01背包，以它们之累加和为容量跑一遍，更新答案。","text":"题目思路：根据数据范围，我们可以爆搜枚举每一种情况，然后到达边界时dp一下。dp其实是一个变式01背包，以它们之累加和为容量跑一遍，更新答案。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 30#define INF 2010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;int n,m,ans;int a[Maxn];bool vis[Maxn],pd[INF];namespace DY &#123; void dp() &#123; int cnt=0,sum=0; memset(pd,0,sizeof(pd)); pd[0]=1; for(int i=1; i&lt;=n; i++) &#123; if(vis[i]) continue; for(int j=sum; j&gt;=0; j--) &#123; if(pd[j]&amp;&amp;!pd[j+a[i]]) pd[j+a[i]]=1,cnt++; &#125; sum+=a[i]; &#125; ans=max(ans,cnt); &#125; void dfs(int now,int tot) &#123; if(tot&gt;m) return ; if(now==n+1) &#123; if(tot==m) dp(); return ; &#125; dfs(now+1,tot); vis[now]=1; dfs(now+1,tot+1); vis[now]=0; &#125; void AKNOIP() &#123; n=sc(); m=sc(); for(int i=1; i&lt;=n; i++) a[i]=sc(); dfs(1,0); printf(\"%d\",ans); &#125;&#125;;int main() &#123; DY::AKNOIP(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://dyrisingsunlight.github.io/tags/dp/"},{"name":"dfs","slug":"dfs","permalink":"https://dyrisingsunlight.github.io/tags/dfs/"}]},{"title":"【模板】严格次小生成树[BJWC2010]","slug":"CiXiaoShengChengShu","date":"2019-06-16T16:00:00.000Z","updated":"2019-08-01T14:13:21.667Z","comments":true,"path":"2019/06/17/CiXiaoShengChengShu/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/17/CiXiaoShengChengShu/","excerpt":"题目思路：先搞一个最小生成树，把用到的边做一个标记，然后跑一遍LCA预处理，但是要倍增维护一个最大值和一个次大值。弄完后枚举MST没用到的边，求出两个值——一个是一点到这两点LCA的边权最大值，另一个是另一个点到LCA的边权最大值。然后比较一下取min。","text":"题目思路：先搞一个最小生成树，把用到的边做一个标记，然后跑一遍LCA预处理，但是要倍增维护一个最大值和一个次大值。弄完后枚举MST没用到的边，求出两个值——一个是一点到这两点LCA的边权最大值，另一个是另一个点到LCA的边权最大值。然后比较一下取min。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 100010#define Maxm 300010#define INF 2147483647000000000ll#define ll long longusing namespace std;ll sc() &#123; ll xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct EDGE &#123; ll u,v,dis; bool operator &lt; (const EDGE &amp;x) const &#123; return dis&lt;x.dis; &#125;&#125;a[Maxm*2];struct TREE &#123; ll next,to,dis;&#125;edge[Maxn*2];ll n,m,cnt,ans,num;ll head[Maxn*2],father[Maxn],deep[Maxn];bool vis[Maxm];ll f[Maxn][22];ll ma[Maxn][22][3];namespace DY &#123; void ADD(ll from,ll to,ll dis) &#123; edge[++cnt].next=head[from]; edge[cnt].to=to; edge[cnt].dis=dis; head[from]=cnt; &#125; ll find(ll x) &#123; return x==father[x]? x: father[x]=find(father[x]); &#125; void D_F(ll son,ll fa) &#123; deep[son]=deep[fa]+1; for(int i=head[son]; i; i=edge[i].next) &#123; ll to=edge[i].to; if(to==fa) continue; ma[to][0][0]=edge[i].dis; ma[to][0][1]=-INF; f[to][0]=son; D_F(to,son); &#125; &#125; void d_f() &#123; for(int i=1; i&lt;=18; i++) for(int j=1; j&lt;=n; j++) &#123; f[j][i]=f[f[j][i-1]][i-1]; ma[j][i][0]=max(ma[j][i-1][0], ma[f[j][i-1]][i-1][0]); ma[j][i][1]=max(ma[j][i-1][1], ma[f[j][i-1]][i-1][1]); if(ma[j][i-1][0]&gt;ma[f[j][i-1]][i-1][0]) ma[j][i][1]=max(ma[j][i][1], ma[f[j][i-1]][i-1][0]); else if(ma[j][i-1][0]&lt;ma[f[j][i-1]][i-1][0]) ma[j][i][1]=max(ma[j][i][1], ma[j][i-1][0]); &#125; &#125; ll LCA(ll x,ll y) &#123; if(deep[x]&lt;deep[y]) swap(x,y); for(int i=18; i&gt;=0; i--) if(deep[f[x][i]]&gt;=deep[y]) x=f[x][i]; if(x==y) return y; for(int i=18; i&gt;=0; i--) &#123; if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; &#125; return f[x][0]; &#125; ll calc(ll u,ll v,ll maxx) &#123; ll res=-INF; for(int i=18; i&gt;=0; i--) &#123; if(deep[f[u][i]]&gt;=deep[v]) &#123; if(maxx!=ma[u][i][0]) res=max(res,ma[u][i][0]); else res=max(res,ma[u][i][1]); u=f[u][i]; &#125; &#125; return res; &#125; void AKNOIP() &#123; n=sc(); m=sc(); for(int i=1; i&lt;=m; i++) &#123; a[i].u=sc(); a[i].v=sc(); a[i].dis=sc(); &#125; for(int i=1; i&lt;=n; i++) father[i]=i; sort(a+1,a+1+m); for(int i=1; i&lt;=m; i++) &#123; ll aa=find(a[i].u); ll bb=find(a[i].v); if(aa!=bb) &#123; num+=a[i].dis; father[aa]=bb; ADD(a[i].u,a[i].v,a[i].dis); ADD(a[i].v,a[i].u,a[i].dis); vis[i]=1; &#125; &#125; ma[1][0][1]=-INF; D_F(1,0); d_f(); ans=INF; for(int i=1; i&lt;=m; i++) &#123; if(!vis[i]) &#123; ll lca=LCA(a[i].u,a[i].v); ll maxu=calc(a[i].u,lca,a[i].dis); ll maxv=calc(a[i].v,lca,a[i].dis); ans=min(ans,num-max(maxu,maxv)+a[i].dis); &#125; &#125; printf(\"%lld\",ans); &#125;&#125;;int main() &#123; DY::AKNOIP(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"},{"name":"克鲁斯卡尔","slug":"克鲁斯卡尔","permalink":"https://dyrisingsunlight.github.io/tags/克鲁斯卡尔/"},{"name":"MST","slug":"MST","permalink":"https://dyrisingsunlight.github.io/tags/MST/"}]},{"title":"疫情控制","slug":"YiQingKongZhi","date":"2019-06-16T16:00:00.000Z","updated":"2019-08-01T14:19:06.785Z","comments":true,"path":"2019/06/17/YiQingKongZhi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/17/YiQingKongZhi/","excerpt":"题目思路：链式前向星存图，跑一遍LCA的预处理，判断一下深度为二的有几个点，和军队的总数比较一下来判断能否控制。然后二分答案，check函数先把每个军队往上提，看能否到根节点，如果不能，则把最近能到达的点标记一下，如果能到根节点，那就记一下记录根节点最近能到的一个点并记录，然后在把能到的点按边权排个序，把不能到的点按边权排个序，判断一下最优解是否能超过不能到达的点。","text":"题目思路：链式前向星存图，跑一遍LCA的预处理，判断一下深度为二的有几个点，和军队的总数比较一下来判断能否控制。然后二分答案，check函数先把每个军队往上提，看能否到根节点，如果不能，则把最近能到达的点标记一下，如果能到根节点，那就记一下记录根节点最近能到的一个点并记录，然后在把能到的点按边权排个序，把不能到的点按边权排个序，判断一下最优解是否能超过不能到达的点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 500010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct TREE &#123; int next,to,dis;&#125;edge[Maxn*2];struct node &#123; int id; long long v; bool operator &lt; (const node &amp;x) const &#123; return v&lt;x.v; &#125;&#125;a[Maxn*2],b[Maxn*2];int n,cnt,m,ans,lena,lenb,all;int head[Maxn*2],deep[Maxn],Fa[Maxn],army[Maxn];int f[Maxn][22],Dis[Maxn][22];bool vis[Maxn];namespace DY &#123; void ADD(int from,int to,int dis) &#123; edge[++cnt].next=head[from]; edge[cnt].to=to; edge[cnt].dis=dis; head[from]=cnt; &#125; void D_F(int son,int fa) &#123; deep[son]=deep[fa]+1; Fa[son]=fa; for(int i=1; i&lt;=20&amp;&amp; f[f[son][i-1]][i-1]; i++) &#123; f[son][i]=f[f[son][i-1]][i-1]; Dis[son][i]=Dis[f[son][i-1]][i-1]+Dis[son][i-1]; &#125; for(int i=head[son]; i; i=edge[i].next) &#123; int to=edge[i].to; if(to==fa) continue; f[to][0]=son; Dis[to][0]=edge[i].dis; D_F(to,son); &#125; &#125; void ctrl(int now) &#123; int flag1=1,flag2=0; for(int i=head[now]; i; i=edge[i].next) &#123; int to=edge[i].to; if(to==Fa[now]) continue; ctrl(to); flag1&amp;=vis[to]; flag2=1; &#125; if(now!=-1&amp;&amp; flag1&amp;&amp; flag2) vis[now]=1; &#125; bool chekc(int now) &#123; lena=lenb=0; memset(vis,0,sizeof(vis)); for(int i=1; i&lt;=m; i++) &#123; int x=army[i],num=0; for(int j=20; j&gt;=0; j--) if(f[x][j]&amp;&amp; num+Dis[x][j]&lt;=now) num+=Dis[x][j],x=f[x][j]; if(x!=1) vis[x]=1; else &#123; x=army[i]; a[++lena].v=now-num; for(int j=20; j&gt;=0; j--) if(f[x][j]&gt;1) x=f[x][j]; a[lena].id=x; &#125; &#125; ctrl(1); for(int i=head[1]; i; i=edge[i].next) &#123; int to=edge[i].to; if(vis[to]) continue; b[++lenb].id=to; b[lenb].v=edge[i].dis; &#125; sort(a+1,a+1+lena); sort(b+1,b+1+lenb); int j=1; for(int i=1; i&lt;=lena; i++) &#123; if(!vis[a[i].id]) vis[a[i].id]=1; else if(a[i].v&gt;=b[j].v) vis[b[j].id]=1; while(vis[b[j].id]&amp;&amp; j&lt;=lenb) j++; &#125; return j&gt;lenb; &#125; void main() &#123; n=sc(); int l=0,r=0; for(int i=1; i&lt;n; i++) &#123; int u=sc(),v=sc(),w=sc(); ADD(u,v,w); ADD(v,u,w); r+=w; &#125; all=r; D_F(1,0); m=sc(); for(int i=1; i&lt;=m; i++) army[i]=sc(); int num=0; for(int i=1; i&lt;=n; i++) if(deep[i]==2) num++; if(m&lt;num) &#123; printf(\"-1\"); return ; &#125; while(l&lt;=r) &#123; int mid=l+r&gt;&gt;1;// cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl&lt;&lt;endl; if(chekc(mid)) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf(\"%d\",ans); &#125;&#125;;int main() &#123; DY::main(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"}]},{"title":"斐波那契","slug":"FeiBoNaQi","date":"2019-06-16T16:00:00.000Z","updated":"2019-08-01T14:14:51.155Z","comments":true,"path":"2019/06/17/FeiBoNaQi/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/06/17/FeiBoNaQi/","excerpt":"思路：根据数据，我们能发现，任意两个斐波纳契数做差会得到另一个斐波纳契数。那我们先根据数据范围打一个60项斐波纳契数列表，然后写一个函数。函数通过递归，不断把较大值减去在数列中第一个小于它的数，知道两数相等或其中一个数为1。","text":"思路：根据数据，我们能发现，任意两个斐波纳契数做差会得到另一个斐波纳契数。那我们先根据数据范围打一个60项斐波纳契数列表，然后写一个函数。函数通过递归，不断把较大值减去在数列中第一个小于它的数，知道两数相等或其中一个数为1。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define ll long longusing namespace std;ll sc() &#123; ll xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;long long a[100];int n;namespace DY &#123; inline long long check(ll x,ll y) &#123; if(x&lt;y) swap(x,y); if(x==y) return x; int now=lower_bound(a,a+61,x)-a; return check(y,x-a[now-1]); &#125; void main() &#123; a[1]=a[2]=1; for(register int i=3; i&lt;=60; i++) a[i]=a[i-1]+a[i-2]; n=sc(); while(n--) &#123; ll x=sc(),y=sc(); printf(\"%lld\\n\",check(x,y)); &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"},{"name":"递推","slug":"递推","permalink":"https://dyrisingsunlight.github.io/tags/递推/"}]},{"title":"暗的连锁","slug":"TJ_andesuolian","date":"2019-04-13T16:00:00.000Z","updated":"2019-08-06T14:16:55.091Z","comments":true,"path":"2019/04/14/TJ_andesuolian/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/04/14/TJ_andesuolian/","excerpt":"题目链接：「一本通 4.4 例 2」暗的连锁 题目标签：LCA，（树上差分） 题目大意：请自行读题。。。","text":"题目链接：「一本通 4.4 例 2」暗的连锁 题目标签：LCA，（树上差分） 题目大意：请自行读题。。。 题目分析：对于一条附加边[x,y]，如果将原树分开后x,y分成了两个部分，那么下一步就必须把x,y切开。通过研究样例，我们不妨这样想，对于每一条附加边[x,y]，我们就说 _从x到y的路径上的节点被覆盖了一次_ ，那么对于每个节点，无疑有三种情况： 1.该节点到根节点没有被覆盖过，那么下一步可以随意切一条边，故有M种方案。 2.该节点到根节点被覆盖过1次，那么下一步只能切除被分开的x,y。 3.该节点到根节点被覆盖过&gt;=2次，那么下一步无论怎样切割都无法达到要求。 那我们就把问题简化成了：对于每一条附加边，把它们的路径上的节点覆盖一次，然后枚举除了根节点之外的节点，累加方案数。 关于优化：如果暴力覆盖的话肯定会TLE，那我们就来差分一下，也就是树上差分，在这里不做详细解释，搬来一篇解释差分的洛谷日报，不会的读者请自行学习。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 200010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct EDGE &#123; int next,to;&#125;edge[Maxn*2];int n,m,ans,cnt;int head[Maxn*2],deep[Maxn],w[Maxn],ww[Maxn];int f[Maxn][21];namespace DY &#123; void ADD(int from,int to) &#123; edge[++cnt].next=head[from]; edge[cnt].to=to; head[from]=cnt; &#125; void D_F(int son,int fa) &#123; //LCA的板子(From line30 to line52) deep[son]=deep[fa]+1; for(int i=0; i&lt;=19; i++) f[son][i+1]=f[f[son][i]][i]; for(int i=head[son]; i; i=edge[i].next) &#123; int to=edge[i].to; if(to==fa) continue; f[to][0]=son; D_F(to,son); &#125; &#125; int LCA(int x,int y) &#123; if(deep[x]&lt;deep[y]) swap(x,y); for(int i=20; i&gt;=0; i--) &#123; if(deep[f[x][i]]&gt;=deep[y]) x=f[x][i]; if(x==y) return x; &#125; for(int i=20; i&gt;=0; i--) &#123; if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; &#125; return f[x][0]; &#125; void dfs(int son,int fa) &#123; //遍历赋值 for(int i=head[son]; i; i=edge[i].next) &#123; int to=edge[i].to; if(to==fa) continue; dfs(to,son); ww[son]+=ww[to]; &#125; &#125; void main() &#123; n=sc(); m=sc(); for(int i=1; i&lt;n; i++) &#123; int u=sc(),v=sc(); ADD(u,v); ADD(v,u); &#125; deep[1]=1; D_F(1,0); for(int i=1; i&lt;=m; i++) &#123; //树上差分 int u=sc(),v=sc(); w[u]++; w[v]++; w[LCA(u,v)]-=2; &#125; for(int i=1; i&lt;=n; i++) //ww[i]为第i个节点到根节点被覆盖的次数 ww[i]=w[i]; dfs(1,0); //进行遍历来赋值 for(int i=2; i&lt;=n; i++) &#123; if(!ww[i]) ans+=m; else if(ww[i]==1) ans+=1; &#125; printf(\"%d\",ans); &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; RP++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"},{"name":"树上差分","slug":"树上差分","permalink":"https://dyrisingsunlight.github.io/tags/树上差分/"}]},{"title":"模板_最近公共祖先（LCA）","slug":"TJ_LCA","date":"2019-04-12T16:00:00.000Z","updated":"2019-08-01T14:18:08.115Z","comments":true,"path":"2019/04/13/TJ_LCA/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/04/13/TJ_LCA/","excerpt":"题目链接：【模板】最近公共祖先（LCA） 题目标签：LCA 题目大意：略","text":"题目链接：【模板】最近公共祖先（LCA） 题目标签：LCA 题目大意：略 题目思路：LCA的朴素求法直接略过，只说明倍增求法。设f[i][j]为第i个节点的2^k倍的祖先，如果该节点不存在，则f[i][j]=0。重点来了：对于k∈[1,log(n)]，有f[x][k]=f[f[x][k-1]][k-1],即从x节点走2^k步==从x的父亲走2^k-1步再走2^k-1步，因此，我们可以用一次遍历来把f数组求出来，时间复杂度为O(nlogn)，至于查找函数，大体思路是：把深度大的节点放前面(设为x)，从x往上跳，直到与另一个节点（设为y）同深度，再去单个查找他们的父亲是不是同一个。时间复杂度为O(logn)。 代码（注释被吃了）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 500010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct EDGE &#123; int next,to;&#125;edge[Maxn*2];int n,m,s,cnt;int head[Maxn*2],deep[Maxn];int f[Maxn][21];namespace DY &#123; void ADD(int from,int to) &#123; edge[++cnt].next=head[from]; edge[cnt].to=to; head[from]=cnt; &#125; void D_F(int son,int fa) &#123; deep[son]=deep[fa]+1; for(int i=0; i&lt;=19; i++) f[son][i+1]=f[f[son][i]][i]; for(int i=head[son]; i; i=edge[i].next) &#123; int to=edge[i].to; if(to==fa) continue; f[to][0]=son; D_F(to,son); &#125; &#125; int LCA(int x,int y) &#123; if(deep[x]&lt;deep[y]) swap(x,y); for(int i=20; i&gt;=0; i--) &#123; if(deep[f[x][i]]&gt;=deep[y]) x=f[x][i]; if(x==y) return x; &#125; for(int i=20; i&gt;=0; i--) &#123; if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; &#125; return f[x][0]; &#125; void main() &#123; n=sc(); m=sc(); s=sc(); for(int i=1; i&lt;n; i++) &#123; //链式前向星建树 int u=sc(),v=sc(); ADD(u,v); ADD(v,u); &#125; D_F(s,0); //预处理 while(m--) &#123; int u=sc(),v=sc(); printf(\"%d\\n\",LCA(u,v)); //查询 &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; RP++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"https://dyrisingsunlight.github.io/tags/LCA/"}]},{"title":"SCOI2010_序列操作","slug":"TJ_xuliecaozuo","date":"2019-04-12T16:00:00.000Z","updated":"2019-08-01T14:18:49.918Z","comments":true,"path":"2019/04/13/TJ_xuliecaozuo/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/04/13/TJ_xuliecaozuo/","excerpt":"题目链接：SCOI2010_序列操作 写在前面的话：这道题真毒！！！ 题目标签：线段树 题目大意：给定一个序列，支持5种操作，全变0，全变1，区间取反，查询1的总数，查询连续1的总数。","text":"题目链接：SCOI2010_序列操作 写在前面的话：这道题真毒！！！ 题目标签：线段树 题目大意：给定一个序列，支持5种操作，全变0，全变1，区间取反，查询1的总数，查询连续1的总数。 题目思路：一个线段树维护7个量+2种标记。即 _1的总数（sum）、连续1的数目（l1）、连续0的数目（l0）、从左端点开始连续1的数目（ll1）、从左端点开始连续0的数目（ll0）、从右端点开始连续1的数目（rl1）、从右端点开始连续0的数目（rl0）;整体取反标记（all）、单个取反标记（sin）_ 。 建树：略 上传标记：sum直接左右儿子求和，ll0、ll1、rl0、rl1、l1、l0的维护详见另一篇题解。 下传标记：先处理全部取反的标记，再处理单个取反，详见代码pushdown函数。 3种修改：请读者自行理解。 2种查询： 对于查询1的总数：略 查询连续1的总数：和上传标记的思路基本一样，请读者自行理解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 100010using namespace std;int sc() &#123; int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct lst &#123; int sum,l1,l0,ll1,ll0,rl1,rl0,all,sin;&#125;T[Maxn*4];int n,m;int a[Maxn];namespace DY &#123; void pushup(int k,int l,int r) &#123; int mid=l+r&gt;&gt;1; int L1=mid-l+1,L2=r-mid; T[k].sum=T[k&lt;&lt;1].sum+T[k&lt;&lt;1|1].sum; T[k].ll0=T[k&lt;&lt;1].ll0; T[k].ll1=T[k&lt;&lt;1].ll1; if(T[k].ll0==L1) T[k].ll0+=T[k&lt;&lt;1|1].ll0; if(T[k].ll1==L1) T[k].ll1+=T[k&lt;&lt;1|1].ll1; T[k].rl0=T[k&lt;&lt;1|1].rl0; T[k].rl1=T[k&lt;&lt;1|1].rl1; if(T[k].rl0==L2) T[k].rl0+=T[k&lt;&lt;1].rl0; if(T[k].rl1==L2) T[k].rl1+=T[k&lt;&lt;1].rl1; T[k].l0=max(T[k&lt;&lt;1].l0, T[k&lt;&lt;1|1].l0); T[k].l0=max(T[k].l0, T[k&lt;&lt;1].rl0+T[k&lt;&lt;1|1].ll0); T[k].l1=max(T[k&lt;&lt;1].l1, T[k&lt;&lt;1|1].l1); T[k].l1=max(T[k].l1, T[k&lt;&lt;1].rl1+T[k&lt;&lt;1|1].ll1); &#125; void pushdown(int k,int l,int r) &#123; int mid=l+r&gt;&gt;1; int L1=mid-l+1,L2=r-mid; if(T[k].all==1) &#123; //首先处理整体取反 （这一部分感觉很好理解） T[k&lt;&lt;1]=(lst)&#123;L1,L1,0,L1,0,L1,0,1,0&#125;; //整体变1 T[k&lt;&lt;1|1]=(lst)&#123;L2,L2,0,L2,0,L2,0,1,0&#125;; &#125; else if(T[k].all==0) &#123; T[k&lt;&lt;1]=(lst)&#123;0,0,L1,0,L1,0,L1,0,0&#125;; //整体变0 T[k&lt;&lt;1|1]=(lst)&#123;0,0,L2,0,L2,0,L2,0,0&#125;; &#125; T[k].all=-1; if(T[k].sin==1) &#123; //单个取反 T[k].sin=0; T[k&lt;&lt;1].sum=L1-T[k&lt;&lt;1].sum; //新的sum相当于区间长度-原来1的数目 swap(T[k&lt;&lt;1].l0,T[k&lt;&lt;1].l1); //剩下的内容交换 具体解释[请自行copy该链接](https://www.luogu.org/blog/RIsingSunlight43383/dui-yu-wei-hu-xian-duan-shu-di-xie-shi-xu-lie-wei-hu-di-dan-ge-qu-fan) swap(T[k&lt;&lt;1].ll0,T[k&lt;&lt;1].ll1); swap(T[k&lt;&lt;1].rl0,T[k&lt;&lt;1].rl1); T[k&lt;&lt;1].sin^=1; T[k&lt;&lt;1|1].sum=L2-T[k&lt;&lt;1|1].sum; swap(T[k&lt;&lt;1|1].l0,T[k&lt;&lt;1|1].l1); swap(T[k&lt;&lt;1|1].ll0,T[k&lt;&lt;1|1].ll1); swap(T[k&lt;&lt;1|1].rl0,T[k&lt;&lt;1|1].rl1); T[k&lt;&lt;1|1].sin^=1; &#125; &#125; void build(int k,int l,int r) &#123; T[k].all=-1; if(l==r) &#123; T[k]=(lst)&#123;a[l],a[l],a[l]^1,a[l],a[l]^1,a[l],a[l]^1,-1,0&#125;; return ; &#125; int mid=l+r&gt;&gt;1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); pushup(k,l,r); &#125; void modify0(int k,int l,int r,int x,int y) &#123;// if(l&lt;x|| r&gt;y) return ; int mid=l+r&gt;&gt;1; if(l&gt;=x&amp;&amp; r&lt;=y) &#123; int L=r-l+1; T[k]=(lst)&#123;0,0,L,0,L,0,L,0,0&#125;; //0,0,L,0,0,L,L,0,0 return ; &#125; if(l&gt;y|| r&lt;x) return ; pushdown(k,l,r); if(x&lt;=mid) modify0(k&lt;&lt;1, l, mid, x, y); if(y&gt;mid) modify0(k&lt;&lt;1|1, mid+1, r, x, y); pushup(k,l,r); &#125; void modify1(int k,int l,int r,int x,int y) &#123;// if(l&lt;x|| r&gt;y) return ; int mid=l+r&gt;&gt;1; if(l&gt;=x&amp;&amp; r&lt;=y) &#123; int L=r-l+1; T[k]=(lst)&#123;L,L,0,L,0,L,0,1,0&#125;; //L,L,0,L,L,0,0,1,0 return ; &#125; if(l&gt;y|| r&lt;x) return ; pushdown(k,l,r); if(x&lt;=mid) modify1(k&lt;&lt;1, l, mid, x, y); if(y&gt;mid) modify1(k&lt;&lt;1|1, mid+1, r, x, y); pushup(k,l,r); &#125; void modify2(int k,int l,int r,int x,int y) &#123;// if(l&lt;x|| r&gt;y) return ; int mid=l+r&gt;&gt;1; if(l&gt;=x&amp;&amp; r&lt;=y) &#123; int L=r-l+1; T[k].sum=L-T[k].sum; swap(T[k].l0,T[k].l1); swap(T[k].ll0,T[k].ll1); swap(T[k].rl0,T[k].rl1); T[k].sin^=1; return ; &#125; if(l&gt;y|| r&lt;x) return ; pushdown(k,l,r); if(x&lt;=mid) modify2(k&lt;&lt;1, l, mid, x, y); if(y&gt;mid) modify2(k&lt;&lt;1|1, mid+1, r, x, y); pushup(k,l,r); &#125; int query1(int k,int l,int r,int x,int y) &#123;// if(l&lt;x|| r&gt;y) return 0; if(l&gt;=x&amp;&amp; r&lt;=y) return T[k].sum; if(l&gt;y|| r&lt;x) return 0; int mid=l+r&gt;&gt;1,res=0; pushdown(k,l,r); if(x&lt;=mid) res+=query1(k&lt;&lt;1, l, mid, x, y); if(y&gt;mid) res+=query1(k&lt;&lt;1|1, mid+1, r, x, y); return res; &#125; lst query2(int k,int l,int r,int x,int y) &#123;// if(l&lt;x|| r&gt;y) return (lst)&#123;0&#125;; if(l&gt;=x&amp;&amp; r&lt;=y) return T[k]; if(l&gt;y|| r&lt;x) return (lst)&#123;0&#125;; pushdown(k,l,r); int mid=l+r&gt;&gt;1; int L1=mid-l+1,L2=r-mid; lst LL=query2(k&lt;&lt;1, l, mid, x, y); lst RR=query2(k&lt;&lt;1|1, mid+1, r, x, y); lst ans; ans.sum=LL.sum+RR.sum; ans.ll0=LL.ll0; ans.ll1=LL.ll1; if(ans.ll0==L1) ans.ll0+=RR.ll0; if(ans.ll1==L1) ans.ll1+=RR.ll1; ans.rl0=RR.rl0; ans.rl1=RR.rl1; if(ans.rl0==L2) ans.rl0+=LL.rl0; if(ans.rl1==L2) ans.rl1+=LL.rl1; ans.l0=max(LL.l0, RR.l0); ans.l0=max(ans.l0, LL.rl0+RR.ll0); ans.l1=max(LL.l1, RR.l1); ans.l1=max(ans.l1, LL.rl1+RR.ll1); return ans; &#125; void main() &#123; n=sc(); m=sc(); for(int i=1; i&lt;=n; i++) a[i]=sc(); build(1,1,n); while(m--) &#123; int flag=sc(),u=sc(),v=sc(); u++,v++; if(!flag) &#123; modify0(1,1,n,u,v); &#125; else if(flag==1) &#123; modify1(1,1,n,u,v); &#125; else if(flag==2) &#123; modify2(1,1,n,u,v); &#125; else if(flag==3) &#123; printf(\"%d\\n\",query1(1,1,n,u,v)); &#125; else &#123; printf(\"%d\\n\",query2(1,1,n,u,v).l1); &#125; &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; RP++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"}]},{"title":"中位数","slug":"TJ_zhongweishu","date":"2019-04-05T16:00:00.000Z","updated":"2019-08-01T14:18:52.467Z","comments":true,"path":"2019/04/06/TJ_zhongweishu/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/04/06/TJ_zhongweishu/","excerpt":"题目链接：中位数 题目标签：线段树 题意：有一个长度为N的序列，要求输出前k个的中位数（1&lt;=k&lt;=(N+1)/2）。","text":"题目链接：中位数 题目标签：线段树 题意：有一个长度为N的序列，要求输出前k个的中位数（1&lt;=k&lt;=(N+1)/2）。 题目分析：这道题如果暴力来做，N&lt;=1e9，必TLE。所以本题主要考察了用线段树来模拟数组的理解+一点离散化。 大体思路：原始数列用a数组来存，用b数组来将a数组排序去重（sort,unique），如果不懂unique请点击这。再用一个线段树来模拟b数组，从1开始，找到a[i]在b数组中的位置，让线段树中的一个变量来存在b数组中对应元素出现的个数，让对应位置的这个变量+1，如果i为奇数，那就找到中位数并输出。 关于如何找中位数：按照我们的方法，当我们枚举到i时，前i个元素出现的次数已经被我们记录，既然b数组已经升序排序了，那我们就直接输出b数组中第（i/2+1）大的元素就行了。 如何用线段树来查找第（i/2+1）大的元素： 我们用l来存对应b数组位置的值，r为以当前节点为父亲的子节点包含的最大元素值，mid为以当前节点为父亲的 _左_ 子节点包含的最大元素值，那我们查找时，只要判断一下（i/2+1）是否比当前节点的mid大就行了，如果小于等于mid，说明在左子树，如果大于mid,说明在右子树，那就继续向下查找。 需要注意的一点是：如果要查找右子树，需要将number(初始为（i/2+1）)减去当前节点的mid，笔者因语文不太好，无法清楚明白地解释原因，请读者自行理解。。。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 100010using namespace std;int sc() &#123; //快读 int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;int n;int a[Maxn],b[Maxn];int L[Maxn*4],R[Maxn*4],Mid[Maxn*4],num[Maxn*4]; //线段树 namespace DY &#123; void build(int k,int l,int r) &#123; //建树 L[k]=l; R[k]=r; Mid[k]=l+r&gt;&gt;1; if(l== r) return ; //说明是最后的叶节点，跳出 build(k&lt;&lt;1, l, Mid[k]); build(k&lt;&lt;1|1, Mid[k]+1, r); &#125; void modify(int k,int now) &#123; //修改 num[k]++; //num++ if(L[k]== R[k]) return ; if(now&lt;=Mid[k]) modify(k&lt;&lt;1, now); if(now&gt;Mid[k]) modify(k&lt;&lt;1|1, now); &#125; int query(int k,int number) &#123; //查询 if(L[k]==R[k]) return L[k]; //返回当前节点的值 if(number&lt;=num[k&lt;&lt;1]) return query(k&lt;&lt;1, number); else return query(k&lt;&lt;1|1, number-num[k&lt;&lt;1]); &#125; void main() &#123; n=sc(); //输入 for(int i=1; i&lt;=n; i++) &#123; a[i]=sc(); b[i]=a[i]; &#125; build(1,1,n); //建树 sort(b+1,b+n+1); //升序排序 int len=unique(b+1,b+n+1)-b; //去重 for(int i=1; i&lt;=n; i++) &#123; int now=lower_bound(b+1,b+len+1,a[i])-b; //找到a[i]在b[]的位置 modify(1,now); //将其对应num++ if((i&amp;1)==1) &#123; //如果i为奇数 printf(\"%d\\n\",b[query(1,i/2+1)]); //输出第i/2+1大的元素 &#125; &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; RP++","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"}]},{"title":"好一个一中腰鼓！","slug":"TJ_haoyigeyizhongyaogu","date":"2019-04-04T16:00:00.000Z","updated":"2019-08-01T14:17:55.654Z","comments":true,"path":"2019/04/05/TJ_haoyigeyizhongyaogu/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/04/05/TJ_haoyigeyizhongyaogu/","excerpt":"题目链接：好一个一中腰鼓！","text":"题目链接：好一个一中腰鼓！ 题目标签：线段树 题意：给定一个01串，刚开始全为0（当然也可以为1，跟我所描述的相反即可），支持一种操作：将第u个数值反转。求每次反转之后，整个连续01串的最大值。 题目分析：这道题是关于线段树的应用问题，而不再是一些数值运算。现在线段树中一个节点要包含5个值：从左边开始连续01串的最大值，从右边开始连续01串的最大值，整个连续01串的最大值，01串左节点的值，01串右节点的值，区间长度。具体怎么更新不太好解释，详见代码注释吧！ AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 20010using namespace std;int sc() &#123; //快读 int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;int n,m;int L[Maxn*4],R[Maxn*4],data_l[Maxn*4],data_r[Maxn*4],Mid[Maxn*4],Len[Maxn*4]; //L为左端点开始最大值，R为右端点开始最大值，data_l为左端点值，data_r为右端点值，Mid为整个最大值，Len为区间长度。 namespace DY &#123; void Updata(int k) &#123; L[k]=L[k&lt;&lt;1]; R[k]=R[k&lt;&lt;1|1]; //当前节点的左端点开始最大值（以后简称左开最大值），和右开最大值即为左儿子的左开最大值和右儿子的右开最大值。 data_l[k]=data_l[k&lt;&lt;1]; data_r[k]=data_r[k&lt;&lt;1|1]; //当前节点的左端点值为左儿子的左端点值，右端点值为右儿子的右端点值。 Mid[k]=max(R[k&lt;&lt;1],Mid[k&lt;&lt;1]); Mid[k]=max(Mid[k], max(L[k&lt;&lt;1|1], Mid[k&lt;&lt;1|1])); //整个最大值为 max(左儿子的右开最大值，整个最大值) 和 max(右儿子的左开最大值，整个最大值) 的最大值 //注意：一定要左儿子和左儿子比，右儿子和右儿子比，否则会有问题。 if(data_r[k&lt;&lt;1]!= data_l[k&lt;&lt;1|1]) &#123; //当左端点右值和右端点左值不相等时，即为合法的01串 Mid[k]=max(Mid[k], R[k&lt;&lt;1]+L[k&lt;&lt;1|1]); //更新整个最大值 if(L[k&lt;&lt;1]== Len[k&lt;&lt;1]) //如果左儿子 左开最大值等于 左区间长度，说明左右区间相连，因此，当前节点的左开最大值要加上右儿子的左开最大值 。 L[k]+=L[k&lt;&lt;1|1]; if(R[k&lt;&lt;1|1]== Len[k&lt;&lt;1|1]) //同上解释 R[k]+=R[k&lt;&lt;1]; &#125; &#125; void build(int k,int l,int r) &#123; //建树 Len[k]=r-l+1; //计算区间长度 （为了方便以后判断） if(l==r) &#123; L[k]=R[k]=Mid[k]=1; //长度初值为1（它自己的长度） data_l[k]=data_r[k]=0; //数值初值为0 return ; &#125; int mid=l+r&gt;&gt;1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); Updata(k); //更新数据 &#125; void modify(int k,int l,int r,int now) &#123; //修改 if(l==r) &#123; data_l[k]=data_r[k]=~(data_r[k]); //0变1 1变0 即为取反（~） return ; &#125; int mid=l+r&gt;&gt;1; if(now&lt;=mid) modify(k&lt;&lt;1, l, mid, now); if(now&gt;mid) modify(k&lt;&lt;1|1, mid+1, r, now); Updata(k); //更新数据 &#125; void main() &#123; n=sc(); m=sc(); build(1,1,n); //建树 while(m--) &#123; int u=sc(); modify(1,1,n,u); //修改 printf(\"%d\\n\",Mid[1]); //Mid[1]即为整个序列最大01串的长度 &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; 总体来说，本题很好地加深了对线段树应用的理解，大家一定要弄明白（可能本人解释的不太好，但已经尽力了）。","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"}]},{"title":"模板_线段树2","slug":"TJ_muban segment tree2","date":"2019-03-30T16:00:00.000Z","updated":"2019-08-01T14:18:26.132Z","comments":true,"path":"2019/03/31/TJ_muban segment tree2/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/31/TJ_muban segment tree2/","excerpt":"题目链接：【模板】线段树 2 （区间加法、乘法、查询） 题目标签：线段树","text":"题目链接：【模板】线段树 2 （区间加法、乘法、查询） 题目标签：线段树 题目大意：给定一个序列，支持三种操作：区间加法、区间乘法和区间查询，输出每一次 _查询mod p_ 的结果。 题目分析：对于区间加法和区间查询，相信大家在AC完模板1后已经掌握了，那我们着重来分析一下 _区间乘法_ ，根据模板1的经验，我们可以想到——肯定还要打标记，但是怎样打一个合适的懒标记呢？ 区间乘法的LazyTag 我们来假设一下，我们现在有集合S{a,b,c},当它们都加上一个数N，再乘上一个数M，会变成 S{ (a+N) X M), ((b+N) X M),((c+N) X M) }(X意为乘号) 则又可以化为 S{ (a X M+N X M), (b X M+N X M), (c X M+N X M) }即乘法分配律，由此我们可得 _子节点的加法标记要乘父节点的乘法标记加上父节点的加法标记_ ，化成代码即为 123add[子节点]=(add[子节点]*mul[父节点]+add[父节点])%p;mul[子节点]=(mul[子节点]*mul[父节点])%p;data[子节点]=(data[子节点]*mul[父节点]+(r-l+1)*add[父节点])%p; 所以这道题这样做就可以AC了！ 下面是代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define gc getchar()#define Maxn 100010using namespace std;typedef long long ll;ll sc() &#123; //long long 快读 ll xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;ll n,m,p;ll a[Maxn],data[Maxn*4],add[Maxn*4],mul[Maxn*4];namespace DY &#123; void ADD(ll k,ll l,ll r,ll v1,ll v2) &#123; //添加标记，具体解释在上方 add[k]=(add[k]*v2+v1)%p; mul[k]=(mul[k]*v2)%p; data[k]=(data[k]*v2+(r-l+1)*v1)%p; &#125; void pushdown(ll k,ll l,ll r,ll mid) &#123; //下传标记 if(!add[k]&amp;&amp; mul[k]==1) return ; ADD(k&lt;&lt;1, l, mid, add[k], mul[k]); ADD(k&lt;&lt;1|1, mid+1, r, add[k], mul[k]); add[k]=0; mul[k]=1; &#125; void modify(ll k,ll l,ll r,ll x,ll y,ll v1,ll v2) &#123; //修改[x,y] 的数据 +v1 *v2 if(l&gt;=x&amp;&amp; r&lt;=y) return ADD(k,l,r,v1,v2); //添加标记 ll mid=l+r&gt;&gt;1; pushdown(k,l,r,mid); //下传标记 if(x&lt;=mid) modify(k&lt;&lt;1, l, mid, x, y, v1, v2); if(y&gt;mid) modify(k&lt;&lt;1|1, mid+1, r, x, y, v1, v2); data[k]=(data[k&lt;&lt;1]+data[k&lt;&lt;1|1])%p; //更新节点数据 &#125; ll query(ll k,ll l,ll r,ll x,ll y) &#123; //区间求和 if(l&gt;=x&amp;&amp; r&lt;=y) return data[k]; ll mid=l+r&gt;&gt;1,res=0; pushdown(k,l,r,mid); if(x&lt;=mid) res=query(k&lt;&lt;1, l, mid, x, y)%p; if(y&gt;mid) res+=(query(k&lt;&lt;1|1, mid+1, r, x, y)%p); return res%p; &#125; void build(ll k,ll l,ll r) &#123; //建树 mul[k]=1; //乘法标记要赋初值为1 if(l==r) &#123; data[k]=a[l]; return ; &#125; ll mid=l+r&gt;&gt;1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); data[k]=(data[k&lt;&lt;1]+data[k&lt;&lt;1|1])%p; //更新节点数据 &#125; void main() &#123; n=sc(); m=sc(); p=sc(); for(int i=1; i&lt;=n; i++) a[i]=sc(); //输入原始序列 build(1,1,n); //建树 while(m--) &#123; ll flag=sc(); if(flag==1) &#123; //区间乘法 ll u=sc(),v=sc(),num=sc(); modify(1,1,n,u,v,0,num); &#125; else if(flag==2) &#123; //区间加法 ll u=sc(),v=sc(),num=sc(); modify(1,1,n,u,v,num,1); &#125; else &#123; //区间求和 ll u=sc(),v=sc(); printf(\"%lld\\n\",query(1,1,n,u,v)); &#125; &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; RP++","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dyrisingsunlight.github.io/categories/学习笔记/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"}]},{"title":"上帝造题的七分钟2 / 花神游历各国","slug":"TJ_huashenyouligeguo","date":"2019-03-29T16:00:00.000Z","updated":"2019-08-01T14:18:02.797Z","comments":true,"path":"2019/03/30/TJ_huashenyouligeguo/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/30/TJ_huashenyouligeguo/","excerpt":"题目链接：上帝造题的七分钟2 / 花神游历各国 题目标签：线段树 题目大意：给定一个序列，有两种操作，一种是区间求和，另一种是区间修改（全部开平方）。","text":"题目链接：上帝造题的七分钟2 / 花神游历各国 题目标签：线段树 题目大意：给定一个序列，有两种操作，一种是区间求和，另一种是区间修改（全部开平方）。 题目思路：肯定用线段树来修改数值，但如果按照常规修改肯定会TLE，那我们就应该进行优化。 我们来思考一下如何优化，假如我们现在有一个很大的数，经过多次开方，肯定会变为1或0。 看一下图 所以我们只需要设置一个bool数组来判断这个数值是否为1就可以完美解决修改超时的问题。 温馨提示：在区间求和时，给出的l和r可能会l&gt;r，要进行判断。 代码就带不解释了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define gc getchar()#define Maxn 100010using namespace std;typedef long long ll;ll sc() &#123; ll xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;ll n,m;ll a[Maxn],sum[Maxn*4];bool vis[Maxn*4];namespace DY &#123; void modify(ll k,ll l,ll r,ll x,ll y) &#123; if(vis[k]) return ; if(l==r) &#123; sum[k]=sqrt(sum[k]); if(sum[k]==0|| sum[k]==1) vis[k]=1; return ; &#125; ll mid=l+r&gt;&gt;1; if(x&lt;=mid) modify(k&lt;&lt;1, l, mid, x, y); if(y&gt;mid) modify(k&lt;&lt;1|1, mid+1, r, x, y); sum[k]=sum[k&lt;&lt;1]+sum[k&lt;&lt;1|1]; vis[k]=vis[k&lt;&lt;1]&amp;&amp;vis[k&lt;&lt;1|1]; &#125; ll query(ll k,ll l,ll r,ll x,ll y) &#123; if(l&gt;=x&amp;&amp; r&lt;=y) return sum[k]; ll mid=l+r&gt;&gt;1,ans=0; if(x&lt;=mid) ans=query(k&lt;&lt;1, l, mid, x, y); if(y&gt;mid) ans+=query(k&lt;&lt;1|1, mid+1, r, x, y); return ans; &#125; void build(ll k,ll l,ll r) &#123; if(l==r) &#123; sum[k]=a[l]; if(sum[k]==0|| sum[k]==1) vis[k]=1; return ; &#125; ll mid=l+r&gt;&gt;1; build(k&lt;&lt;1, l, mid); build(k&lt;&lt;1|1, mid+1, r); sum[k]=sum[k&lt;&lt;1]+sum[k&lt;&lt;1|1]; vis[k]=vis[k&lt;&lt;1]&amp;&amp;vis[k&lt;&lt;1|1]; &#125; void main() &#123; n=sc(); for(int i=1; i&lt;=n; i++) a[i]=sc(); build(1,1,n); m=sc(); while(m--) &#123; ll flag=sc(),u=sc(),v=sc(); if(u&gt;v) swap(u,v); if(!flag) &#123; modify(1,1,n,u,v); &#125; else &#123; printf(\"%lld\\n\",query(1,1,n,u,v)); &#125; &#125; &#125;&#125;;int main() &#123; DY::main(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://dyrisingsunlight.github.io/tags/线段树/"}]},{"title":"「一本通 1.2 练习 2」扩散","slug":"TJ_diffusion","date":"2019-03-16T16:00:00.000Z","updated":"2019-08-01T14:17:52.868Z","comments":true,"path":"2019/03/17/TJ_diffusion/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/17/TJ_diffusion/","excerpt":"题目链接：「一本通 1.2 练习 2」扩散 题目算法：见 _标签_ （在最下面用’#’和’_’组成）","text":"题目链接：「一本通 1.2 练习 2」扩散 题目算法：见 _标签_ （在最下面用’#’和’_’组成） 题目大意：有n个点，每个时间单位会向四周（上下左右）扩散一个点，并且定义一个概念连通块——图内任何两点都联通（即两个点以及扩散出去的点有公共部分），求形成连通块的最短时间。 题目分析：通过求最小值我们很容易就联想到二分。那么连通块如何求？根据定义，我们直接从第1个点开始广搜，搜完能够扩散的点，看看能否到达剩余n-1个点就可以了。用l,r来枚举时间，具体解释见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define gc getchar()#define Maxn 60using namespace std;int sc() &#123; //快读 int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;struct Map &#123; //建一个结构体来存坐标 int x,y;&#125;a[Maxn];int n,l,r,ans; //ans为最短时间 bool pd[Maxn]; //pd[]为从第1个点开始扩散能到达的点(pd[i]=1，即为第1个点和第i个点联通) queue &lt;int&gt; q; //广搜标配——队列，存序号 namespace DY &#123; int aabs(int x) &#123; //绝对值函数，因为cmath里的abs()的返回值为double类型，安全起见，自己写int类型 return x&gt; 0? x: -x; &#125; int Manhattan(int u,int v) &#123; //求u,v两点的曼哈顿距离，用来判断从u能否扩散到v return aabs(a[u].x-a[v].x)+aabs(a[u].y-a[v].y); &#125; bool check(int mid) &#123; //判断时间为mid时，能否形成连通块 memset(pd,0,sizeof(pd)); //数组清零 q=queue &lt;int&gt; (); //队列清空 q.push(1); //从第1个点出发，当然要入队且记录 pd[1]=1; while(!q.empty()) &#123; //bfs int now=q.front(); q.pop(); for(int i=1; i&lt;=n; i++) &#123; //枚举每一个点 if(pd[i]|| Manhattan(now,i)&gt; 2*mid) continue; //如果这个点被访问过或两个点的曼哈顿距离超过两倍的时间，前者是不用再处理了，后者是不能扩散到。 //为什么曼哈顿距离小于2倍时间到达不了呢？ /*当时间为mid时，第now个点最多扩散mid个距离，第i个点最多也是扩散mid个距离， 当曼哈顿距离比最大扩散距离还大，当然是不能扩散到。*/ pd[i]=1; //记录+入队 q.push(i); &#125; &#125; for(int i=1; i&lt;=n; i++) //判断是否到达每一个点 if(!pd[i]) return 0; //有 没有到达的点，跳出 return 1; //形成连通块 &#125; void main() &#123; n=sc(); //输入 for(int i=1; i&lt;=n; i++) &#123; a[i].x=sc(); a[i].y=sc(); r=max(r,max(a[i].x,a[i].y)); &#125; while(l&lt;=r) &#123; //二分模板 int mid=l+r&gt;&gt;1; if(check(mid)) r=mid-1,ans=mid; //如果能形成连通块，时间越小越好，所以要缩小r else l=mid+1; //形成不了连通块，说明时间不够，所以要扩大l &#125; printf(\"%d\",ans); //输出 &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; 祝各位OIer( _Of course including me_ ) RP++;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://dyrisingsunlight.github.io/tags/二分答案/"},{"name":"bfs","slug":"bfs","permalink":"https://dyrisingsunlight.github.io/tags/bfs/"}]},{"title":"USACO17JAN Cow Dance Show奶牛舞蹈","slug":"TJ_The cow dance","date":"2019-03-15T16:00:00.000Z","updated":"2019-08-01T14:18:33.379Z","comments":true,"path":"2019/03/16/TJ_The cow dance/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/16/TJ_The cow dance/","excerpt":"题目链接：USACO17JAN Cow Dance Show奶牛舞蹈 这是一道二分答案结合优先队列的题目，自我感觉对二分和贪心都有一定的帮助，毕竟是USACO的题目。。。 大体说一下题意：你有n头奶牛，要进行一场表演，表演有一定的时间限制T，每头奶牛要表演a[i]个时间，你可以要求K头奶牛同时表演，求K的最小值。","text":"题目链接：USACO17JAN Cow Dance Show奶牛舞蹈 这是一道二分答案结合优先队列的题目，自我感觉对二分和贪心都有一定的帮助，毕竟是USACO的题目。。。 大体说一下题意：你有n头奶牛，要进行一场表演，表演有一定的时间限制T，每头奶牛要表演a[i]个时间，你可以要求K头奶牛同时表演，求K的最小值。 题目思路：我们不妨设二分的左右变量为奶牛同时表演的数目，同一个函数来判断当前mid是否符合题意，如果符合则缩小r，反之则扩大l，最终答案即为l。 但是 _判断函数_ 怎么写？ 如果按照模拟求解，显然会TLE，所以我们要进行相应的优化。 判断函数优化思路让我们先来想一下怎样模拟——将a数组降序排列，然后每次枚举mid个，通过很复杂的处理来求出时间总和，最后再进行判断是否小于T。 那我们不妨这样想，既然要求最小时间，那我们何不用一个小根堆来存放时间，先把mid个时间放进去，再把剩余（n-mid）个的时间加到排好序的小根堆里，同时进行判断，如果不符题意，直接return 0，处理完这一步后，我们再取小根堆里前mid个数值进行判断，通过这两步判断，没有return的肯定符合题意。 我们来思考一下，小根堆每次都要清零吗？ 我们每次check，都会往原时间上加内容，所以肯定比原时间要大，由此小根堆不需要清零，这也是用小根堆的好处，清零会浪费大量的时间，极有可能会TLE。 那最后就是上代码了，有思路的同学就不要往下看了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define gc getchar()#define Maxn 10010 //数据最大值 using namespace std;int ead() &#123; //快读优化 int xx=0,ff=1; char cch; while(cch&lt;'0'|| cch&gt;'9') &#123; if(cch=='-') ff=-ff; cch=gc; &#125; while(cch&gt;='0'&amp;&amp; cch&lt;='9') &#123; xx=xx*10+(cch-48); cch=gc; &#125; return xx*ff;&#125;int n,T,r,l; //n头牛，T个时间 int a[Maxn];priority_queue &lt;int, vector &lt;int&gt;, greater &lt;int&gt; &gt; q; //STL之小根堆 namespace DY &#123; bool check(int x) &#123; //check函数用来判断mid符不符合题意 for(int i=1; i&lt;=x; i++) q.push(a[i]); //去mid个时间放进去 for(int i=x+1; i&lt;=n; i++) &#123; //枚举剩余的牛 int now=q.top(); q.pop(); if(now&gt;T) return 0; //超出时间限制，不符题意 now+=a[i]; //加上时间 q.push(now); //重新进栈 &#125; for(int i=1; i&lt;=x; i++) &#123; //再判断前mid个时间是否合法 int now=q.top(); q.pop(); if(now&gt;T) return 0; //不合法 &#125; return 1; //到最后肯定是符合题意了 &#125; void main() &#123; n=ead(); T=ead(); //输入 for(int i=1; i&lt;=n; i++) a[i]=ead(); l=1; r=n; while(l&lt;=r) &#123; //经典的二分模板 int mid=l+r&gt;&gt;1; if(check(mid)) r=mid-1; else l=mid+1; &#125; printf(\"%d\",l); //输出 &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; 祝大家（ _Of course including me_ ）RP++；","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://dyrisingsunlight.github.io/tags/贪心/"},{"name":"二分答案","slug":"二分答案","permalink":"https://dyrisingsunlight.github.io/tags/二分答案/"},{"name":"优先队列","slug":"优先队列","permalink":"https://dyrisingsunlight.github.io/tags/优先队列/"}]},{"title":"「一本通 1.1 练习 4」家庭作业（带反悔的贪心）","slug":"TJ_homework","date":"2019-03-15T16:00:00.000Z","updated":"2019-08-01T14:17:59.349Z","comments":true,"path":"2019/03/16/TJ_homework/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/16/TJ_homework/","excerpt":"题目来源：《信息学奥赛一本通·提高篇》提供题目的OJ：LOJ题目链接：「一本通 1.1 练习 4」家庭作业","text":"题目来源：《信息学奥赛一本通·提高篇》提供题目的OJ：LOJ题目链接：「一本通 1.1 练习 4」家庭作业 本题目的基本算法——贪心，具体说是带反悔的贪心。题目大意：你有n个项目，每个项目有一定的期限和价值，规定只有在期限内完成这个项目才能获得相应的价值，完成一个项目需要花一个时间单位，求能获得的最大价值。基本思路：带反悔的贪心，先按照期限升序排序，用一个变量记录时间，然后枚举每一个项目，如果时间在期限以内，将价值存入一个小根堆中，如果超出期限，与小根堆的top()进行比较，如果大于top()，则将top()扔掉，加入当前的价值。因为时间原因，代码不写注释了，感觉思路已经很明确了。。。 附件：代码 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;struct HM &#123; int tim,dis; bool operator &lt; (const HM &amp;x) const &#123; return tim&lt;x.tim; &#125;&#125;a[1000010];int n,ans,Time=1;bool pd[1000010];priority_queue &lt;int, vector &lt;int&gt;, greater &lt;int&gt; &gt; q;namespace DY &#123; void main() &#123; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(\"%d%d\",&amp;a[i].tim,&amp;a[i].dis); &#125; sort(a+1,a+1+n); for(int i=1; i&lt;=n; i++) &#123; if(Time&lt;= a[i].tim) Time++,q.push(a[i].dis); else if(a[i].dis&gt;q.top()) q.pop(),q.push(a[i].dis); &#125; while(!q.empty()) &#123; int x=q.top(); q.pop(); ans+=x; &#125; printf(\"%d\",ans); &#125;&#125;;int main() &#123; DY::main(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://dyrisingsunlight.github.io/tags/贪心/"},{"name":"优先队列","slug":"优先队列","permalink":"https://dyrisingsunlight.github.io/tags/优先队列/"}]},{"title":"后缀表达式","slug":"TJ_Postfix expression","date":"2019-03-14T16:00:00.000Z","updated":"2019-08-01T14:18:29.202Z","comments":true,"path":"2019/03/15/TJ_Postfix expression/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/15/TJ_Postfix expression/","excerpt":"这道题应用到了栈的思想，也相当于一个模拟过程。 处理过程：扫描后缀表达式，只要遇到操作数将其进栈，遇到运算符则从栈中弹出两个操作数进行相应运算，将运算结果进栈，然后继续扫描，直到扫完位置，这时，栈底的数即为该后缀表达式的值。","text":"这道题应用到了栈的思想，也相当于一个模拟过程。 处理过程：扫描后缀表达式，只要遇到操作数将其进栈，遇到运算符则从栈中弹出两个操作数进行相应运算，将运算结果进栈，然后继续扫描，直到扫完位置，这时，栈底的数即为该后缀表达式的值。 发一下我的代码（C++） 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt; //头文件 using namespace std;int edg[1010];char s[256]; //全局变量 int dfs(char s[256]) //扫描后缀表达式 &#123; int i=0,top=0,e; while(i&lt;=strlen(s)-2) //扫描到strlen(s)-2 &#123; switch(s[i]) //判断 &#123; case'+':edg[--top]+=edg[top+1];break; //+ case'-':edg[--top]-=edg[top+1];break; //- case'*':edg[--top]*=edg[top+1];break; //* case'/':edg[--top]/=edg[top+1];break; /// default:e=0; while(s[i]!='.') e=e*10+s[i++]-'0'; //检查是否扫描到间隔符号'.' edg[++top]=e;break; &#125; i++; &#125; return edg[top];&#125;int main() //主程序 &#123; gets(s); //输入 printf(\"%d\",dfs(s)); //输出 return 0;&#125; 希望我的代码能够帮助到大家！","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://dyrisingsunlight.github.io/tags/模拟/"},{"name":"栈","slug":"栈","permalink":"https://dyrisingsunlight.github.io/tags/栈/"}]},{"title":"麦当劳叔叔的难题","slug":"TJ_Uncle McDonald's problem","date":"2019-03-14T16:00:00.000Z","updated":"2019-08-01T14:18:46.392Z","comments":true,"path":"2019/03/15/TJ_Uncle McDonald's problem/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/15/TJ_Uncle McDonald's problem/","excerpt":"1这篇题解应该是我征战TG以来第一篇题解，特此纪念。 这道题是个搜索好题，有很多种做法，大体题意就是走迷宫（可以上下左右走），大小为n*n，其中有m个障碍，问你从左下角到右上角的最大步数与最小步数之差。","text":"1这篇题解应该是我征战TG以来第一篇题解，特此纪念。 这道题是个搜索好题，有很多种做法，大体题意就是走迷宫（可以上下左右走），大小为n*n，其中有m个障碍，问你从左下角到右上角的最大步数与最小步数之差。 我们分开来看，最小步数的话，bfs一遍就行了，最大步数的话，写个dfs试试看，万一就卡时间过了呢（这种思想很危险，NOIP千万不能这么想）。。。 bfs的思路：两个队列qx,qy分别存x,y坐标，pd[][]用来判重，dis[i][j]表示到(i,j)的最少步数，应该比较好懂。 dfs的思路：①：直接爆搜，具体解释见代码一。 ②：记忆化搜索，为了不超时，记忆化是个好东西，同样，pd[][]判重，但dis[i][j]表示到(i,j)的步数(是个临时变量，要回溯)，M[][]表示到(i,j)的最大步数(基本确定，只有最后的最大值修改时才会变)，具体解释见代码二。 给各位读者一段话：你的水平不取决于你解决了多少个题，而是取决于你是如何思考的。当你试图去解决一个问题时，你应该先独立思考。如果你实在没有思路，那么你应该去一点一点的读别人的题解，而不是一次性都读完，尽可能确保能有更多的部分是你自己做出来的。之后，仔细思考下，为什么你会想不出来依赖于题解解决的那些部分。千万别抄别人的代码，每个人都有他独特的解题理解方式。所以说……有思路就不要再看我的代码了。附件： 代码一（90Pts） 有一个点TLE，原因是dfs直接爆搜。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int dx[]=&#123;1,-1,0,0&#125;;const int dy[]=&#123;0,0,1,-1&#125;;int n,m,minn,maxx;//minn为最小步数，maxx为最大步数 bool Map[20][20],pd[20][20],vis[20][20];//Map[][]用来存那个点为障碍，其他变量上面有解释，vis[][]和pd[][]一个用处 int dis[20][20];queue &lt;int&gt; qx,qy;namespace DY &#123; void bfs() &#123; qx.push(n);//从左下角出发 qy.push(1);// dis[1][1]=1; pd[n][1]=1; while(!qx.empty()) &#123; int xx=qx.front(),yy=qy.front(); qx.pop(); qy.pop(); for(int i=0; i&lt;4; i++) &#123; int nowx=xx+dx[i],nowy=yy+dy[i];//向四周扩展 if(nowx&gt;0&amp;&amp;nowy&gt;0&amp;&amp;nowx&lt;=n&amp;&amp;nowy&lt;=n&amp;&amp;Map[nowx][nowy]==0&amp;&amp;pd[nowx][nowy]==0) &#123; if(nowx==1&amp;&amp;nowy==n) &#123;//到达右上角，因为bfs的第一个结果一定是最优解，所以可以节省时间 minn=dis[xx][yy]+1; return ; &#125; qx.push(nowx); qy.push(nowy);//把新点入队 pd[nowx][nowy]=1; dis[nowx][nowy]=dis[xx][yy]+1; &#125; &#125; &#125; &#125; void dfs(int xx,int yy,int Dis) &#123;//爆搜 if(xx==1&amp;&amp;yy==n) &#123;//到达右上角 maxx=max(maxx,Dis);//取最大值 return ; &#125; for(int i=0; i&lt;4; i++) &#123; int nowx=xx+dx[i],nowy=yy+dy[i]; if(nowx&gt;0&amp;&amp;nowy&gt;0&amp;&amp;nowx&lt;=n&amp;&amp;nowy&lt;=n&amp;&amp;Map[nowx][nowy]==0&amp;&amp;vis[nowx][nowy]==0) &#123; vis[nowx][nowy]=1; dfs(nowx,nowy,Dis+1);//往下一个点搜 vis[nowx][nowy]=0;//回溯 &#125; &#125; &#125; void main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); Map[x][y]=1;//记录障碍 &#125; bfs();//广搜求最少步数 vis[n][1]=1; dfs(n,1,0);//深搜求最大步数 printf(\"%d\",maxx-minn); &#125;&#125;;int main() &#123; DY::main(); return 0;&#125; 代码二（100Pts）dfs变成了记忆化搜索，节省时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define re registerusing namespace std;const int dx[]=&#123;1,-1,0,0&#125;;const int dy[]=&#123;0,0,1,-1&#125;;int n,m,minn,maxx;bool Map[20][20],pd[20][20];//变量解释见上文或代码一 int dis[20][20],M[20][20];queue &lt;int&gt; qx,qy;namespace DY &#123; inline void control() &#123;//将f[][]赋值给M[][] for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) M[i][j]=dis[i][j]; &#125; inline void bfs() &#123;//广搜解释见代码一 qx.push(n); qy.push(1); pd[n][1]=1; while(!qx.empty()) &#123; int xx=qx.front(),yy=qy.front(); qx.pop(); qy.pop(); for(re int i=0; i&lt;4; i++) &#123; int nowx=xx+dx[i],nowy=yy+dy[i]; if(nowx&gt;0&amp;&amp;nowy&gt;0&amp;&amp;nowx&lt;=n&amp;&amp;nowy&lt;=n&amp;&amp;(!Map[nowx][nowy])&amp;&amp;(!pd[nowx][nowy])) &#123; if(nowx==1&amp;&amp;nowy==n) &#123; minn=dis[xx][yy]+1; return ; &#125; dis[nowx][nowy]=dis[xx][yy]+1; pd[nowx][nowy]=1; qx.push(nowx); qy.push(nowy); &#125; &#125; &#125; &#125; inline void dfs(int xx,int yy) &#123;//记忆化深搜 if(dis[xx][yy]&gt;minn&amp;&amp;dis[xx][yy]&lt;M[xx][yy]) return ;//剪枝，如果到这个点的步数已经比最小值大了，但是却没有以前经过此点的步数多，再见。 if(xx==1&amp;&amp;yy==n) &#123;//到达右上角 if(dis[xx][yy]&gt;maxx) &#123;//取最大值 maxx=dis[xx][yy]; control();//此函数用来更新M[][]即把当前的f[][]赋值给M[][] &#125; return ; &#125; for(int i=0; i&lt;4; i++) &#123; int nowx=xx+dx[i],nowy=yy+dy[i]; if(nowx&gt;0&amp;&amp;nowy&gt;0&amp;&amp;nowx&lt;=n&amp;&amp;nowy&lt;=n&amp;&amp;(!Map[nowx][nowy])&amp;&amp;(!pd[nowx][nowy])) &#123; pd[nowx][nowy]=1; dis[nowx][nowy]=dis[xx][yy]+1; dfs(nowx,nowy);//搜下一个点 pd[nowx][nowy]=0;//回溯 dis[nowx][nowy]=0; &#125; &#125; &#125; inline void main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(re int i=1; i&lt;=m; i++) &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); Map[x][y]=1;//记录障碍 &#125; bfs();//广搜求最少步数 memset(pd,0,sizeof(pd));//清零 memset(dis,0,sizeof(dis)); pd[n][1]=1; dfs(n,1);//深搜求最大步数 // cout&lt;&lt;maxx&lt;&lt;endl&lt;&lt;minn&lt;&lt;endl; printf(\"%d\",maxx-minn); &#125; &#125;;int main() &#123; DY::main(); return 0;&#125; 祝各位OIer(Of course including me) RP++;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://dyrisingsunlight.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://dyrisingsunlight.github.io/tags/bfs/"}]},{"title":"JLOI2009 二叉树问题","slug":"TJ_Binary tree problem","date":"2019-03-14T16:00:00.000Z","updated":"2019-08-01T14:17:49.641Z","comments":true,"path":"2019/03/15/TJ_Binary tree problem/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/15/TJ_Binary tree problem/","excerpt":"这道题用到了树的一些概念，但主要算法还是搜索和模拟，我用了深搜（Deep First Search，简称DFS）。","text":"这道题用到了树的一些概念，但主要算法还是搜索和模拟，我用了深搜（Deep First Search，简称DFS）。主要思路：1.用一个结构体来表示树，l表示左子树，r表示右子树，fa表示父节点，ceng表示当前节点的深度，数组下标表示当前节点的值。2.深度用maxx来表示，每求出一个节点的ceng，就与maxx比较，取大者为maxx，最后的maxx即为深度。3.宽度用一个数组num来记，假设下标为i，num[i]即为第i层有几个节点，通过扫描所有节点来记，记完后sort从大到小一遍，num[1]即为宽度。4.计算距离用dfs函数，参数为now（当前节点），up（上行的次数）,down（下行的次数），加上简单的剪枝，求出结果ans=up*2+down。具体解释见代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct tree//树，见思路 &#123; int fa; int l; int r; int ceng;&#125;t[787878];int n,u,v,ans,maxx=-7878;//n个节点,计算从u到v的距离，ans为距离，maxx为深度 int num[787878];//计算宽度，见思路 bool pd[787878];//用来dfs剪枝 bool cmp(int a,int b)//sort从大到小函数 &#123; return a&gt;b;&#125;void dfs(int now,int up,int down)//计算从u到v的距离 &#123; if(now==v)//到达终点 &#123; ans=up*2+down;//计算距离 return; &#125; if(now&lt;1||now&gt;n) return;//剪枝 pd[now]=true;//记录 if(t[now].l&gt;=1&amp;&amp;t[now].l&lt;=n&amp;&amp;pd[t[now].l]==false) dfs(t[now].l,up,down+1);//搜索左子树，下行次数+1 if(t[now].r&gt;=1&amp;&amp;t[now].r&lt;=n&amp;&amp;pd[t[now].r]==false) dfs(t[now].r,up,down+1);//搜索右子树，下行次数+1 if(t[now].fa&gt;=1&amp;&amp;t[now].fa&lt;=n&amp;&amp;pd[t[now].fa]==false) dfs(t[now].fa,up+1,down);//搜索父节点，上行次数+1 &#125;int main()//主函数 &#123; scanf(\"%d\",&amp;n);//输入 t[1].fa=0; t[1].ceng=1;//处理根节点 for(int i=1;i&lt;=(n-1);i++) &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y);//输入 if(t[x].l==0) t[x].l=y; else t[x].r=y;//记录左右子树 t[y].fa=x;//记录父节点 t[y].ceng=t[x].ceng+1;//记录层数 maxx=max(maxx,t[y].ceng);//计算深度 &#125; scanf(\"%d%d\",&amp;u,&amp;v);//输入 for(int i=1;i&lt;=n;i++) num[t[i].ceng]++;//计算每一层节点的数量 sort(num+1,num+n+1,cmp);//排序，找出宽度 dfs(u,0,0);//搜索从u到v的距离 printf(\"%d\\n%d\\n%d\",maxx,num[1],ans);//输出 return 0;//程序结束 &#125; 希望我的代码能够帮助到大家！","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"https://dyrisingsunlight.github.io/tags/dfs/"},{"name":"二叉树","slug":"二叉树","permalink":"https://dyrisingsunlight.github.io/tags/二叉树/"}]},{"title":"logo语言","slug":"TJ_logo language","date":"2019-03-14T16:00:00.000Z","updated":"2019-08-01T14:18:11.321Z","comments":true,"path":"2019/03/15/TJ_logo language/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/15/TJ_logo language/","excerpt":"这道题其实可以用纯模拟来做，把字符串看做一个算式，‘FD’相当于加，‘BK’相当于减，‘REPEAT’相当于乘，‘【】’相当于（）。详细解释见代码注释。。。","text":"这道题其实可以用纯模拟来做，把字符串看做一个算式，‘FD’相当于加，‘BK’相当于减，‘REPEAT’相当于乘，‘【】’相当于（）。详细解释见代码注释。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char a[260];//字符串 int b[]=&#123;0,1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000&#125;;//用来处理字符串中的位数关系，一直到十亿 int num[7878]=&#123;1&#125;;//用来记录REPEAT(相当于乘)当前的数 int lena,now,pd,numn,len_num;//lena=字符串长度 now=当前距起点的距离 pd=1时表示前进，pd=2时表示后退，pd=3时表示REPEAT//numn表示num数组当前下标 len_num用来为num数组加数 int main()//主程序（程序快乐的开始了） &#123; gets(a);//输入 注：gets 一直读到回车（'\\n'） scanf读到空格（' '） 所以要用gets lena=strlen(a);//记录长度 for(int i=0;i&lt;lena;)//处理 &#123; while(a[i]==' ')//空格跳过 i++; if(i&gt;=lena) break;//判断是否到头 if(a[i]=='[')//当出现‘【’时说明有REPEAT 以便乘num数组 &#123; numn++; i++; continue; &#125; if(a[i]==']')//当出现‘】’时说明REPEAT结束 乘之前的num数组 &#123; numn--; i++; continue; &#125; if(a[i]=='R'&amp;&amp;a[i+1]=='E')//处理REPEAT &#123; pd=3;//防止处理前进或后退 i+=6;//往前处理 while(a[i]==' ')//跳过空格 i++; int ii=0,iii=i;//处理数字 while(a[iii]&gt;='0'&amp;&amp;a[iii]&lt;='9')//符合数字范围 &#123; ii++;//用来记数的位数 iii++;//用来往前处理数字 &#125; int x=0;//数的总和 while(ii)//计算数的总和 &#123; x=int(a[i]-'0')*b[ii]+x;//当前数*位数+原来的数 ii--;//位数-1 i++;//往前处理 &#125; x*=num[numn];//乘之前的REPEAT num[++len_num]=x;//加入新的乘数（REPEAT） &#125; if(a[i]=='F'&amp;&amp;a[i+1]=='D')//处理前进 &#123; i+=2;//往前处理 pd=1;//用来表示前进 continue; &#125; if(a[i]=='B'&amp;&amp;a[i+1]=='K')//处理后退 &#123; i+=2;//同上 pd=2;//用来表示后退 continue; &#125; if(pd!=3)//处理前进或后退而不处理REPEAT &#123; int ii=0,iii=i;//同上 while(a[iii]&gt;='0'&amp;&amp;a[iii]&lt;='9') &#123; ii++; iii++; &#125; int x=0; while(ii) &#123; x=int(a[i]-'0')*b[ii]+x; ii--; i++; &#125; x*=num[numn]; if(pd==1) now+=x;//如果前进 + else if(pd==2) now-=x;//如果后退 - &#125; pd=0;//pd归零 &#125; if(now&lt;0) now=0-now;//处理负数（求绝对值，可用abs(cmath)） printf(\"%d\",now);//输出 return 0;//程序快乐的结束了 &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://dyrisingsunlight.github.io/tags/模拟/"}]},{"title":"USACO13FEB 牛奶调度Milk Scheduling","slug":"TJ_Milk Scheduling","date":"2019-03-14T16:00:00.000Z","updated":"2019-08-01T14:18:15.686Z","comments":true,"path":"2019/03/15/TJ_Milk Scheduling/","link":"","permalink":"https://dyrisingsunlight.github.io/2019/03/15/TJ_Milk Scheduling/","excerpt":"本人思路：拓扑思想+简单模拟1这道题其实并不难，只是用到了拓扑的思想，A奶牛必须在B奶牛挤奶前挤奶，这就形成了一个有向图，点A指向点B。","text":"本人思路：拓扑思想+简单模拟1这道题其实并不难，只是用到了拓扑的思想，A奶牛必须在B奶牛挤奶前挤奶，这就形成了一个有向图，点A指向点B。 我们只需要记一下总量（实际上是每只奶牛挤奶时间的总和），每一次循环将入度为0的奶牛加入要挤奶的数组，并且取挤奶数组的最小值，让在挤奶数组里的奶牛减去最小值，如果一个奶牛挤完奶了，那就删除与它相连的边，并且相连的点入度减一，总时间加上最小值，总量减去最小值*挤奶牛数，直到总量为0结束,如果到这里还不懂可以看代码，代码有更详细的解释。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define maxn 10007using namespace std;int n,m,minn,ans,tot,len; //n奶牛数目 m有先后要求的量 minn挤奶数组的最小值 ans最后答案 tot总量 len挤奶数组长度 int a[maxn],ru[maxn],q[maxn]; //a[]每只奶牛挤奶时间 ru[]每只奶牛的入度 q[]挤奶数组 bool edg[20000][20000]; //二维数组建图（模拟大法好） int main() //程序开始 &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),tot+=a[i]; //输入，并且计算总量 for(int i=1;i&lt;=m;i++) &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); ru[y]++; //x指向y y入度+1 edg[x][y]=1; //建图 &#125; while(tot) //直到总量为0结束 &#123; minn=0x7fffffff; //先赋一个最大值 len=0; memset(q,0,sizeof(q)); //挤奶数组长度、内容清零 for(int i=1;i&lt;=n;i++) &#123; if(!ru[i]&amp;&amp;a[i]&gt;0) q[++len]=i,minn=min(minn,a[i]); //找还有奶并且入度为0的奶牛加入挤奶数组 &amp;&amp; 计算挤奶最小值 &#125; for(int i=1;i&lt;=len;i++) &#123; a[q[i]]-=minn; //每只挤奶奶牛减去最小值 if(a[q[i]]&lt;=0) //处理没奶的奶牛 &#123; for(int j=1;j&lt;=n;j++) &#123; if(edg[q[i]][j]==1) ru[j]--,edg[q[i]][j]=0; //删除和它相连的所有边以及和它相连点的入度 &#125; &#125; &#125; tot-=(minn*len); //总量减去（最小值*挤奶奶牛数） ans+=minn; //需要时间（答案）加上最小值 &#125; printf(\"%d\",ans); //输出 return 0; //程序结束 &#125; 另外嘱咐大家一句：数组一定要够大，否则RE最后祝大家RP++；","categories":[{"name":"题解","slug":"题解","permalink":"https://dyrisingsunlight.github.io/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://dyrisingsunlight.github.io/tags/模拟/"},{"name":"拓扑","slug":"拓扑","permalink":"https://dyrisingsunlight.github.io/tags/拓扑/"}]}]}